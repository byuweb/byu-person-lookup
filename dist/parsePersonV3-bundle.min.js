var commonjsGlobal='undefined'==typeof window?'undefined'==typeof global?'undefined'==typeof self?{}:self:global:window,FUNC_ERROR_TEXT='Expected a function',HASH_UNDEFINED='__lodash_hash_undefined__',INFINITY=1/0,funcTag='[object Function]',genTag='[object GeneratorFunction]',symbolTag='[object Symbol]',reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reEscapeChar=/\\(\\)?/g,reIsHostCtor=/^\[object .+?Constructor\]$/,freeGlobal='object'==typeof commonjsGlobal&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal,freeSelf='object'==typeof self&&self&&self.Object===Object&&self,root=freeGlobal||freeSelf||Function('return this')();/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 *//** Used as the `TypeError` message for "Functions" methods. *//** Used to stand-in for `undefined` hash values. *//** Used as references for various `Number` constants. *//** `Object#toString` result references. *//** Used to match property names within property paths. *//**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 *//** Used to match backslashes in property paths. *//** Used to detect host constructors (Safari). *//** Detect free variable `global` from Node.js. *//** Detect free variable `self`. *//** Used as a reference to the global object. *//**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(a,b){return null==a?void 0:a[b]}/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */function isHostObject(a){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var b=!1;if(null!=a&&'function'!=typeof a.toString)try{b=!!(a+'')}catch(a){}return b}/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype,coreJsData=root['__core-js_shared__'],maskSrcKey=function(){var a=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return a?'Symbol(src)_1.'+a:''}(),funcToString=funcProto.toString,hasOwnProperty=objectProto.hasOwnProperty,objectToString=objectProto.toString,reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$'),Symbol=root.Symbol,splice=arrayProto.splice,Map=getNative(root,'Map'),nativeCreate=getNative(Object,'create'),symbolProto=Symbol?Symbol.prototype:void 0,symbolToString=symbolProto?symbolProto.toString:void 0;/** Used to detect overreaching core-js shims. *//** Used to detect methods masquerading as native. *//** Used to resolve the decompiled source of functions. *//** Used to check objects for own properties. *//**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 *//** Used to detect if a method is native. *//** Built-in value references. *//* Built-in method references that are verified to be native. *//** Used to convert symbols to primitives and strings. *//**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(a){var b=-1,c=a?a.length:0;for(this.clear();++b<c;){var d=a[b];this.set(d[0],d[1])}}/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{}}/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(a){return this.has(a)&&delete this.__data__[a]}/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(a){var b=this.__data__;if(nativeCreate){var c=b[a];return c===HASH_UNDEFINED?void 0:c}return hasOwnProperty.call(b,a)?b[a]:void 0}/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(a){var b=this.__data__;return nativeCreate?b[a]!==void 0:hasOwnProperty.call(b,a)}/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(a,b){var c=this.__data__;return c[a]=nativeCreate&&void 0===b?HASH_UNDEFINED:b,this}// Add methods to `Hash`.
Hash.prototype.clear=hashClear,Hash.prototype['delete']=hashDelete,Hash.prototype.get=hashGet,Hash.prototype.has=hashHas,Hash.prototype.set=hashSet;/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(a){var b=-1,c=a?a.length:0;for(this.clear();++b<c;){var d=a[b];this.set(d[0],d[1])}}/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[]}/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(a){var b=this.__data__,c=assocIndexOf(b,a);if(0>c)return!1;var d=b.length-1;return c==d?b.pop():splice.call(b,c,1),!0}/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(a){var b=this.__data__,c=assocIndexOf(b,a);return 0>c?void 0:b[c][1]}/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(a){return-1<assocIndexOf(this.__data__,a)}/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(a,b){var c=this.__data__,d=assocIndexOf(c,a);return 0>d?c.push([a,b]):c[d][1]=b,this}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear,ListCache.prototype['delete']=listCacheDelete,ListCache.prototype.get=listCacheGet,ListCache.prototype.has=listCacheHas,ListCache.prototype.set=listCacheSet;/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(a){var b=-1,c=a?a.length:0;for(this.clear();++b<c;){var d=a[b];this.set(d[0],d[1])}}/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.__data__={hash:new Hash,map:new(Map||ListCache),string:new Hash}}/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(a){return getMapData(this,a)['delete'](a)}/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(a){return getMapData(this,a).get(a)}/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(a){return getMapData(this,a).has(a)}/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(a,b){return getMapData(this,a).set(a,b),this}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear,MapCache.prototype['delete']=mapCacheDelete,MapCache.prototype.get=mapCacheGet,MapCache.prototype.has=mapCacheHas,MapCache.prototype.set=mapCacheSet;/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(a,b){for(var c=a.length;c--;)if(eq(a[c][0],b))return c;return-1}/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */function baseGet(a,b){b=isKey(b,a)?[b]:castPath(b);for(var c=0,d=b.length;null!=a&&c<d;)a=a[toKey(b[c++])];return c&&c==d?a:void 0}/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(a){if(!isObject(a)||isMasked(a))return!1;var b=isFunction(a)||isHostObject(a)?reIsNative:reIsHostCtor;return b.test(toSource(a))}/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */function baseToString(a){// Exit early for strings to avoid a performance hit in some environments.
if('string'==typeof a)return a;if(isSymbol(a))return symbolToString?symbolToString.call(a):'';var b=a+'';return'0'==b&&1/a==-INFINITY?'-0':b}/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */function castPath(a){return isArray(a)?a:stringToPath(a)}/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(a,b){var c=a.__data__;return isKeyable(b)?c['string'==typeof b?'string':'hash']:c.map}/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(a,b){var c=getValue(a,b);return baseIsNative(c)?c:void 0}/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */function isKey(a,b){if(isArray(a))return!1;var c=typeof a;return!!('number'==c||'symbol'==c||'boolean'==c||null==a||isSymbol(a))||reIsPlainProp.test(a)||!reIsDeepProp.test(a)||null!=b&&a in Object(b)}/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(a){var b=typeof a;return'string'==b||'number'==b||'symbol'==b||'boolean'==b?'__proto__'!==a:null===a}/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(a){return!!maskSrcKey&&maskSrcKey in a}/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */var stringToPath=memoize(function(a){a=toString(a);var b=[];return reLeadingDot.test(a)&&b.push(''),a.replace(rePropName,function(a,c,d,e){b.push(d?e.replace(reEscapeChar,'$1'):c||a)}),b});/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */function toKey(a){if('string'==typeof a||isSymbol(a))return a;var b=a+'';return'0'==b&&1/a==-INFINITY?'-0':b}/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */function toSource(a){if(null!=a){try{return funcToString.call(a)}catch(a){}try{return a+''}catch(a){}}return''}/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */function memoize(a,b){if('function'!=typeof a||b&&'function'!=typeof b)throw new TypeError(FUNC_ERROR_TEXT);var c=function(){var d=arguments,e=b?b.apply(this,d):d[0],f=c.cache;if(f.has(e))return f.get(e);var g=a.apply(this,d);return c.cache=f.set(e,g),g};return c.cache=new(memoize.Cache||MapCache),c}// Assign cache to `_.memoize`.
memoize.Cache=MapCache;/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(a,b){return a===b||a!==a&&b!==b}/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(a){// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 8-9 which returns 'object' for typed array and other constructors.
var b=isObject(a)?objectToString.call(a):'';return b==funcTag||b==genTag}/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(a){var b=typeof a;return!!a&&('object'==b||'function'==b)}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(a){return!!a&&'object'==typeof a}/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */function isSymbol(a){return'symbol'==typeof a||isObjectLike(a)&&objectToString.call(a)==symbolTag}/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */function toString(a){return null==a?'':baseToString(a)}/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */function get(a,b,c){var d=null==a?void 0:baseGet(a,b);return d===void 0?c:d}var lodash_get=get;/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const pickFirst=(a,b)=>a||b;function parseLinks(a){const b=lodash_get(a,'persons__next.href'),c=lodash_get(a,'persons__prev.href');return{next:b,prev:c}}function parseAddresses(a){return 200===a.metadata.validation_response.code?a.values.reduce((a,b)=>{const c=[lodash_get(b,'address_line_1.value',''),lodash_get(b,'address_line_2.value',''),lodash_get(b,'address_line_3.value',''),lodash_get(b,'address_line_4.value','')].filter(a=>0<a.trim().length),d={MAL:'mailing',RES:'residential',WRK:'work',PRM:'permanent'}[b.address_type.value]||b.address_type.value;return Object.assign({},a,{[d]:c})},{}):null}function parseBasic(a){const b=lodash_get(a,'name_lnf.value',''),c=lodash_get(a,'byu_id.value',''),d=lodash_get(a,'net_id.value',''),e=lodash_get(a,'person_id.value','');return{name:b,byuId:c,netId:d,personId:e}}function parseEmailAddresses(a){return 200===a.metadata.validation_response.code?a.values.map(a=>lodash_get(a,'email_address.value','')).filter(a=>!!a).reduce(pickFirst,''):null}function parsePhones(a){return 200===a.metadata.validation_response.code?a.values.map(a=>lodash_get(a,'phone_number.value','')).filter(a=>!!a).reduce(pickFirst,''):null}function parseEmployeeSummaries(a){return 200===a.metadata.validation_response.code?{employeeType:lodash_get(a,'employee_type.value'),department:lodash_get(a,'department.value'),jobTitle:lodash_get(a,'job_title.description')}:null}function parseStudentSummaries(a){if(200!==a.metadata.validation_response.code)return null;const b=lodash_get(a,'student_status.value');return{studentStatus:b}}function parsePerson(a){return Object.assign({addresses:parseAddresses(a.addresses),email:parseEmailAddresses(a.email_addresses),phone:parsePhones(a.phones)},parseBasic(a.basic),parseEmployeeSummaries(a.employee_summaries),parseStudentSummaries(a.student_summaries))}function parsePersonV3(a){const b=a.values.map(parsePerson),{next:c,prev:d}=parseLinks(a.links);return{next:c,prev:d,people:b}}export default parsePersonV3;
