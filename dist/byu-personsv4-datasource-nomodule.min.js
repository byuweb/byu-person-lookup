(function(){'use strict';function e(e,t){let n;"function"==typeof window.CustomEvent?n=new CustomEvent(e,{detail:t}):(n=document.createEvent("CustomEvent"),n.initCustomEvent(e,!0,!1,t)),document.dispatchEvent(n)}/**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function t(e,t){return null==e?void 0:e[t]}/**
     * Checks if `value` is a host object in IE < 9.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
     */function n(e){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(t){}return t}/** Used for built-in method references. */ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function a(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function r(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function s(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */ /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function d(e,t){for(var n=e.length;n--;)if(v(e[n][0],t))return n;return-1}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function o(e,t){t=_(t,e)?[t]:l(t);for(var n=0,a=t.length;null!=e&&n<a;)e=e[y(t[n++])];return n&&n==a?e:void 0}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function i(e){if(!b(e)||h(e))return!1;var t=S(e)||n(e)?le:Y;return t.test(g(e))}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function p(e){// Exit early for strings to avoid a performance hit in some environments.
if("string"==typeof e)return e;if(P(e))return ye?ye.call(e):"";var t=e+"";return"0"==t&&1/e==-$?"-0":t}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast property path array.
     */function l(e){return fe(e)?e:ge(e)}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function u(e,t){var n=e.__data__;return m(t)?n["string"==typeof t?"string":"hash"]:n.map}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function c(e,n){var a=t(e,n);return i(a)?a:void 0}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function _(e,t){if(fe(e))return!1;var n=typeof e;return!!("number"==n||"symbol"==n||"boolean"==n||null==e||P(e))||G.test(e)||!D.test(e)||null!=t&&e in Object(t)}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function m(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function h(e){return!!de&&de in e}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */ /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function y(e){if("string"==typeof e||P(e))return e;var t=e+"";return"0"==t&&1/e==-$?"-0":t}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to process.
     * @returns {string} Returns the source code.
     */function g(e){if(null!=e){try{return oe.call(e)}catch(t){}try{return e+""}catch(t){}}return""}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function f(e,t){if("function"!=typeof e||t&&"function"!=typeof t)throw new TypeError("Expected a function");var n=function(){var a=arguments,r=t?t.apply(this,a):a[0],s=n.cache;if(s.has(r))return s.get(r);var d=e.apply(this,a);return n.cache=s.set(r,d),d};return n.cache=new(f.Cache||s),n}// Assign cache to `_.memoize`.
/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function v(e,t){return e===t||e!==e&&t!==t}/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */ /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function S(e){// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 8-9 which returns 'object' for typed array and other constructors.
var t=b(e)?pe.call(e):"";return t=="[object Function]"||t=="[object GeneratorFunction]"}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function b(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function x(e){return!!e&&"object"==typeof e}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function P(e){return"symbol"==typeof e||x(e)&&pe.call(e)=="[object Symbol]"}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function C(e){return null==e?"":p(e)}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function N(e){const t=ve(e,"persons__next.href"),n=ve(e,"persons__prev.href");return{next:t,prev:n}}function E(e){return 200===e.metadata.validation_response.code?e.values.filter(e=>200===e.metadata.validation_response.code).reduce((e,t)=>{const n=[ve(t,"address_line_1.value",""),ve(t,"address_line_2.value",""),ve(t,"address_line_3.value",""),ve(t,"address_line_4.value","")].filter(e=>0<e.trim().length),a={MAL:"mailing",RES:"residential",WRK:"work",PRM:"permanent"}[t.address_type.value]||t.address_type.value;return Object.assign({},e,{[a]:n})},{}):null}function k(e){const t=ve(e,"name_lnf.value",""),n=ve(e,"byu_id.value",""),a=ve(e,"net_id.value",""),r=ve(e,"person_id.value","");return{name:t,byuId:n,netId:a,personId:r}}function A(e){return 200===e.metadata.validation_response.code?e.values.map(t=>ve(t,"email_address.value","")).filter(t=>!!t).reduce(Se,""):null}function T(e){return 200===e.metadata.validation_response.code?e.values.map(e=>ve(e,"phone_number.value","")).filter(e=>!!e).reduce(Se,""):null}function V(e){if(200!==e.metadata.validation_response.code)return null;const t=ve(e,"is_active.value"),n=t?"Active":"Not Active";return{employeeStatus:`${ve(e,"employee_or_contingent_worker_type.value")} (${n})`,department:ve(e,"supervisory_org.value"),jobTitle:ve(e,"business_title.value"),isActive:t}}function w(e){return e?e.mailing?e.mailing:e.residential?e.mailing:e.permanent?e.permanent:[]:[]}function I(e){const t=e.addresses.work?e.addresses.work:[];return[e.department,e.jobTitle,...t]}function R(e){const t=Object.assign({addresses:E(e.addresses),email:A(e.email_addresses),phone:T(e.phones)},k(e.basic),V(e.employee_summary)),n=w(t.addresses),{email:a,phone:r,name:s,byuId:d,netId:o,employeeStatus:i}=t,p=t.isActive,l=p?I(t):[];return{address:n,email:a,phone:r,name:s,byuId:d,netId:o,employeeStatus:i,showAdditionalInfo:p,additionalInfo:l}}function O(e){const t=e.values.map(R),{next:n,prev:a}=N(e.links);return{next:n,prev:a,people:t}}/*
     * Copyright 2018 Brigham Young University
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *    http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */function j(){xe||(xe=new B(({state:e,token:t,user:n,error:a})=>{// React to change
be=t?t.authorizationHeader:null}))}function z(){return{label:"Search"}}async function L(e,t){if(!be)throw new Error("Not authenticated!");const n=encodeURIComponent(e),a=new URLSearchParams;a.append("search_context","person_lookup"),a.append("search_text",n);const r={method:"GET",headers:new window.Headers({Authorization:be})};a.append("field_sets","basic,addresses,email_addresses,phones,employee_summary"),a.append("page_size","50");const s=t||`${"https://api.byu.edu:443/byuapi/persons/v4"}/?${a.toString()}`,d=await window.fetch(s,r);if(d.ok){const e=await d.json();return O(e)}if(404===d.status)return{};const o=`Error ${d.status} while querying personsv4`;throw new Error(o)}// in disconnectedCallback():
function U(){xe&&xe.disconnect(),xe=null}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */function q(e){let t=Qe.get(e.type);void 0===t&&(t={stringsArray:new WeakMap,keyString:new Map},Qe.set(e.type,t));let n=t.stringsArray.get(e.strings);if(void 0!==n)return n;// If the TemplateStringsArray is new, generate a key from the strings
// This key is shared between all templates with identical content
const a=e.strings.join(Te);// Check if we already have a Template for this key
return n=t.keyString.get(a),void 0===n&&(n=new Re(e,e.getTemplateElement()),t.keyString.set(a,n)),t.stringsArray.set(e.strings,n),n}/**
     * Removes the list of nodes from a Template safely. In addition to removing
     * nodes from the Template, the Template part indices are updated to match
     * the mutated Template DOM.
     *
     * As the template is walked the removal state is tracked and
     * part indices are adjusted as needed.
     *
     * div
     *   div#1 (remove) <-- start removing (removing node is div#1)
     *     div
     *       div#2 (remove)  <-- continue removing (removing node is still div#1)
     *         div
     * div <-- stop removing since previous sibling is the removing node (div#1,
     * removed 4 nodes)
     */function F(e,t){const{element:{content:a},parts:n}=e,r=document.createTreeWalker(a,et,null,!1);let s=nt(n),d=n[s],o=-1,i=0;const p=[];for(let a=null;r.nextNode();){o++;const e=r.currentNode;// End removal if stepped past the removing node
for(e.previousSibling===a&&(a=null),t.has(e)&&(p.push(e),null===a&&(a=e)),null!==a&&i++;d!==void 0&&d.index===o;)// If part is in a removed node deactivate it by setting index to -1 or
// adjust the index as needed.
// go to the next active part.
d.index=null===a?d.index-i:-1,s=nt(n,s),d=n[s]}p.forEach(e=>e.parentNode.removeChild(e))}/**
     * Inserts the given node into the Template, optionally before the given
     * refNode. In addition to inserting the node into the Template, the Template
     * part indices are updated to match the mutated Template DOM.
     */function H(e,t,n=null){const{element:{content:r},parts:a}=e;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===n||void 0===n)return void r.appendChild(t);const s=document.createTreeWalker(r,et,null,!1);let d=nt(a),o=0,i=-1;for(;s.nextNode();){i++;const e=s.currentNode;for(e===n&&(o=tt(t),n.parentNode.insertBefore(t,n));-1!==d&&a[d].index===i;){// If we've inserted the node, simply adjust all subsequent parts
if(0<o){for(;-1!==d;)a[d].index+=o,d=nt(a,d);return}d=nt(a,d)}}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ // Get a key to lookup in `templateCaches`.
const M=`${"byu-browser-oauth"}-state-changed`;/*
     * Copyright 2018 Brigham Young University
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */class B{constructor(t,{notifyCurrent:n=!0}={}){this._listener=function(n){t(n.detail)},document.addEventListener(M,this._listener,!1),n&&e(`${"byu-browser-oauth"}-current-info-requested`,{callback:t})}disconnect(){document.removeEventListener(M,this._listener,!1)}}var W="undefined"==typeof globalThis?"undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?{}:self:global:window:globalThis,$=1/0,D=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,G=/^\w*$/,K=/^\./,J=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Q=/[\\^$.*+?()[\]{}|]/g,X=/\\(\\)?/g,Y=/^\[object .+?Constructor\]$/,Z="object"==typeof W&&W&&W.Object===Object&&W,ee="object"==typeof self&&self&&self.Object===Object&&self,te=Z||ee||Function("return this")(),ne=Array.prototype,ae=Function.prototype,re=Object.prototype,se=te["__core-js_shared__"],de=function(){var e=/[^.]+$/.exec(se&&se.keys&&se.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),oe=ae.toString,ie=re.hasOwnProperty,pe=re.toString,le=RegExp("^"+oe.call(ie).replace(Q,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ue=te.Symbol,ce=ne.splice,_e=c(te,"Map"),me=c(Object,"create"),he=ue?ue.prototype:void 0,ye=he?he.toString:void 0;/**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */ /** Used as the `TypeError` message for "Functions" methods. */a.prototype.clear=function(){this.__data__=me?me(null):{}}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */,a.prototype["delete"]=function(e){return this.has(e)&&delete this.__data__[e]}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */,a.prototype.get=function(e){var t=this.__data__;if(me){var n=t[e];return n==="__lodash_hash_undefined__"?void 0:n}return ie.call(t,e)?t[e]:void 0}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */,a.prototype.has=function(e){var t=this.__data__;return me?t[e]!==void 0:ie.call(t,e)}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */,a.prototype.set=function(e,t){var n=this.__data__;return n[e]=me&&void 0===t?"__lodash_hash_undefined__":t,this}// Add methods to `Hash`.
,r.prototype.clear=function(){this.__data__=[]}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */,r.prototype["delete"]=function(e){var t=this.__data__,n=d(t,e);if(0>n)return!1;var a=t.length-1;return n==a?t.pop():ce.call(t,n,1),!0}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */,r.prototype.get=function(e){var t=this.__data__,n=d(t,e);return 0>n?void 0:t[n][1]}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */,r.prototype.has=function(e){return-1<d(this.__data__,e)}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */,r.prototype.set=function(e,t){var n=this.__data__,a=d(n,e);return 0>a?n.push([e,t]):n[a][1]=t,this}// Add methods to `ListCache`.
,s.prototype.clear=function(){this.__data__={hash:new a,map:new(_e||r),string:new a}}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */,s.prototype["delete"]=function(e){return u(this,e)["delete"](e)}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */,s.prototype.get=function(e){return u(this,e).get(e)}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */,s.prototype.has=function(e){return u(this,e).has(e)}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */,s.prototype.set=function(e,t){return u(this,e).set(e,t),this}// Add methods to `MapCache`.
;var ge=f(function(e){e=C(e);var t=[];return K.test(e)&&t.push(""),e.replace(J,function(e,n,a,r){t.push(a?r.replace(X,"$1"):n||e)}),t});f.Cache=s;var fe=Array.isArray,ve=function(e,t,n){var a=null==e?void 0:o(e,t);return a===void 0?n:a};/*
     * Copyright 2018 Brigham Young University
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *    http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */const Se=(e,t)=>e||t;let be=null,xe=null;const Pe=new WeakMap,Ce=e=>"function"==typeof e&&Pe.has(e),Ne=window.customElements!==void 0&&window.customElements.polyfillWrapFlushCallback!==void 0,Ee=(e,t,n=null)=>{for(let a=t;a!==n;){const t=a.nextSibling;e.removeChild(a),a=t}},ke={},Ae={},Te=`{{lit-${(Math.random()+"").slice(2)}}}`,Ve=`<!--${Te}-->`,we=new RegExp(`${Te}|${Ve}`),Ie="$lit$";/**
     * An updateable Template that tracks the location of dynamic parts.
     */class Re{constructor(e,t){this.parts=[],this.element=t;let n=-1,a=0;const r=[],s=t=>{const d=t.content,o=document.createTreeWalker(d,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
for(// Keeps track of the last index associated with a part. We try to delete
// unnecessary nodes, but we never want to associate two different parts
// to the same index. They must have a constant node between.
let d=0;o.nextNode();){n++;const t=o.currentNode;if(1===t.nodeType/* Node.ELEMENT_NODE */){if(t.hasAttributes()){const r=t.attributes;// Per
// https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order.
// In particular, Edge/IE can return them out of order, so we cannot
// assume a correspondance between part index and attribute index.
let s=0;for(let e=0;e<r.length;e++)0<=r[e].value.indexOf(Te)&&s++;for(;0<s--;){// Get the template literal section leading up to the first
// expression in this attribute
const r=e.strings[a],s=ze.exec(r)[2],d=s.toLowerCase()+Ie,o=t.getAttribute(d),i=o.split(we);// Find the attribute name
this.parts.push({type:"attribute",index:n,name:s,strings:i}),t.removeAttribute(d),a+=i.length-1}}"TEMPLATE"===t.tagName&&s(t)}else if(3===t.nodeType/* Node.TEXT_NODE */){const e=t.data;if(0<=e.indexOf(Te)){const s=t.parentNode,d=e.split(we),o=d.length-1;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let e=0;e<o;e++)s.insertBefore(""===d[e]?je():document.createTextNode(d[e]),t),this.parts.push({type:"node",index:++n});// If there's no text, we must insert a comment to mark our place.
// Else, we can trust it will stick around after cloning.
// We have a part for each match found
""===d[o]?(s.insertBefore(je(),t),r.push(t)):t.data=d[o],a+=o}}else if(8===t.nodeType/* Node.COMMENT_NODE */)if(t.data===Te){const e=t.parentNode;// Add a new marker node to be the startNode of the Part if any of
// the following are true:
//  * We don't have a previousSibling
//  * The previousSibling is already the start of a previous part
(null===t.previousSibling||n===d)&&(n++,e.insertBefore(je(),t)),d=n,this.parts.push({type:"node",index:n}),null===t.nextSibling?t.data="":(r.push(t),n--),a++}else for(let e=-1;-1!==(e=t.data.indexOf(Te,e+1));)// Comment node has a binding marker inside, make an inactive part
// The binding won't work, but subsequent bindings will
// TODO (justinfagnani): consider whether it's even worth it to
// make bindings in comments work
this.parts.push({type:"node",index:-1})}};s(t);// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const a of r)a.parentNode.removeChild(a)}}const Oe=e=>-1!==e.index,je=()=>document.createComment(""),ze=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */class Le{constructor(e,t,n){this._parts=[],this.template=e,this.processor=t,this.options=n}update(e){let t=0;for(const n of this._parts)void 0!==n&&n.setValue(e[t]),t++;for(const t of this._parts)void 0!==t&&t.commit()}_clone(){// When using the Custom Elements polyfill, clone the node, rather than
// importing it, to keep the fragment in the template's document. This
// leaves the fragment inert so custom elements won't upgrade and
// potentially modify their contents by creating a polyfilled ShadowRoot
// while we traverse the tree.
const e=Ne?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=this.template.parts;let n=0,a=0;const r=e=>{// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const s=document.createTreeWalker(e,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Loop through all the nodes and parts of a template
for(let d=s.nextNode();n<t.length&&null!==d;){const e=t[n];// Consecutive Parts may have the same node index, in the case of
// multiple bound attributes on an element. So each iteration we either
// increment the nodeIndex, if we aren't on a node with a part, or the
// partIndex if we are. By not incrementing the nodeIndex when we find a
// part, we allow for the next part to be associated with the current
// node if neccessasry.
if(!Oe(e))this._parts.push(void 0),n++;else if(a===e.index){if("node"===e.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(d.previousSibling),this._parts.push(e)}else this._parts.push(...this.processor.handleAttributeExpressions(d,e.name,e.strings,this.options));n++}else a++,"TEMPLATE"===d.nodeName&&r(d.content),d=s.nextNode()}};return r(e),Ne&&(document.adoptNode(e),customElements.upgrade(e)),e}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */class Ue{constructor(e,t,n,a){this.strings=e,this.values=t,this.type=n,this.processor=a}/**
         * Returns a string of HTML used to create a `<template>` element.
         */getHTML(){const e=this.strings.length-1;let t="";for(let n=0;n<e;n++){const e=this.strings[n],a=ze.exec(e);// This exec() call does two things:
// 1) Appends a suffix to the bound attribute name to opt out of special
// attribute value parsing that IE11 and Edge do, like for style and
// many SVG attributes. The Template class also appends the same suffix
// when looking up attributes to create Parts.
// 2) Adds an unquoted-attribute-safe marker for the first expression in
// an attribute. Subsequent attribute expressions will use node markers,
// and this is safe since attributes with multiple expressions are
// guaranteed to be quoted.
t+=a?e.substr(0,a.index)+a[1]+a[2]+Ie+a[3]+Te:e+Ve}return t+this.strings[e]}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */const qe=e=>null===e||"object"!=typeof e&&"function"!=typeof e;/**
     * Sets attribute values for AttributeParts, so that the value is only set once
     * even if there are multiple parts for an attribute.
     */class Fe{constructor(e,t,n){this.dirty=!0,this.element=e,this.name=t,this.strings=n,this.parts=[];for(let a=0;a<n.length-1;a++)this.parts[a]=this._createPart()}/**
         * Creates a single part. Override this to create a differnt type of part.
         */_createPart(){return new He(this)}_getValue(){const e=this.strings,t=e.length-1;let n="";for(let a=0;a<t;a++){n+=e[a];const t=this.parts[a];if(void 0!==t){const e=t.value;if(null!=e&&(Array.isArray(e)||// tslint:disable-next-line:no-any
"string"!=typeof e&&e[Symbol.iterator]))for(const a of e)n+="string"==typeof a?a:a+"";else n+="string"==typeof e?e:e+""}}return n+=e[t],n}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class He{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===ke||qe(e)&&e===this.value||(this.value=e,!Ce(e)&&(this.committer.dirty=!0))}commit(){for(;Ce(this.value);){const e=this.value;this.value=ke,e(this)}this.value===ke||this.committer.commit()}}class Me{constructor(e){this.value=void 0,this._pendingValue=void 0,this.options=e}/**
         * Inserts this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */appendInto(e){this.startNode=e.appendChild(je()),this.endNode=e.appendChild(je())}/**
         * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
         * its next sibling must be static, unchanging nodes such as those that appear
         * in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}/**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */appendIntoPart(e){e._insert(this.startNode=je()),e._insert(this.endNode=je())}/**
         * Appends this part after `ref`
         *
         * This part must be empty, as its contents are not automatically moved.
         */insertAfterPart(e){e._insert(this.startNode=je()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this._pendingValue=e}commit(){for(;Ce(this._pendingValue);){const e=this._pendingValue;this._pendingValue=ke,e(this)}const e=this._pendingValue;e===ke||(qe(e)?e!==this.value&&this._commitText(e):e instanceof Ue?this._commitTemplateResult(e):e instanceof Node?this._commitNode(e):Array.isArray(e)||// tslint:disable-next-line:no-any
e[Symbol.iterator]?this._commitIterable(e):e===Ae?(this.value=Ae,this.clear()):this._commitText(e))}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_commitNode(e){this.value===e||(this.clear(),this._insert(e),this.value=e)}_commitText(e){const t=this.startNode.nextSibling;e=null==e?"":e,t===this.endNode.previousSibling&&3===t.nodeType/* Node.TEXT_NODE */?t.data=e:this._commitNode(document.createTextNode("string"==typeof e?e:e+"")),this.value=e}_commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value instanceof Le&&this.value.template===t)this.value.update(e.values);else{// Make sure we propagate the template processor from the TemplateResult
// so that we use its syntax extension, etc. The template factory comes
// from the render function options so that it can control template
// caching and preprocessing.
const n=new Le(t,e.processor,this.options),a=n._clone();n.update(e.values),this._commitNode(a),this.value=n}}_commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const t=this.value;let n,a=0;for(const r of e)// Try to reuse an existing part
n=t[a],void 0===n&&(n=new Me(this.options),t.push(n),0==a?n.appendIntoPart(this):n.insertAfterPart(t[a-1])),n.setValue(r),n.commit(),a++;a<t.length&&(t.length=a,this.clear(n&&n.endNode))}clear(e=this.startNode){Ee(this.startNode.parentNode,e.nextSibling,this.endNode)}}/**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */class Be{constructor(e,t,n){if(this.value=void 0,this._pendingValue=void 0,2!==n.length||""!==n[0]||""!==n[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=n}setValue(e){this._pendingValue=e}commit(){for(;Ce(this._pendingValue);){const e=this._pendingValue;this._pendingValue=ke,e(this)}if(this._pendingValue!==ke){const e=!!this._pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=e,this._pendingValue=ke}}}/**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */class We extends Fe{constructor(e,t,n){super(e,t,n),this.single=2===n.length&&""===n[0]&&""===n[1]}_createPart(){return new $e(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class $e extends He{}// Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.
let De=!1;try{const e={get capture(){return De=!0,!1}};// tslint:disable-next-line:no-any
// tslint:disable-next-line:no-any
window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}class Ge{constructor(e,t,n){this.value=void 0,this._pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=n,this._boundHandleEvent=t=>this.handleEvent(t)}setValue(e){this._pendingValue=e}commit(){for(;Ce(this._pendingValue);){const e=this._pendingValue;this._pendingValue=ke,e(this)}if(this._pendingValue===ke)return;const e=this._pendingValue,t=this.value,n=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive);n&&this.element.removeEventListener(this.eventName,this._boundHandleEvent,this._options),null!=e&&(null==t||n)&&(this._options=Ke(e),this.element.addEventListener(this.eventName,this._boundHandleEvent,this._options)),this.value=e,this._pendingValue=ke}handleEvent(e){"function"==typeof this.value?this.value.call(this.eventContext||this.element,e):this.value.handleEvent(e)}}// We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.
const Ke=e=>e&&(De?{capture:e.capture,passive:e.passive,once:e.once}:e.capture);/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * Creates Parts when a template is instantiated.
     */const Je=new class{/**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */handleAttributeExpressions(e,t,n,a){const r=t[0];if("."===r){const a=new We(e,t.slice(1),n);return a.parts}if("@"===r)return[new Ge(e,t.slice(1),a.eventContext)];if("?"===r)return[new Be(e,t.slice(1),n)];const s=new Fe(e,t,n);return s.parts}/**
         * Create parts for a text-position binding.
         * @param templateFactory
         */handleTextExpression(e){return new Me(e)}},Qe=new Map,Xe=new WeakMap,Ye=(e,t,n)=>{let a=Xe.get(t);a===void 0&&(Ee(t,t.firstChild),Xe.set(t,a=new Me(Object.assign({templateFactory:q},n))),a.appendInto(t)),a.setValue(e),a.commit()};(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.0.0");/**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */const Ze=(e,...t)=>new Ue(e,t,"html",Je),et=133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,tt=e=>{let t=11===e.nodeType/* Node.DOCUMENT_FRAGMENT_NODE */?0:1;for(const n=document.createTreeWalker(e,et,null,!1);n.nextNode();)t++;return t},nt=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(Oe(t))return n}return-1},at=(e,t)=>`${e}--${t}`;/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */let rt=!0;"undefined"==typeof window.ShadyCSS?rt=!1:"undefined"==typeof window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."),rt=!1);/**
     * Template factory which scopes template DOM using ShadyCSS.
     * @param scopeName {string}
     */const st=e=>t=>{const n=at(t.type,e);let a=Qe.get(n);void 0===a&&(a={stringsArray:new WeakMap,keyString:new Map},Qe.set(n,a));let r=a.stringsArray.get(t.strings);if(void 0!==r)return r;const s=t.strings.join(Te);if(r=a.keyString.get(s),void 0===r){const n=t.getTemplateElement();rt&&window.ShadyCSS.prepareTemplateDom(n,e),r=new Re(t,n),a.keyString.set(s,r)}return a.stringsArray.set(t.strings,r),r},dt=["html","svg"],ot=e=>{dt.forEach(t=>{const n=Qe.get(at(t,e));n!==void 0&&n.keyString.forEach(e=>{const{element:{content:t}}=e,n=new Set;// IE 11 doesn't support the iterable param Set constructor
Array.from(t.querySelectorAll("style")).forEach(e=>{n.add(e)}),F(e,n)})})},it=new Set,pt=(e,t,n)=>{it.add(n);// Move styles out of rendered DOM and store.
const a=e.querySelectorAll("style");// If there are no styles, skip unnecessary work
if(0===a.length)return void window.ShadyCSS.prepareTemplateStyles(t.element,n);const r=document.createElement("style");// Collect styles into a single style. This helps us make sure ShadyCSS
// manipulations will not prevent us from being able to fix up template
// part indices.
// NOTE: collecting styles is inefficient for browsers but ShadyCSS
// currently does this anyway. When it does not, this should be changed.
for(let s=0;s<a.length;s++){const e=a[s];e.parentNode.removeChild(e),r.textContent+=e.textContent}// Remove styles from nested templates in this scope.
if(ot(n),H(t,r,t.element.content.firstChild),window.ShadyCSS.prepareTemplateStyles(t.element,n),window.ShadyCSS.nativeShadow){// When in native Shadow DOM, re-add styling to rendered content using
// the style ShadyCSS produced.
const n=t.element.content.querySelector("style");e.insertBefore(n.cloneNode(!0),e.firstChild)}else{t.element.content.insertBefore(r,t.element.content.firstChild);const e=new Set;e.add(r),F(t,e)}},lt=(e,t,n)=>{const a=n.scopeName,r=Xe.has(t),s=t instanceof ShadowRoot&&rt&&e instanceof Ue,d=s&&!it.has(a),o=d?document.createDocumentFragment():t;// When performing first scope render,
// (1) We've rendered into a fragment so that there's a chance to
// `prepareTemplateStyles` before sub-elements hit the DOM
// (which might cause them to render based on a common pattern of
// rendering in a custom element's `connectedCallback`);
// (2) Scope the template with ShadyCSS one time only for this scope.
// (3) Render the fragment into the container and make sure the
// container knows its `part` is the one we just rendered. This ensures
// DOM will be re-used on subsequent renders.
if(Ye(e,o,Object.assign({templateFactory:st(a)},n)),d){const e=Xe.get(o);Xe.delete(o),e.value instanceof Le&&pt(o,e.value.template,a),Ee(t,t.firstChild),t.appendChild(o),Xe.set(t,e)}// After elements have hit the DOM, update styling if this is the
// initial render to this container.
// This is needed whenever dynamic changes are made so it would be
// safest to do every render; however, this would regress performance
// so we leave it up to the user to call `ShadyCSSS.styleElement`
// for dynamic changes.
!r&&s&&window.ShadyCSS.styleElement(t.host)},ut=e=>e,ct=(e,t)=>{if(e in t)for(;t!==Object.prototype;){if(t.hasOwnProperty(e))return Object.getOwnPropertyDescriptor(t,e);t=Object.getPrototypeOf(t)}},_t={toAttribute(e,t){return t===Boolean?e?"":null:t===Object||t===Array?null==e?e:JSON.stringify(e):e},fromAttribute(e,t){return t===Boolean?null!==e:t===Number?null===e?null:+e:t===Object||t===Array?JSON.parse(e):e}},mt=(e,t)=>t!==e&&(t===t||e===e),ht={attribute:!0,type:String,converter:_t,reflect:!1,hasChanged:mt},yt=Promise.resolve(!0),gt=1,ft=4,vt=8,St=16,bt=32;/**
     * Base element class which manages element properties and attributes. When
     * properties change, the `update` method is asynchronously called. This method
     * should be supplied by subclassers to render updates as desired.
     */class xt extends HTMLElement{constructor(){/**
             * Map with keys for any properties that have changed since the last
             * update cycle with previous values.
             */ /**
             * Map with keys of properties that should be reflected when updated.
             */super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=yt,this._hasConnectedResolver=void 0,this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}/**
         * Returns a list of attributes corresponding to the registered properties.
         * @nocollapse
         */static get observedAttributes(){this._finalize();const e=[];for(const[t,n]of this._classProperties){const a=this._attributeNameForProperty(t,n);a!==void 0&&(this._attributeToPropertyMap.set(a,t),e.push(a))}return e}/**
         * Ensures the private `_classProperties` property metadata is created.
         * In addition to `_finalize` this is also called in `createProperty` to
         * ensure the `@property` decorator can add property metadata.
         */ /** @nocollapse */static _ensureClassProperties(){// ensure private storage for property declarations.
if(!this.hasOwnProperty(ut("_classProperties",this))){this._classProperties=new Map;// NOTE: Workaround IE11 not supporting Map constructor argument.
const e=Object.getPrototypeOf(this)._classProperties;e!==void 0&&e.forEach((e,t)=>this._classProperties.set(t,e))}}/**
         * Creates a property accessor on the element prototype if one does not exist.
         * The property setter calls the property's `hasChanged` property option
         * or uses a strict identity check to determine whether or not to request
         * an update.
         * @nocollapse
         */static createProperty(e,t=ht){if(this._ensureClassProperties(),this._classProperties.set(e,t),!t.noAccessor){const t=ct(e,this.prototype);let n;// If there is a super accessor, capture it and "super" to it
if(void 0!==t&&t.set&&t.get){const{set:a,get:r}=t;n={get(){return r.call(this)},set(t){const n=this[e];a.call(this,t),this.requestUpdate(e,n)},configurable:!0,enumerable:!0}}else{const t="symbol"==typeof e?Symbol():`__${e}`;n={get(){return this[t]},set(n){const a=this[e];this[t]=n,this.requestUpdate(e,a)},configurable:!0,enumerable:!0}}Object.defineProperty(this.prototype,e,n)}}/**
         * Creates property accessors for registered properties and ensures
         * any superclasses are also finalized.
         * @nocollapse
         */static _finalize(){if(!(this.hasOwnProperty(ut("finalized",this))&&this.finalized)){// finalize any superclasses
const e=Object.getPrototypeOf(this);// make any properties
// Note, only process "own" properties since this element will inherit
// any properties defined on the superClass, and finalization ensures
// the entire prototype chain is finalized.
if("function"==typeof e._finalize&&e._finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(ut("properties",this))){const e=this.properties,t=[...Object.getOwnPropertyNames(e),...("function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[])];// support symbols in properties (IE11 does not support this)
for(const n of t)// note, use of `any` is due to TypeSript lack of support for symbol in
// index types
this.createProperty(n,e[n])}}}/**
         * Returns the property name for the given attribute `name`.
         * @nocollapse
         */static _attributeNameForProperty(e,t){const n=t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}/**
         * Returns true if a property should request an update.
         * Called when a property value is set and uses the `hasChanged`
         * option for the property if present or a strict identity check.
         * @nocollapse
         */static _valueHasChanged(e,t,n=mt){return n(e,t)}/**
         * Returns the property value for the given attribute value.
         * Called via the `attributeChangedCallback` and uses the property's
         * `converter` or `converter.fromAttribute` property option.
         * @nocollapse
         */static _propertyValueFromAttribute(e,t){const n=t.type,a=t.converter||_t,r="function"==typeof a?a:a.fromAttribute;return r?r(e,n):e}/**
         * Returns the attribute value for the given property value. If this
         * returns undefined, the property will *not* be reflected to an attribute.
         * If this returns null, the attribute will be removed, otherwise the
         * attribute will be set to the value.
         * This uses the property's `reflect` and `type.toAttribute` property options.
         * @nocollapse
         */static _propertyValueToAttribute(e,t){if(void 0===t.reflect)return;const n=t.type,a=t.converter,r=a&&a.toAttribute||_t.toAttribute;return r(e,n)}/**
         * Performs element initialization. By default captures any pre-set values for
         * registered properties.
         */initialize(){this._saveInstanceProperties()}/**
         * Fixes any properties set on the instance before upgrade time.
         * Otherwise these would shadow the accessor and break these properties.
         * The properties are stored in a Map which is played back after the
         * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
         * (<=41), properties created for native platform properties like (`id` or
         * `name`) may not have default values set in the element constructor. On
         * these browsers native properties appear on instances and therefore their
         * default value will overwrite any element default (e.g. if the element sets
         * this.id = 'id' in the constructor, the 'id' will become '' since this is
         * the native platform default).
         */_saveInstanceProperties(){for(const[e]of this.constructor._classProperties)if(this.hasOwnProperty(e)){const t=this[e];delete this[e],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(e,t)}}/**
         * Applies previously saved instance properties.
         */_applyInstanceProperties(){for(const[e,t]of this._instanceProperties)this[e]=t;this._instanceProperties=void 0}connectedCallback(){this._updateState|=bt,this._hasConnectedResolver?(this._hasConnectedResolver(),this._hasConnectedResolver=void 0):this.requestUpdate()}/**
         * Allows for `super.disconnectedCallback()` in extensions while
         * reserving the possibility of making non-breaking feature additions
         * when disconnecting at some point in the future.
         */disconnectedCallback(){}/**
         * Synchronizes property values when attributes change.
         */attributeChangedCallback(e,t,n){t!==n&&this._attributeToProperty(e,n)}_propertyToAttribute(e,t,n=ht){const a=this.constructor,r=a._attributeNameForProperty(e,n);if(r!==void 0){const e=a._propertyValueToAttribute(t,n);// an undefined value does not change the attribute.
if(e===void 0)return;// Track if the property is being reflected to avoid
// setting the property again via `attributeChangedCallback`. Note:
// 1. this takes advantage of the fact that the callback is synchronous.
// 2. will behave incorrectly if multiple attributes are in the reaction
// stack at time of calling. However, since we process attributes
// in `update` this should not be possible (or an extreme corner case
// that we'd like to discover).
// mark state reflecting
// mark state not reflecting
this._updateState|=vt,null==e?this.removeAttribute(r):this.setAttribute(r,e),this._updateState&=~vt}}_attributeToProperty(e,t){// Use tracking info to avoid deserializing attribute value if it was
// just set from a property setter.
if(this._updateState&vt)return;const n=this.constructor,a=n._attributeToPropertyMap.get(e);if(a!==void 0){const e=n._classProperties.get(a)||ht;// mark state reflecting
// mark state not reflecting
this._updateState|=St,this[a]=n._propertyValueFromAttribute(t,e),this._updateState&=~St}}/**
         * Requests an update which is processed asynchronously. This should
         * be called when an element should update based on some state not triggered
         * by setting a property. In this case, pass no arguments. It should also be
         * called when manually implementing a property setter. In this case, pass the
         * property `name` and `oldValue` to ensure that any configured property
         * options are honored. Returns the `updateComplete` Promise which is resolved
         * when the update completes.
         *
         * @param name {PropertyKey} (optional) name of requesting property
         * @param oldValue {any} (optional) old value of requesting property
         * @returns {Promise} A Promise that is resolved when the update completes.
         */requestUpdate(e,t){let n=!0;// if we have a property key, perform property update steps.
if(void 0!==e&&!this._changedProperties.has(e)){const a=this.constructor,r=a._classProperties.get(e)||ht;a._valueHasChanged(this[e],t,r.hasChanged)?(this._changedProperties.set(e,t),!0===r.reflect&&!(this._updateState&St)&&(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,r))):n=!1}return!this._hasRequestedUpdate&&n&&this._enqueueUpdate(),this.updateComplete}/**
         * Sets up the element to asynchronously update.
         */async _enqueueUpdate(){this._updateState|=ft;let e;const t=this._updatePromise;this._updatePromise=new Promise(t=>e=t),await t,this._hasConnected||(await new Promise(e=>this._hasConnectedResolver=e));// Allow `performUpdate` to be asynchronous to enable scheduling of updates.
const n=this.performUpdate();// Note, this is to avoid delaying an additional microtask unless we need
// to.
null!=n&&"function"==typeof n.then&&(await n),e(!this._hasRequestedUpdate)}get _hasConnected(){return this._updateState&bt}get _hasRequestedUpdate(){return this._updateState&ft}get hasUpdated(){return this._updateState&gt}/**
         * Performs an element update.
         *
         * You can override this method to change the timing of updates. For instance,
         * to schedule updates to occur just before the next frame:
         *
         * ```
         * protected async performUpdate(): Promise<unknown> {
         *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
         *   super.performUpdate();
         * }
         * ```
         */performUpdate(){if(this._instanceProperties&&this._applyInstanceProperties(),this.shouldUpdate(this._changedProperties)){const e=this._changedProperties;this.update(e),this._markUpdated(),this._updateState&gt||(this._updateState|=gt,this.firstUpdated(e)),this.updated(e)}else this._markUpdated()}_markUpdated(){this._changedProperties=new Map,this._updateState&=~ft}/**
         * Returns a Promise that resolves when the element has completed updating.
         * The Promise value is a boolean that is `true` if the element completed the
         * update without triggering another update. The Promise result is `false` if
         * a property was set inside `updated()`. This getter can be implemented to
         * await additional state. For example, it is sometimes useful to await a
         * rendered element before fulfilling this Promise. To do this, first await
         * `super.updateComplete` then any subsequent state.
         *
         * @returns {Promise} The Promise returns a boolean that indicates if the
         * update resolved without triggering another update.
         */get updateComplete(){return this._updatePromise}/**
         * Controls whether or not `update` should be called when the element requests
         * an update. By default, this method always returns `true`, but this can be
         * customized to control when to update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */shouldUpdate(e){return!0}/**
         * Updates the element. This method reflects property values to attributes.
         * It can be overridden to render and keep updated element DOM.
         * Setting properties inside this method will *not* trigger
         * another update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */update(e){if(this._reflectingProperties!==void 0&&0<this._reflectingProperties.size){for(const[e,t]of this._reflectingProperties)this._propertyToAttribute(e,this[e],t);this._reflectingProperties=void 0}}/**
         * Invoked whenever the element is updated. Implement to perform
         * post-updating tasks via DOM APIs, for example, focusing an element.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */updated(e){}/**
         * Invoked when the element is first updated. Implement to perform one time
         * work on the element after update.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */firstUpdated(e){}}/**
     * Marks class as having finished creating properties.
     */xt.finalized=!0;/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
    @license
    Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at
    http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
    http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
    found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
    part of the polymer project is also subject to an additional IP rights grant
    found at http://polymer.github.io/PATENTS.txt
    */const Pt="adoptedStyleSheets"in Document.prototype;/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */class Ct extends xt{/**
         * Array of styles to apply to the element. The styles should be defined
         * using the `css` tag function.
         */static get styles(){return[]}static get _uniqueStyles(){if(this._styles===void 0){const e=this.styles,t=e.reduceRight((e,t)=>(e.add(t),e),new Set);// As a performance optimization to avoid duplicated styling that can
// occur especially when composing via subclassing, de-duplicate styles
// preserving the last item in the list. The last item is kept to
// try to preserve cascade order with the assumption that it's most
// important that last added styles override previous styles.
// Array.form does not work on Set in IE
this._styles=[],t.forEach(e=>this._styles.unshift(e))}return this._styles}/**
         * Performs element initialization. By default this calls `createRenderRoot`
         * to create the element `renderRoot` node and captures any pre-set values for
         * registered properties.
         */initialize(){super.initialize(),this.renderRoot=this.createRenderRoot(),window.ShadowRoot&&this.renderRoot instanceof window.ShadowRoot&&this.adoptStyles()}/**
         * Returns the node into which the element should render and by default
         * creates and returns an open shadowRoot. Implement to customize where the
         * element's DOM is rendered. For example, to render into the element's
         * childNodes, return `this`.
         * @returns {Element|DocumentFragment} Returns a node into which to render.
         */createRenderRoot(){return this.attachShadow({mode:"open"})}/**
         * Applies styling to the element shadowRoot using the `static get styles`
         * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
         * available and will fallback otherwise. When Shadow DOM is polyfilled,
         * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
         * is available but `adoptedStyleSheets` is not, styles are appended to the
         * end of the `shadowRoot` to [mimic spec
         * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
         */adoptStyles(){const e=this.constructor._uniqueStyles;0===e.length||(window.ShadyCSS===void 0||window.ShadyCSS.nativeShadow?Pt?this.renderRoot.adoptedStyleSheets=e.map(e=>e.styleSheet):this._needsShimAdoptedStyleSheets=!0:window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e=>e.cssText),this.localName));// There are three separate cases here based on Shadow DOM support.
// (1) shadowRoot polyfilled: use ShadyCSS
// (2) shadowRoot.adoptedStyleSheets available: use it.
// (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
// rendering
}connectedCallback(){super.connectedCallback(),this.hasUpdated&&window.ShadyCSS!==void 0&&window.ShadyCSS.styleElement(this)}/**
         * Updates the element. This method reflects property values to attributes
         * and calls `render` to render DOM via lit-html. Setting properties inside
         * this method will *not* trigger another update.
         * * @param _changedProperties Map of changed properties with old values
         */update(e){super.update(e);const t=this.render();t instanceof Ue&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this}),this._needsShimAdoptedStyleSheets&&(this._needsShimAdoptedStyleSheets=!1,this.constructor._uniqueStyles.forEach(e=>{const t=document.createElement("style");t.textContent=e.cssText,this.renderRoot.appendChild(t)}))}/**
         * Invoked on each update to perform rendering tasks. This method must return
         * a lit-html TemplateResult. Setting properties inside this method will *not*
         * trigger the element to update.
         */render(){}}/**
     * Ensure this class is marked as `finalized` as an optimization ensuring
     * it will not needlessly try to `finalize`.
     */Ct.finalized=!0,Ct.render=lt;/*
     * Copyright 2018 Brigham Young University
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *    http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */const{CustomEvent:Nt}=window,Et=async(e,t,n)=>{try{const{next:a,prev:r,people:s}=await L(e,n);return t.dispatchEvent(new Nt("byu-lookup-datasource-result",{bubbles:!0,detail:s})),{next:a,prev:r}}catch(e){return console.error(e),t.dispatchEvent(new Nt("byu-lookup-datasource-error",{bubbles:!0,detail:e})),{next:null,prev:null}}},kt=e=>{const t=new Nt("byu-lookup-datasource-searching",{bubbles:!0});e.dispatchEvent(t)};class At extends Ct{connectedCallback(){super.connectedCallback(),j();const e=new Nt("byu-lookup-datasource-register",{bubbles:!0});this.dispatchEvent(e)}disconnectedCallback(){super.disconnectedCallback(),U()}static get properties(){return{search:{type:String},next:{type:String},prev:{type:String}}}render(){this.search||(this.search="");const{label:e}=z(this.search);return Ze`${e}`}async performSearch(e){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{kt(this);const{next:t,prev:n}=await Et(e,this);this.next=t,this.prev=n},100)}async nextPage(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{if(this.next){kt(this);const{next:e,prev:t}=await Et(this.search,this,this.next);this.next=e,this.prev=t}},100)}async prevPage(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{if(this.prev){kt(this);const{next:e,prev:t}=await Et(this.search,this,this.prev);this.next=e,this.prev=t}},100)}}console.log("registering personsv4 datasource"),window.customElements.define("byu-personsv4-datasource",At)})();
