window.JSCompiler_renameProperty=function(e){return e};/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/// unique global id for deduping mixins.
let dedupeId=0;/* eslint-disable valid-jsdoc *//**
 * Wraps an ES6 class expression mixin such that the mixin is only applied
 * if it has not already been applied its base argument. Also memoizes mixin
 * applications.
 *
 * @template T
 * @param {T} mixin ES6 class expression mixin to wrap
 * @return {T}
 * @suppress {invalidCasts}
 */const dedupingMixin=function(e){function t(t){let a=/** @type {!MixinFunction} */t.__mixinSet;if(a&&a[r])return t;let i=n,s=i.get(t);s||(s=/** @type {!Function} */e(t),i.set(t,s));// copy inherited mixin set from the extended class, or the base class
// NOTE: we avoid use of Set here because some browser (IE11)
// cannot extend a base Set via the constructor.
let d=Object.create(/** @type {!MixinFunction} */s.__mixinSet||a||null);return d[r]=!0,s.__mixinSet=d,s}let n=/** @type {!MixinFunction} */e.__mixinApplications;n||(n=new WeakMap,e.__mixinApplications=n);// maintain a unique id for each mixin
let r=dedupeId++;return(/** @type {T} */t)};/* eslint-enable valid-jsdoc *//**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/// Microtask implemented using Mutation Observer
let microtaskCurrHandle=0,microtaskLastHandle=0,microtaskCallbacks=[],microtaskNodeContent=0,microtaskNode=document.createTextNode('');new window.MutationObserver(microtaskFlush).observe(microtaskNode,{characterData:!0});function microtaskFlush(){const e=microtaskCallbacks.length;for(let t,n=0;n<e;n++)if(t=microtaskCallbacks[n],t)try{t()}catch(t){setTimeout(()=>{throw t})}microtaskCallbacks.splice(0,e),microtaskLastHandle+=e}/**
 * Async interface for enqueuing callbacks that run at microtask timing.
 *
 * Note that microtask timing is achieved via a single `MutationObserver`,
 * and thus callbacks enqueued with this API will all run in a single
 * batch, and not interleaved with other microtasks such as promises.
 * Promises are avoided as an implementation choice for the time being
 * due to Safari bugs that cause Promises to lack microtask guarantees.
 *
 * @namespace
 * @summary Async interface for enqueuing callbacks that run at microtask
 *   timing.
 */const microTask={/**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */run(e){return microtaskNode.textContent=microtaskNodeContent++,microtaskCallbacks.push(e),microtaskCurrHandle++},/**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */cancel(e){const t=e-microtaskLastHandle;if(0<=t){if(!microtaskCallbacks[t])throw new Error('invalid async handle: '+e);microtaskCallbacks[t]=null}}},microtask=microTask,PropertiesChanged=dedupingMixin(e=>{return(/**
   * @polymer
   * @mixinClass
   * @extends {superClass}
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   */class extends e{/**
     * Creates property accessors for the given property names.
     * @param {!Object} props Object whose keys are names of accessors.
     * @return {void}
     * @protected
     */static createProperties(e){const t=this.prototype;for(let n in e)// don't stomp an existing accessor
n in t||t._createPropertyAccessor(n)}/**
     * Returns an attribute name that corresponds to the given property.
     * The attribute name is the lowercased property name. Override to
     * customize this mapping.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     */static attributeNameForProperty(e){return e.toLowerCase()}/**
     * Override point to provide a type to which to deserialize a value to
     * a given property.
     * @param {string} name Name of property
     *
     * @protected
     */static typeForProperty(){}//eslint-disable-line no-unused-vars
/**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @return {void}
     * @protected
     */_createPropertyAccessor(e,t){this._addPropertyToAttributeMap(e),this.hasOwnProperty('__dataHasAccessor')||(this.__dataHasAccessor=Object.assign({},this.__dataHasAccessor)),this.__dataHasAccessor[e]||(this.__dataHasAccessor[e]=!0,this._definePropertyAccessor(e,t))}/**
     * Adds the given `property` to a map matching attribute names
     * to property names, using `attributeNameForProperty`. This map is
     * used when deserializing attribute values to properties.
     *
     * @param {string} property Name of the property
     */_addPropertyToAttributeMap(e){if(this.hasOwnProperty('__dataAttributes')||(this.__dataAttributes=Object.assign({},this.__dataAttributes)),!this.__dataAttributes[e]){const t=this.constructor.attributeNameForProperty(e);this.__dataAttributes[t]=e}}/**
     * Defines a property accessor for the given property.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     * @return {void}
     */_definePropertyAccessor(e,t){Object.defineProperty(this,e,{/* eslint-disable valid-jsdoc *//** @this {PropertiesChanged} */get(){return this._getProperty(e)},/** @this {PropertiesChanged} */set:t?function(){}:function(t){this._setProperty(e,t)}/* eslint-enable */})}constructor(){super(),this.__dataEnabled=!1,this.__dataReady=!1,this.__dataInvalid=!1,this.__data={},this.__dataPending=null,this.__dataOld=null,this.__dataInstanceProps=null,this.__serializing=!1,this._initializeProperties()}/**
     * Lifecycle callback called when properties are enabled via
     * `_enableProperties`.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its property data initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @return {void}
     * @public
     */ready(){this.__dataReady=!0,this._flushProperties()}/**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @return {void}
     * @protected
     */_initializeProperties(){// Capture instance properties; these will be set into accessors
// during first flush. Don't set them here, since we want
// these to overwrite defaults/constructor assignments
for(let e in this.__dataHasAccessor)this.hasOwnProperty(e)&&(this.__dataInstanceProps=this.__dataInstanceProps||{},this.__dataInstanceProps[e]=this[e],delete this[e])}/**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     */_initializeInstanceProperties(e){Object.assign(this,e)}/**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     * @protected
     */_setProperty(e,t){this._setPendingProperty(e,t)&&this._invalidateProperties()}/**
     * Returns the value for the given property.
     * @param {string} property Name of property
     * @return {*} Value for the given property
     * @protected
     */_getProperty(e){return this.__data[e]}/* eslint-disable no-unused-vars *//**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} ext Not used here; affordance for closure
     * @return {boolean} Returns true if the property changed
     * @protected
     */_setPendingProperty(e,t){let n=this.__data[e],r=this._shouldPropertyChange(e,t,n);return r&&(!this.__dataPending&&(this.__dataPending={},this.__dataOld={}),this.__dataOld&&!(e in this.__dataOld)&&(this.__dataOld[e]=n),this.__data[e]=t,this.__dataPending[e]=t),r}/* eslint-enable *//**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @return {void}
     * @protected
     */_invalidateProperties(){!this.__dataInvalid&&this.__dataReady&&(this.__dataInvalid=!0,microtask.run(()=>{this.__dataInvalid&&(this.__dataInvalid=!1,this._flushProperties())}))}/**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     *
     * @return {void}
     * @protected
     */_enableProperties(){this.__dataEnabled||(this.__dataEnabled=!0,this.__dataInstanceProps&&(this._initializeInstanceProperties(this.__dataInstanceProps),this.__dataInstanceProps=null),this.ready())}/**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     * @return {void}
     * @protected
     */_flushProperties(){const e=this.__data,t=this.__dataPending,n=this.__dataOld;this._shouldPropertiesChange(e,t,n)&&(this.__dataPending=null,this.__dataOld=null,this._propertiesChanged(e,t,n))}/**
     * Called in `_flushProperties` to determine if `_propertiesChanged`
     * should be called. The default implementation returns true if
     * properties are pending. Override to customize when
     * `_propertiesChanged` is called.
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {!Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {!Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {boolean} true if changedProps is truthy
     */_shouldPropertiesChange(e,t){// eslint-disable-line no-unused-vars
return!!t}/**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {!Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {!Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     * @protected
     */_propertiesChanged(){}// eslint-disable-line no-unused-vars
/**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` if a strict equality
     * check fails. The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     */_shouldPropertyChange(e,t,n){return(// Strict equality check
n!==t&&(// This ensures (old==NaN, value==NaN) always returns false
n===n||t===t))}/**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @suppress {missingProperties} Super may or may not implement the callback
     */attributeChangedCallback(e,t,n,r){t!==n&&this._attributeToProperty(e,n),super.attributeChangedCallback&&super.attributeChangedCallback(e,t,n,r)}/**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to, defaults to the value
     * returned from `typeForProperty`
     * @return {void}
     */_attributeToProperty(e,t,n){if(!this.__serializing){const r=this.__dataAttributes,a=r&&r[e]||e;this[a]=this._deserializeValue(t,n||this.constructor.typeForProperty(a))}}/**
     * Serializes a property to its associated attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is an element.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect to.
     * @param {*=} value Property value to refect.
     * @return {void}
     */_propertyToAttribute(e,t,n){this.__serializing=!0,n=3>arguments.length?this[e]:n,this._valueToNodeAttribute(/** @type {!HTMLElement} */this,n,t||this.constructor.attributeNameForProperty(e)),this.__serializing=!1}/**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @return {void}
     */_valueToNodeAttribute(e,t,n){const r=this._serializeValue(t);r===void 0?e.removeAttribute(n):e.setAttribute(n,r)}/**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called when setting JS property values to
     * HTML attributes.  Users may override this method to provide
     * serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided
     * property  value.
     */_serializeValue(e){switch(typeof e){case'boolean':return e?'':void 0;default:return null==e?void 0:e.toString();}}/**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called when reading HTML attribute values to
     * JS properties.  Users may override this method to provide
     * deserialization for custom `type`s. Types for `Boolean`, `String`,
     * and `Number` convert attributes to the expected types.
     *
     * @param {?string} value Value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     */_deserializeValue(e,t){return t===Boolean?null!==e:t===Number?+e:e}})});/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*//** @const {!AsyncInterface} *//**
 * Element class mixin that provides basic meta-programming for creating one
 * or more property accessors (getter/setter pair) that enqueue an async
 * (batched) `_propertiesChanged` callback.
 *
 * For basic usage of this mixin, call `MyClass.createProperties(props)`
 * once at class definition time to create property accessors for properties
 * named in props, implement `_propertiesChanged` to react as desired to
 * property changes, and implement `static get observedAttributes()` and
 * include lowercase versions of any property names that should be set from
 * attributes. Last, call `this._enableProperties()` in the element's
 * `connectedCallback` to enable the accessors.
 *
 * @mixinFunction
 * @polymer
 * @summary Element class mixin for reacting to property changes from
 *   generated property accessors.
 *//**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*//**
 * Creates a copy of `props` with each property normalized such that
 * upgraded it is an object with at least a type property { type: Type}.
 *
 * @param {Object} props Properties to normalize
 * @return {Object} Copy of input `props` with normalized properties that
 * are in the form {type: Type}
 * @private
 */function normalizeProperties(e){const t={};for(let n in e){const r=e[n];t[n]='function'==typeof r?{type:r}:r}return t}/**
 * Mixin that provides a minimal starting point to using the PropertiesChanged
 * mixin by providing a mechanism to declare properties in a static
 * getter (e.g. static get properties() { return { foo: String } }). Changes
 * are reported via the `_propertiesChanged` method.
 *
 * This mixin provides no specific support for rendering. Users are expected
 * to create a ShadowRoot and put content into it and update it in whatever
 * way makes sense. This can be done in reaction to properties changing by
 * implementing `_propertiesChanged`.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Mixin that provides a minimal starting point for using
 * the PropertiesChanged mixin by providing a declarative `properties` object.
 */const PropertiesMixin=dedupingMixin(e=>{/**
  * Returns the super class constructor for the given class, if it is an
  * instance of the PropertiesMixin.
  *
  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {PropertiesMixinConstructor} Super class constructor
  */function t(e){const t=Object.getPrototypeOf(e);// Note, the `PropertiesMixin` class below only refers to the class
// generated by this call to the mixin; the instanceof test only works
// because the mixin is deduped and guaranteed only to apply once, hence
// all constructors in a proto chain will see the same `PropertiesMixin`
return t.prototype instanceof a?/** @type {PropertiesMixinConstructor} */t:null}/**
  * Returns a memoized version of the `properties` object for the
  * given class. Properties not in object format are converted to at
  * least {type}.
  *
  * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {Object} Memoized properties object
  */function n(e){if(!e.hasOwnProperty(JSCompiler_renameProperty('__ownProperties',e))){let t=null;e.hasOwnProperty(JSCompiler_renameProperty('properties',e))&&e.properties&&(t=normalizeProperties(e.properties)),e.__ownProperties=t}return e.__ownProperties}/**
  * @polymer
  * @mixinClass
  * @extends {base}
  * @implements {Polymer_PropertiesMixin}
  * @unrestricted
  *//**
  * @constructor
  * @extends {superClass}
  * @implements {Polymer_PropertiesChanged}
  */const r=PropertiesChanged(e);class a extends r{/**
    * Implements standard custom elements getter to observes the attributes
    * listed in `properties`.
    * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
    */static get observedAttributes(){const e=this._properties;return e?Object.keys(e).map(e=>this.attributeNameForProperty(e)):[]}/**
    * Finalizes an element definition, including ensuring any super classes
    * are also finalized. This includes ensuring property
    * accessors exist on the element prototype. This method calls
    * `_finalizeClass` to finalize each constructor in the prototype chain.
    * @return {void}
    */static finalize(){if(!this.hasOwnProperty(JSCompiler_renameProperty('__finalized',this))){const e=t(/** @type {PropertiesMixinConstructor} */this);e&&e.finalize(),this.__finalized=!0,this._finalizeClass()}}/**
    * Finalize an element class. This includes ensuring property
    * accessors exist on the element prototype. This method is called by
    * `finalize` and finalizes the class constructor.
    *
    * @protected
    */static _finalizeClass(){const e=n(/** @type {PropertiesMixinConstructor} */this);e&&this.createProperties(e)}/**
    * Returns a memoized version of all properties, including those inherited
    * from super classes. Properties not in object format are converted to
    * at least {type}.
    *
    * @return {Object} Object containing properties for this class
    * @protected
    */static get _properties(){if(!this.hasOwnProperty(JSCompiler_renameProperty('__properties',this))){const e=t(/** @type {PropertiesMixinConstructor} */this);this.__properties=Object.assign({},e&&e._properties,n(/** @type {PropertiesMixinConstructor} */this))}return this.__properties}/**
    * Overrides `PropertiesChanged` method to return type specified in the
    * static `properties` object for the given property.
    * @param {string} name Name of property
    * @return {*} Type to which to deserialize attribute
    *
    * @protected
    */static typeForProperty(e){const t=this._properties[e];return t&&t.type}/**
    * Overrides `PropertiesChanged` method and adds a call to
    * `finalize` which lazily configures the element's property accessors.
    * @override
    * @return {void}
    */_initializeProperties(){this.constructor.finalize(),super._initializeProperties()}/**
    * Called when the element is added to a document.
    * Calls `_enableProperties` to turn on property system from
    * `PropertiesChanged`.
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    */connectedCallback(){super.connectedCallback&&super.connectedCallback(),this._enableProperties()}/**
    * Called when the element is removed from a document
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    */disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback()}}return a}),templateCaches=new Map;/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*//**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */// The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */class TemplateResult{constructor(e,t,n,r=defaultPartCallback){this.strings=e,this.values=t,this.type=n,this.partCallback=r}/**
     * Returns a string of HTML used to create a <template> element.
     */getHTML(){const e=this.strings.length-1;let t='',n=!0;for(let r=0;r<e;r++){const e=this.strings[r];t+=e;// We're in a text position if the previous string closed its tags.
// If it doesn't have any tags, then we use the previous text position
// state.
const a=findTagClose(e);n=-1<a?a<e.length:n,t+=n?nodeMarker:marker}return t+=this.strings[e],t}getTemplateElement(){const e=document.createElement('template');return e.innerHTML=this.getHTML(),e}}/**
 * A TemplateResult for SVG fragments.
 *
 * This class wraps HTMl in an <svg> tag in order to parse its contents in the
 * SVG namespace, then modifies the template to remove the <svg> tag so that
 * clones only container the original fragment.
 */class SVGTemplateResult extends TemplateResult{getHTML(){return`<svg>${super.getHTML()}</svg>`}getTemplateElement(){const e=super.getTemplateElement(),t=e.content,n=t.firstChild;return t.removeChild(n),reparentNodes(t,n.firstChild),e}}/**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */function defaultTemplateFactory(e){let t=templateCaches.get(e.type);void 0===t&&(t=new Map,templateCaches.set(e.type,t));let n=t.get(e.strings);return void 0===n&&(n=new Template(e,e.getTemplateElement()),t.set(e.strings,n)),n}/**
 * Renders a template to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 *
 * @param result a TemplateResult created by evaluating a template tag like
 *     `html` or `svg`.
 * @param container A DOM parent to render to. The entire contents are either
 *     replaced, or efficiently updated if the same result type was previous
 *     rendered there.
 * @param templateFactory a function to create a Template or retreive one from
 *     cache.
 */function render(e,t,n=defaultTemplateFactory){const r=n(e);let a=t.__templateInstance;// Repeat render, just call update()
if(void 0!==a&&a.template===r&&a._partCallback===e.partCallback)return void a.update(e.values);// First render, create a new TemplateInstance and append it
a=new TemplateInstance(r,e.partCallback,n),t.__templateInstance=a;const i=a._clone();a.update(e.values),removeNodes(t,t.firstChild),t.appendChild(i)}/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */const marker=`{{lit-${(Math.random()+'').slice(2)}}}`,nodeMarker=`<!--${marker}-->`,markerRegex=new RegExp(`${marker}|${nodeMarker}`),lastAttributeNameRegex=/[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*)$/;/**
 * An expression marker used text-posisitions, not attribute positions,
 * in template.
 *//**
 * This regex extracts the attribute name preceding an attribute-position
 * expression. It does this by matching the syntax allowed for attributes
 * against the string literal directly preceding the expression, assuming that
 * the expression is in an attribute-value position.
 *
 * See attributes in the HTML spec:
 * https://www.w3.org/TR/html5/syntax.html#attributes-0
 *
 * "\0-\x1F\x7F-\x9F" are Unicode control characters
 *
 * " \x09\x0a\x0c\x0d" are HTML space characters:
 * https://www.w3.org/TR/html5/infrastructure.html#space-character
 *
 * So an attribute is:
 *  * The name: any character except a control character, space character, ('),
 *    ("), ">", "=", or "/"
 *  * Followed by zero or more space characters
 *  * Followed by "="
 *  * Followed by zero or more space characters
 *  * Followed by:
 *    * Any character except space, ('), ("), "<", ">", "=", (`), or
 *    * (") then any non-("), or
 *    * (') then any non-(')
 *//**
 * Finds the closing index of the last closed HTML tag.
 * This has 3 possible return values:
 *   - `-1`, meaning there is no tag in str.
 *   - `string.length`, meaning the last opened tag is unclosed.
 *   - Some positive number < str.length, meaning the index of the closing '>'.
 */function findTagClose(e){const t=e.lastIndexOf('>'),n=e.indexOf('<',t+1);return-1<n?e.length:t}/**
 * A placeholder for a dynamic expression in an HTML template.
 *
 * There are two built-in part types: AttributePart and NodePart. NodeParts
 * always represent a single dynamic expression, while AttributeParts may
 * represent as many expressions are contained in the attribute.
 *
 * A Template's parts are mutable, so parts can be replaced or modified
 * (possibly to implement different template semantics). The contract is that
 * parts can only be replaced, not removed, added or reordered, and parts must
 * always consume the correct number of values in their `update()` method.
 *
 * TODO(justinfagnani): That requirement is a little fragile. A
 * TemplateInstance could instead be more careful about which values it gives
 * to Part.update().
 */class TemplatePart{constructor(e,t,n,r,a){this.type=e,this.index=t,this.name=n,this.rawName=r,this.strings=a}}/**
 * An updateable Template that tracks the location of dynamic parts.
 */class Template{constructor(e,t){this.parts=[],this.element=t;const n=this.element.content,r=document.createTreeWalker(n,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
               NodeFilter.SHOW_TEXT */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
let a=-1,i=0;const s=[];// The actual previous node, accounting for removals: if a node is removed
// it will never be the previousNode.
// Used to set previousNode at the top of the loop.
for(let n,d;r.nextNode();){a++,n=d;const t=d=r.currentNode;if(1===t.nodeType/* Node.ELEMENT_NODE */){if(!t.hasAttributes())continue;const n=t.attributes;// Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order. In
// particular, Edge/IE can return them out of order, so we cannot assume
// a correspondance between part index and attribute index.
let r=0;for(let e=0;e<n.length;e++)0<=n[e].value.indexOf(marker)&&r++;for(;0<r--;){// Get the template literal section leading up to the first
// expression in this attribute attribute
const r=e.strings[i],s=lastAttributeNameRegex.exec(r)[1],d=n.getNamedItem(s),o=d.value.split(markerRegex);// Find the attribute name
// Find the corresponding attribute
// TODO(justinfagnani): remove non-null assertion
this.parts.push(new TemplatePart('attribute',a,d.name,s,o)),t.removeAttribute(d.name),i+=o.length-1}}else if(3===t.nodeType/* Node.TEXT_NODE */){const e=t.nodeValue;if(0>e.indexOf(marker))continue;const n=t.parentNode,r=e.split(markerRegex),d=r.length-1;// We have a part for each match found
i+=d;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let e=0;e<d;e++)n.insertBefore(''===r[e]?document.createComment(''):document.createTextNode(r[e]),t),this.parts.push(new TemplatePart('node',a++));n.insertBefore(''===r[d]?document.createComment(''):document.createTextNode(r[d]),t),s.push(t)}else if(8===t.nodeType/* Node.COMMENT_NODE */&&t.nodeValue===marker){const e=t.parentNode,r=t.previousSibling;// Add a new marker node to be the startNode of the Part if any of the
// following are true:
//  * We don't have a previousSibling
//  * previousSibling is being removed (thus it's not the
//    `previousNode`)
//  * previousSibling is not a Text node
//
// TODO(justinfagnani): We should be able to use the previousNode here
// as the marker node and reduce the number of extra nodes we add to a
// template. See https://github.com/PolymerLabs/lit-html/issues/147
null===r||r!==n||r.nodeType!==Node.TEXT_NODE?e.insertBefore(document.createComment(''),t):a--,this.parts.push(new TemplatePart('node',a++)),s.push(t),null===t.nextSibling?e.insertBefore(document.createComment(''),t):a--,d=n,i++}}// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const r of s)r.parentNode.removeChild(r)}}/**
 * Returns a value ready to be inserted into a Part from a user-provided value.
 *
 * If the user value is a directive, this invokes the directive with the given
 * part. If the value is null, it's converted to undefined to work better
 * with certain DOM APIs, like textContent.
 */const getValue=(e,t)=>isDirective(t)?(t=t(e),directiveValue):null===t?void 0:t,isDirective=e=>'function'==typeof e&&!0===e.__litDirective,directiveValue={},isPrimitiveValue=e=>null===e||'object'!=typeof e&&'function'!=typeof e;/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */class AttributePart{constructor(e,t,n,r){this.instance=e,this.element=t,this.name=n,this.strings=r,this.size=r.length-1,this._previousValues=[]}_interpolate(e,t){const n=this.strings,r=n.length-1;let a='';for(let s=0;s<r;s++){a+=n[s];const r=getValue(this,e[t+s]);if(r&&r!==directiveValue&&(Array.isArray(r)||'string'!=typeof r&&r[Symbol.iterator]))for(const e of r)// TODO: we need to recursively call getValue into iterables...
a+=e;else a+=r}return a+n[r]}_equalToPreviousValues(e,t){for(let n=t;n<t+this.size;n++)if(this._previousValues[n]!==e[n]||!isPrimitiveValue(e[n]))return!1;return!0}setValue(e,t){if(this._equalToPreviousValues(e,t))return;const n=this.strings;let r;2===n.length&&''===n[0]&&''===n[1]?(r=getValue(this,e[t]),Array.isArray(r)&&(r=r.join(''))):r=this._interpolate(e,t),r!==directiveValue&&this.element.setAttribute(this.name,r),this._previousValues=e}}class NodePart{constructor(e,t,n){this.instance=e,this.startNode=t,this.endNode=n,this._previousValue=void 0}setValue(e){if(e=getValue(this,e),e!==directiveValue)if(isPrimitiveValue(e)){// Handle primitive values
// If the value didn't change, do nothing
if(e===this._previousValue)return;this._setText(e)}else e instanceof TemplateResult?this._setTemplateResult(e):Array.isArray(e)||e[Symbol.iterator]?this._setIterable(e):e instanceof Node?this._setNode(e):void 0===e.then?this._setText(e):this._setPromise(e)}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_setNode(e){this._previousValue===e||(this.clear(),this._insert(e),this._previousValue=e)}_setText(e){const t=this.startNode.nextSibling;e=e===void 0?'':e,t===this.endNode.previousSibling&&t.nodeType===Node.TEXT_NODE?t.textContent=e:this._setNode(document.createTextNode(e)),this._previousValue=e}_setTemplateResult(e){const t=this.instance._getTemplate(e);let n;this._previousValue&&this._previousValue.template===t?n=this._previousValue:(n=new TemplateInstance(t,this.instance._partCallback,this.instance._getTemplate),this._setNode(n._clone()),this._previousValue=n),n.update(e.values)}_setIterable(e){Array.isArray(this._previousValue)||(this.clear(),this._previousValue=[]);// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const t=this._previousValue;let n=0;for(const r of e){// Try to reuse an existing part
let e=t[n];// If no existing part, create a new one
if(e===void 0){// If we're creating the first item part, it's startNode should be the
// container's startNode
let r=this.startNode;// If we're not creating the first part, create a new separator marker
// node, and fix up the previous part's endNode to point to it
if(0<n){const e=t[n-1];r=e.endNode=document.createTextNode(''),this._insert(r)}e=new NodePart(this.instance,r,this.endNode),t.push(e)}e.setValue(r),n++}if(0==n)this.clear(),this._previousValue=void 0;else if(n<t.length){const e=t[n-1];// Truncate the parts array so _previousValue reflects the current state
t.length=n,this.clear(e.endNode.previousSibling),e.endNode=this.endNode}}_setPromise(e){this._previousValue=e,e.then(t=>{this._previousValue===e&&this.setValue(t)})}clear(e=this.startNode){removeNodes(this.startNode.parentNode,e.nextSibling,this.endNode)}}const defaultPartCallback=(e,t,n)=>{if('attribute'===t.type)return new AttributePart(e,n,t.name,t.strings);if('node'===t.type)return new NodePart(e,n,n.nextSibling);throw new Error(`Unknown part type ${t.type}`)};/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */class TemplateInstance{constructor(e,t,n){this._parts=[],this.template=e,this._partCallback=t,this._getTemplate=n}update(e){let t=0;for(const n of this._parts)void 0===n.size?(n.setValue(e[t]),t++):(n.setValue(e,t),t+=n.size)}_clone(){const e=document.importNode(this.template.element.content,!0),t=this.template.parts;if(0<t.length){// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const n=document.createTreeWalker(e,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                   NodeFilter.SHOW_TEXT */,null,!1);let r=-1;for(let e=0;e<t.length;e++){const a=t[e];for(;r<a.index;)r++,n.nextNode();this._parts.push(this._partCallback(this,a,n.currentNode))}}return e}}/**
 * Reparents nodes, starting from `startNode` (inclusive) to `endNode`
 * (exclusive), into another container (could be the same container), before
 * `beforeNode`. If `beforeNode` is null, it appends the nodes to the
 * container.
 */const reparentNodes=(e,t,n=null,r=null)=>{for(let a=t;a!==n;){const t=a.nextSibling;e.insertBefore(a,r),a=t}},removeNodes=(e,t,n=null)=>{for(let r=t;r!==n;){const t=r.nextSibling;e.removeChild(r),r=t}},shadyTemplateFactory=e=>t=>{const n=`${t.type}--${e}`;let r=templateCaches.get(n);r===void 0&&(r=new Map,templateCaches.set(n,r));let a=r.get(t.strings);if(a===void 0){const n=t.getTemplateElement();'object'==typeof window.ShadyCSS&&window.ShadyCSS.prepareTemplate(n,e),a=new Template(t,n),r.set(t.strings,a)}return a};/**
 * Removes nodes, starting from `startNode` (inclusive) to `endNode`
 * (exclusive), from `container`.
 *//**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */function render$1(e,t,n){return render(e,t,shadyTemplateFactory(n))}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 *//**
 * Interprets a template literal as a lit-extended HTML template.
 */const html$1=(e,...t)=>new TemplateResult(e,t,'html',extendedPartCallback),svg$1=(e,...t)=>new SVGTemplateResult(e,t,'svg',extendedPartCallback),extendedPartCallback=(e,t,n)=>{if('attribute'===t.type){if('on-'===t.rawName.substr(0,3)){const r=t.rawName.slice(3);return new EventPart(e,n,r)}const r=t.name.substr(t.name.length-1);if('$'===r){const r=t.name.slice(0,-1);return new AttributePart(e,n,r,t.strings)}if('?'===r){const r=t.name.slice(0,-1);return new BooleanAttributePart(e,n,r,t.strings)}return new PropertyPart(e,n,t.rawName,t.strings)}return defaultPartCallback(e,t,n)};/**
 * Interprets a template literal as a lit-extended SVG template.
 *//**
 * A PartCallback which allows templates to set properties and declarative
 * event handlers.
 *
 * Properties are set by default, instead of attributes. Attribute names in
 * lit-html templates preserve case, so properties are case sensitive. If an
 * expression takes up an entire attribute value, then the property is set to
 * that value. If an expression is interpolated with a string or other
 * expressions then the property is set to the string result of the
 * interpolation.
 *
 * To set an attribute instead of a property, append a `$` suffix to the
 * attribute name.
 *
 * Example:
 *
 *     html`<button class$="primary">Buy Now</button>`
 *
 * To set an event handler, prefix the attribute name with `on-`:
 *
 * Example:
 *
 *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`
 *
 *//**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */class BooleanAttributePart extends AttributePart{setValue(e,t){const n=this.strings;if(2===n.length&&''===n[0]&&''===n[1]){const n=getValue(this,e[t]);if(n===directiveValue)return;n?this.element.setAttribute(this.name,''):this.element.removeAttribute(this.name)}else throw new Error('boolean attributes can only contain a single expression')}}class PropertyPart extends AttributePart{setValue(e,t){const n=this.strings;let r;this._equalToPreviousValues(e,t)||(r=2===n.length&&''===n[0]&&''===n[1]?getValue(this,e[t]):this._interpolate(e,t),r!==directiveValue&&(this.element[this.name]=r),this._previousValues=e)}}class EventPart{constructor(e,t,n){this.instance=e,this.element=t,this.eventName=n}setValue(e){const t=getValue(this,e);t===this._listener||(null==t?this.element.removeEventListener(this.eventName,this):null==this._listener&&this.element.addEventListener(this.eventName,this),this._listener=t)}handleEvent(e){'function'==typeof this._listener?this._listener.call(this.element,e):'function'==typeof this._listener.handleEvent&&this._listener.handleEvent(e)}}class LitElement extends PropertiesMixin(HTMLElement){constructor(){super(...arguments),this.__renderComplete=null,this.__resolveRenderComplete=null,this.__isInvalid=!1,this.__isChanging=!1}/**
     * Override which sets up element rendering by calling* `_createRoot`
     * and `_firstRendered`.
     */ready(){this._root=this._createRoot(),super.ready(),this._firstRendered()}/**
     * Called after the element DOM is rendered for the first time.
     * Implement to perform tasks after first rendering like capturing a
     * reference to a static node which must be directly manipulated.
     * This should not be commonly needed. For tasks which should be performed
     * before first render, use the element constructor.
     */_firstRendered(){}/**
     * Implement to customize where the element's template is rendered by
     * returning an element into which to render. By default this creates
     * a shadowRoot for the element. To render into the element's childNodes,
     * return `this`.
     * @returns {Element|DocumentFragment} Returns a node into which to render.
     */_createRoot(){return this.attachShadow({mode:'open'})}/**
     * Override which returns the value of `_shouldRender` which users
     * should implement to control rendering. If this method returns false,
     * _propertiesChanged will not be called and no rendering will occur even
     * if property values change or `_requestRender` is called.
     * @param _props Current element properties
     * @param _changedProps Changing element properties
     * @param _prevProps Previous element properties
     * @returns {boolean} Default implementation always returns true.
     */_shouldPropertiesChange(e,t,n){const r=this._shouldRender(e,t,n);return!r&&this.__resolveRenderComplete&&this.__resolveRenderComplete(!1),r}/**
     * Implement to control if rendering should occur when property values
     * change or `_requestRender` is called. By default, this method always
     * returns true, but this can be customized as an optimization to avoid
     * rendering work when changes occur which should not be rendered.
     * @param _props Current element properties
     * @param _changedProps Changing element properties
     * @param _prevProps Previous element properties
     * @returns {boolean} Default implementation always returns true.
     */_shouldRender(){return!0}/**
     * Override which performs element rendering by calling
     * `_render`, `_applyRender`, and finally `_didRender`.
     * @param props Current element properties
     * @param changedProps Changing element properties
     * @param prevProps Previous element properties
     */_propertiesChanged(e,t,n){super._propertiesChanged(e,t,n);const r=this._render(e);r&&this._root!==void 0&&this._applyRender(r,this._root),this._didRender(e,t,n),this.__resolveRenderComplete&&this.__resolveRenderComplete(!0)}_flushProperties(){this.__isChanging=!0,this.__isInvalid=!1,super._flushProperties(),this.__isChanging=!1}/**
     * Override which warns when a user attempts to change a property during
     * the rendering lifecycle. This is an anti-pattern and should be avoided.
     * @param property {string}
     * @param value {any}
     * @param old {any}
     */_shouldPropertyChange(e,t,n){const r=super._shouldPropertyChange(e,t,n);return r&&this.__isChanging&&console.trace(`Setting properties in response to other properties changing `+`considered harmful. Setting '${e}' from `+`'${this._getProperty(e)}' to '${t}'.`),r}/**
     * Implement to describe the DOM which should be rendered in the element.
     * Ideally, the implementation is a pure function using only props to describe
     * the element template. The implementation must a `lit-html` TemplateResult.
     * By default this template is rendered into the element's shadowRoot.
     * This can be customized by implementing `_createRoot`. This method must be
     * implemented.
     * @param {*} _props Current element properties
     * @returns {TemplateResult} Must return a lit-html TemplateResult.
     */_render(){throw new Error('_render() not implemented')}/**
     * Renders the given lit-html template `result` into the given `node`.
     * Implement to customize the way rendering is applied. This is should not
     * typically be needed and is provided for advanced use cases.
     * @param result {TemplateResult} `lit-html` template result to render
     * @param node {Element|DocumentFragment} node into which to render
     */_applyRender(e,t){render$1(e,t,this.localName)}/**
     * Called after element DOM has been rendered. Implement to
     * directly control rendered DOM. Typically this is not needed as `lit-html`
     * can be used in the `_render` method to set properties, attributes, and
     * event listeners. However, it is sometimes useful for calling methods on
     * rendered elements, like calling `focus()` on an element to focus it.
     * @param _props Current element properties
     * @param _changedProps Changing element properties
     * @param _prevProps Previous element properties
     */_didRender(){}/**
     * Call to request the element to asynchronously re-render regardless
     * of whether or not any property changes are pending.
     */_requestRender(){this._invalidateProperties()}/**
     * Override which provides tracking of invalidated state.
     */_invalidateProperties(){this.__isInvalid=!0,super._invalidateProperties()}/**
     * Returns a promise which resolves after the element next renders.
     * The promise resolves to `true` if the element rendered and `false` if the
     * element did not render.
     * This is useful when users (e.g. tests) need to react to the rendered state
     * of the element after a change is made.
     * This can also be useful in event handlers if it is desireable to wait
     * to send an event until after rendering. If possible implement the
     * `_didRender` method to directly respond to rendering within the
     * rendering lifecycle.
     */get renderComplete(){return this.__renderComplete||(this.__renderComplete=new Promise(e=>{this.__resolveRenderComplete=t=>{this.__resolveRenderComplete=this.__renderComplete=null,e(t)}}),!this.__isInvalid&&this.__resolveRenderComplete&&Promise.resolve().then(()=>this.__resolveRenderComplete(!1))),this.__renderComplete}}var faSearch={prefix:'fas',iconName:'search',icon:[512,512,[],'f002','M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z']},faSpinner={prefix:'fas',iconName:'spinner',icon:[512,512,[],'f110','M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z']},faTimes={prefix:'fas',iconName:'times',icon:[352,512,[],'f00d','M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z']},faEnvelope={prefix:'fas',iconName:'envelope',icon:[512,512,[],'f0e0','M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z']},faPhone={prefix:'fas',iconName:'phone',icon:[512,512,[],'f095','M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z']},faHome={prefix:'fas',iconName:'home',icon:[576,512,[],'f015','M488 312.7V456c0 13.3-10.7 24-24 24H348c-6.6 0-12-5.4-12-12V356c0-6.6-5.4-12-12-12h-72c-6.6 0-12 5.4-12 12v112c0 6.6-5.4 12-12 12H112c-13.3 0-24-10.7-24-24V312.7c0-3.6 1.6-7 4.4-9.3l188-154.8c4.4-3.6 10.8-3.6 15.3 0l188 154.8c2.7 2.3 4.3 5.7 4.3 9.3zm83.6-60.9L488 182.9V44.4c0-6.6-5.4-12-12-12h-56c-6.6 0-12 5.4-12 12V117l-89.5-73.7c-17.7-14.6-43.3-14.6-61 0L4.4 251.8c-5.1 4.2-5.8 11.8-1.6 16.9l25.5 31c4.2 5.1 11.8 5.8 16.9 1.6l235.2-193.7c4.4-3.6 10.8-3.6 15.3 0l235.2 193.7c5.1 4.2 12.7 3.5 16.9-1.6l25.5-31c4.2-5.2 3.4-12.7-1.7-16.9z']};/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ByuPersonLookupResults extends LitElement{static get properties(){return{results:Array,context:String,searchPending:Boolean}}_render({results:e,context:t,searchPending:n}){// console.log(`byu-person-lookup-results::_render::searchPending=${searchPending}`)
const r=html$1`
      <style>
        :host {
          padding: 1rem;
        }
    * {
      font-family: 'Gotham A', 'Gotham B', Helvetica Nue, Helvetica, sans-serif;
    }
    .modal {
      z-index: 98;
      background-color: rgba(0, 0, 0, 0.6);
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
    }
    .results {
      z-index: 99;
      position: absolute;
      left: 0;
      right: 0;
      top: 20vh;
      bottom: 0;
      padding: 0.5rem;
      background-color: white;
      display: grid;
      grid-template-columns: 1fr;
      grid-template-rows: auto auto 1fr auto;
      grid-gap: 0.5rem;
      overflow: auto;
    }
    .close-modal {
      z-index: 100;
      position: absolute;
      right: 0;
      top: calc(20vh - 2rem);
      border-radius: 50%;
      display: inline-flex;
      justify-content: center;
      align-items: center;
      padding: 0.3rem;
      border: 1px solid #5199E1;
      cursor: pointer;
      box-shadow: 0rem 0rem 1rem #5199E1;
    }
    h2 {
      margin: 0;
    }
    table {
      border-collapse: collapse;
    }
    th, td {
      padding: 0.5rem;
      border-bottom: 1px solid #666666;
    }
    th {
      text-align: left;
      background-color: #0057B8;
      color: white;
      padding: 1rem;
    }
    tbody tr { cursor: pointer; }
    tbody tr:nth-child(odd) {
      background-color: #E6E6E6;
    }
    tbody tr.placeholder { cursor: default; }
    ol, ul {
      margin: 0;
      padding: 0;
      display: inline-flex;
      flex-direction: column;
    }
    li {
      list-style-type: none;
      margin: 0;
    }
    .nav-btn {
      padding: 0.3rem 1rem;
      border: thin solid #666666;
      border-radius: 0.05rem;
      color: white;
      cursor: pointer;
      justify-self: start;
      align-self: center;
    }
    button {
      font-size: 1.1rem;
      background-color: #0057B8;
    }
    button:hover, button:active {
      box-shadow: inset 0 0 0.2rem rgba(255, 255, 255, 0.5);
      background-color: #5199E1;
    }
    .deck {
      display: grid;
      grid-template-columns: 1fr;
      grid-auto-rows: auto;
      grid-gap: 1rem;
    }
    .card {
      border: thin solid #666666;
      border-left: 0.5rem solid #002E5D;
      padding: 0.5rem;
      display: grid;
      grid-template-columns: 1fr;
      grid-auto-rows: auto;
      grid-gap: 0.5rem;
      cursor: pointer;
    }
    .card h3 {
      margin: 0;
    }
    .contact {
      display: flex;
      flex-direction: column;
    }
    .contact div {
      display: inline-grid;
      grid-template-columns: auto 1fr;
      grid-gap: 0.25rem;
    }
    .contact div svg {
      margin-top: calc(1rem - 14px);
    }
    .card.placeholder { cursor: default; }
    svg.placeholder { filter: blur(2px); }
    svg.placeholder line {
      animation: pulse 1500ms ease-in-out infinite alternate;
    }
    @keyframes pulse {
      from { stroke: #999999; }
      to { stroke: #CCCCCC; }
    }
    @media only screen and (min-width: 650px) {
      .deck {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(28rem, 1fr));
        grid-auto-rows: auto;
        grid-gap: 1rem;
      }
      .card {
        border: thin solid #666666;
        border-left: 0.5rem solid #002E5D;
        padding: 0.5rem;
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto;
        grid-gap: 0.5rem;
        cursor: pointer;
      }
      .card h3 {
        margin: 0;
        grid-column: 1/3;
      }
    }
    @media only screen and (min-width: 900px) {
      .results {
        left: 10vw;
        right: 10vw;
        top: 10vh;
        max-height: 85vh;
      }
      .close-modal {
        right: calc(10vw - 2rem);
        top: calc(10vh - 2rem);
      }
    }
  </style>
`,a=()=>html$1`
      <svg class="placeholder" viewBox="0 0 100 3" preserveAspectRatio="none">
        <line x1="5" x2="95" y1="1.5" y2="1.5" stroke="#666666" />
      </svg>
    `,i=e=>html$1`
      <ul>
        ${e.map(e=>html$1`<li>${e}</li>`)}
      </ul>
    `,s=e=>html$1`
      <tr on-click="${()=>this.select(e)}">
        <td>${e.name}</td>
        <td>${e.byuId}</td>
        <td>${e.netId}</td>
        <td>${e.employeeType}</td>
        <td>${e.studentStatus}</td>
      </tr>
    `,d=()=>[1,2,3,4,5].map(()=>html$1`
      <tr class="placeholder"><td colspan="5">${a()}</td></tr>
    `),o=e=>/ACT/.test(e.employeeType)?html$1`
          <div>
            <div>${e.jobTitle}</div>
            <div>${e.department}</div>
            <div>${e.addresses.work?i(e.addresses.work):''}</div>
          </div>
        `:html$1`<div></div>`,[,,,,l]=faEnvelope.icon,[,,,,p]=faPhone.icon,[,,,,_]=faHome.icon,c=e=>html$1`
      <svg width="14" height="14" viewBox="0 0 512 512">
        ${svg$1`<path d$="${e}" fill="#666666"/>`}
      </svg>
    `,u=e=>html$1`
      <div class="card" on-click="${()=>this.select(e)}">
        <h3>${e.name}</h3>
        ${o(e)}
        <div class="contact">
          <div>${c(l)}${e.email}</div>
          <div>${c(p)}${e.phone}</div>
          <div>${c(_)}${e.addresses.mailing?i(e.addresses.mailing):''}</div>
        </div>
      </div>
    `,m=()=>[1,2,3,4,5].map(()=>html$1`
      <div class="card placeholder">
        <h3>${a()}</h3>
        <div>
          <div>${a()}</div>
          <div>${a()}</div>
        </div>
        <div>
          <div>${a()}</div>
          <div>${a()}</div>
          <div>${a()}</div>
        </div>
      </div>
    `);if(!e||!e.map||1>e.length)return html$1``;const[,,,,g]=faTimes.icon,h=svg$1`
    <path d$=${g} fill="white" transform="translate(90)"/>
    `;return html$1`
      ${r}
      <div class="modal">
        <h1 style="color: white;">${n?'SEARCH PENDING':''}</h1>
        <div class="results">
          <h2 id="top">Lookup Results</h2>
          ${t&&'admin'===t?(e=>html$1`
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>BYU ID</th>
            <th>Net ID</th>
            <th>EMP Type</th>
            <th>STD Status</th>
          </tr>
        </thead>
        <tbody>
          ${e.map(e=>s(e))}
          ${n?d():''}
        </tbody>
      </table>
    `)(e):(e=>html$1`
      <div class="deck">
        ${e.map(e=>u(e))}
        ${n?m():''}
      </div>
    `)(e)}
          <div class="spacer"></div>
          ${IntersectionObserver?html$1`<button id="bottom" class="nav-btn" on-click="${()=>this.close()}">Close</button>`:html$1`
                <div>
                  <button class="nav-btn" on-click="${()=>this.prev()}">Prev</button>
                  <button class="nav-btn" on-click="${()=>this.next()}">Next</button>
                </div>
              `}
        </div>
        <button class="close-modal" on-click="${()=>this.close()}">
          <svg alt="Search" width="24" height="24" viewBox="0 0 512 512">
            ${h}
          </svg>
        </button>
      </div>
    `}dispatch(e,t){const n=t?{detail:t,bubbles:!0,composed:!0}:{bubbles:!0,composed:!0},r=new CustomEvent(e,n);this.dispatchEvent(r)}select(e){const{personId:t,byuId:n,netId:r,name:a}=e;this.dispatch('byu-lookup-results-select',{personId:t,byuId:n,netId:r,name:a}),this.close()}close(){this.dispatch('byu-lookup-results-close')}next(){this.searchPending||this.dispatch('byu-lookup-next-page')}prev(){this.searchPending||this.dispatch('byu-lookup-prev-page')}_didRender(){const e=this._root.getElementById('top'),t=this._root.getElementById('bottom');if(IntersectionObserver&&e&&t){const n=new IntersectionObserver(n=>{n.forEach(n=>{n.isIntersecting&&(n.target===t?this.next():n.target===e&&this.prev())})},{});// observer.observe(top)
n.observe(t)}}}console.log('registering person lookup results'),window.customElements.define('byu-person-lookup-results',ByuPersonLookupResults);/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class ByuPersonLookup extends LitElement{static get properties(){return{search:String,results:Object,searchPending:Boolean,context:String}}_render({search:e,results:t,searchPending:n,context:r}){console.log(`search=${e}, context=${r}`);const[,,,,a]=faSearch.icon,[,,,,i]=faSpinner.icon,s=html$1`
      <style>
        :host {
        }
        * {
         font-family: 'Gotham A', 'Gotham B', Helvetica Nue, Helvetica, sans-serif;
        }
        div {
          position: relative;
          padding: 1rem;
        }
        label {
          position: absolute;
          left: 1rem;
          top: -0.1rem;
          font-size: 0.7rem;
          color: #999;
        }
        input[type="search"] {
          font-size: 1.1rem;
          padding: 0.3rem;
          border: thin solid #666666;
          border-radius: 0.2rem;
          margin-right: 0.2rem;
          min-width: 15rem;
        }
        button {
          font-size: 1.1rem;
          padding: 0.3rem 1rem;
          border: thin solid #666666;
          border-radius: 0.05rem;
          background-color: #0057B8;
          color: white;
          cursor: pointer;
        }
        button:hover, button:active {
          box-shadow: inset 0 0 0.2rem rgba(255, 255, 255, 0.5);
          background-color: #5199E1;
        }
        .spin {
          animation: spin 1500ms linear infinite;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .search-btn-label {
          display: none;
        }
        @media not speech {
          .sr-only { display: none; }
        }
        @media only screen and (min-width: 470px) {
          .search-btn-label {
            display: inline-block;
          }
        }
      </style>
    `;return html$1`
    ${s}
    <div>
      <label for="search">
        <slot>
          No Data Provider
        </slot>
      </label>
      <input
        id="search"
        type="search"
        size="12"
        value$="${e}"
        on-input="${t=>this.searchChange(t)}"
        on-search="${t=>this.doSearch(t)}"
      >
      <button on-click="${t=>this.doSearch(t)}">
        <svg
          class$="${this.searchPending?'spin':''}"
          alt="Search" width="14" height="14" viewBox="0 0 512 512">
          ${svg$1`
            <path
              d$="${this.searchPending?i:a}"
              fill="white"
            />
          `}
        </svg>
        <span class="search-btn-label">
          ${this.searchPending?'Searching':'Search'}
        </span>
      </button>
    </div>
    <slot name="results">
      <byu-person-lookup-results
        results="${t}"
        context="${r}"
        searchPending="${this.searchPending}"
        on-byu-lookup-results-close="${()=>this.closeResults()}"
        on-byu-lookup-next-page="${()=>this.loadNextPage()}"
        on-byu-lookup-prev-page="${()=>this.loadPrevPage()}"
      ></byu-person-lookup-results>
    </slot>
    `}closeResults(){this.results=null}registerProvider(e){this.__lookupProvider=e,this.addEventListener('byu-lookup-datasource-result',this.searchResults),this.addEventListener('byu-lookup-datasource-error',this.searchError),this.addEventListener('byu-lookup-datasource-searching',this.searchBegun),this.fetchFromProvider=this.__lookupProvider.performSearch,this.nextPageFromProvider=this.__lookupProvider.nextPage,this.prevPageFromProvider=this.__lookupProvider.prevPage}connectedCallback(){super.connectedCallback();const e=this.firstElementChild;if(e&&e.performSearch)this.registerProvider(e);else{const t=setTimeout(()=>{throw new Error('No valid lookup provider found!')},1e4);this.addEventListener('byu-lookup-datasource-register',n=>{n.stopPropagation(),this.registerProvider(n.target),clearTimeout(t)})}}searchResults(t){t.stopPropagation(),this.results=this.results.concat(t.detail),this.searchPending=!1}searchError(t){t.stopPropagation(),this.searchPending=!1,alert(t.detail),console.error('search error:\n',t.detail)}searchBegun(t){t.stopPropagation(),this.searchPending=!0}searchChange(t){// console.log(`search=${this.search}`)
if(this.search=t.target.value,this.__lookupProvider){const e=this.search;this.__lookupProvider.search=e}}doSearch(){this.results=[],this.fetchFromProvider(this.search)}loadNextPage(){this.nextPageFromProvider()}loadPrevPage(){this.prevPageFromProvider()}}console.log('registering person lookup'),window.customElements.define('byu-person-lookup',ByuPersonLookup);export default ByuPersonLookup;
