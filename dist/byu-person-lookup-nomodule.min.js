(function(){'use strict';/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */function e(e){let t=z.get(e.type);void 0===t&&(t={stringsArray:new WeakMap,keyString:new Map},z.set(e.type,t));let n=t.stringsArray.get(e.strings);if(void 0!==n)return n;// If the TemplateStringsArray is new, generate a key from the strings
// This key is shared between all templates with identical content
const r=e.strings.join(p);// Check if we already have a Template for this key
return n=t.keyString.get(r),void 0===n&&(n=new h(e,e.getTemplateElement()),t.keyString.set(r,n)),t.stringsArray.set(e.strings,n),n}/**
     * Removes the list of nodes from a Template safely. In addition to removing
     * nodes from the Template, the Template part indices are updated to match
     * the mutated Template DOM.
     *
     * As the template is walked the removal state is tracked and
     * part indices are adjusted as needed.
     *
     * div
     *   div#1 (remove) <-- start removing (removing node is div#1)
     *     div
     *       div#2 (remove)  <-- continue removing (removing node is still div#1)
     *         div
     * div <-- stop removing since previous sibling is the removing node (div#1,
     * removed 4 nodes)
     */function t(e,t){const{element:{content:r},parts:n}=e,s=document.createTreeWalker(r,q,null,!1);let o=U(n),a=n[o],d=-1,i=0;const l=[];for(let r=null;s.nextNode();){d++;const e=s.currentNode;// End removal if stepped past the removing node
for(e.previousSibling===r&&(r=null),t.has(e)&&(l.push(e),null===r&&(r=e)),null!==r&&i++;a!==void 0&&a.index===d;)// If part is in a removed node deactivate it by setting index to -1 or
// adjust the index as needed.
// go to the next active part.
a.index=null===r?a.index-i:-1,o=U(n,o),a=n[o]}l.forEach(e=>e.parentNode.removeChild(e))}/**
     * Inserts the given node into the Template, optionally before the given
     * refNode. In addition to inserting the node into the Template, the Template
     * part indices are updated to match the mutated Template DOM.
     */function n(e,t,n=null){const{element:{content:s},parts:r}=e;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===n||void 0===n)return void s.appendChild(t);const o=document.createTreeWalker(s,q,null,!1);let a=U(r),d=0,i=-1;for(;o.nextNode();){i++;const e=o.currentNode;for(e===n&&(d=O(t),n.parentNode.insertBefore(t,n));-1!==a&&r[a].index===i;){// If we've inserted the node, simply adjust all subsequent parts
if(0<d){for(;-1!==a;)r[a].index+=d,a=U(r,a);return}a=U(r,a)}}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ // Get a key to lookup in `templateCaches`.
const r=new WeakMap,s=e=>"function"==typeof e&&r.has(e),o=window.customElements!==void 0&&window.customElements.polyfillWrapFlushCallback!==void 0,a=(e,t,n=null,r=null)=>{for(let s=t;s!==n;){const t=s.nextSibling;e.insertBefore(s,r),s=t}},d=(e,t,n=null)=>{for(let r=t;r!==n;){const t=r.nextSibling;e.removeChild(r),r=t}},i={},l={},p=`{{lit-${(Math.random()+"").slice(2)}}}`,u=`<!--${p}-->`,c=new RegExp(`${p}|${u}`),g="$lit$";/**
     * An updateable Template that tracks the location of dynamic parts.
     */class h{constructor(e,t){this.parts=[],this.element=t;let n=-1,r=0;const s=[],o=t=>{const a=t.content,d=document.createTreeWalker(a,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
for(// Keeps track of the last index associated with a part. We try to delete
// unnecessary nodes, but we never want to associate two different parts
// to the same index. They must have a constant node between.
let a=0;d.nextNode();){n++;const t=d.currentNode;if(1===t.nodeType/* Node.ELEMENT_NODE */){if(t.hasAttributes()){const s=t.attributes;// Per
// https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order.
// In particular, Edge/IE can return them out of order, so we cannot
// assume a correspondance between part index and attribute index.
let o=0;for(let e=0;e<s.length;e++)0<=s[e].value.indexOf(p)&&o++;for(;0<o--;){// Get the template literal section leading up to the first
// expression in this attribute
const s=e.strings[r],o=y.exec(s)[2],a=o.toLowerCase()+g,d=t.getAttribute(a),i=d.split(c);// Find the attribute name
this.parts.push({type:"attribute",index:n,name:o,strings:i}),t.removeAttribute(a),r+=i.length-1}}"TEMPLATE"===t.tagName&&o(t)}else if(3===t.nodeType/* Node.TEXT_NODE */){const e=t.data;if(0<=e.indexOf(p)){const o=t.parentNode,a=e.split(c),d=a.length-1;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let e=0;e<d;e++)o.insertBefore(""===a[e]?m():document.createTextNode(a[e]),t),this.parts.push({type:"node",index:++n});// If there's no text, we must insert a comment to mark our place.
// Else, we can trust it will stick around after cloning.
// We have a part for each match found
""===a[d]?(o.insertBefore(m(),t),s.push(t)):t.data=a[d],r+=d}}else if(8===t.nodeType/* Node.COMMENT_NODE */)if(t.data===p){const e=t.parentNode;// Add a new marker node to be the startNode of the Part if any of
// the following are true:
//  * We don't have a previousSibling
//  * The previousSibling is already the start of a previous part
(null===t.previousSibling||n===a)&&(n++,e.insertBefore(m(),t)),a=n,this.parts.push({type:"node",index:n}),null===t.nextSibling?t.data="":(s.push(t),n--),r++}else for(let e=-1;-1!==(e=t.data.indexOf(p,e+1));)// Comment node has a binding marker inside, make an inactive part
// The binding won't work, but subsequent bindings will
// TODO (justinfagnani): consider whether it's even worth it to
// make bindings in comments work
this.parts.push({type:"node",index:-1})}};o(t);// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const r of s)r.parentNode.removeChild(r)}}const f=e=>-1!==e.index,m=()=>document.createComment(""),y=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */class _{constructor(e,t,n){this._parts=[],this.template=e,this.processor=t,this.options=n}update(e){let t=0;for(const n of this._parts)void 0!==n&&n.setValue(e[t]),t++;for(const t of this._parts)void 0!==t&&t.commit()}_clone(){// When using the Custom Elements polyfill, clone the node, rather than
// importing it, to keep the fragment in the template's document. This
// leaves the fragment inert so custom elements won't upgrade and
// potentially modify their contents by creating a polyfilled ShadowRoot
// while we traverse the tree.
const e=o?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=this.template.parts;let n=0,r=0;const s=e=>{// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const o=document.createTreeWalker(e,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Loop through all the nodes and parts of a template
for(let a=o.nextNode();n<t.length&&null!==a;){const e=t[n];// Consecutive Parts may have the same node index, in the case of
// multiple bound attributes on an element. So each iteration we either
// increment the nodeIndex, if we aren't on a node with a part, or the
// partIndex if we are. By not incrementing the nodeIndex when we find a
// part, we allow for the next part to be associated with the current
// node if neccessasry.
if(!f(e))this._parts.push(void 0),n++;else if(r===e.index){if("node"===e.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(a.previousSibling),this._parts.push(e)}else this._parts.push(...this.processor.handleAttributeExpressions(a,e.name,e.strings,this.options));n++}else r++,"TEMPLATE"===a.nodeName&&s(a.content),a=o.nextNode()}};return s(e),o&&(document.adoptNode(e),customElements.upgrade(e)),e}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */class v{constructor(e,t,n,r){this.strings=e,this.values=t,this.type=n,this.processor=r}/**
         * Returns a string of HTML used to create a `<template>` element.
         */getHTML(){const e=this.strings.length-1;let t="";for(let n=0;n<e;n++){const e=this.strings[n],r=y.exec(e);// This exec() call does two things:
// 1) Appends a suffix to the bound attribute name to opt out of special
// attribute value parsing that IE11 and Edge do, like for style and
// many SVG attributes. The Template class also appends the same suffix
// when looking up attributes to create Parts.
// 2) Adds an unquoted-attribute-safe marker for the first expression in
// an attribute. Subsequent attribute expressions will use node markers,
// and this is safe since attributes with multiple expressions are
// guaranteed to be quoted.
t+=r?e.substr(0,r.index)+r[1]+r[2]+g+r[3]+p:e+u}return t+this.strings[e]}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}/**
     * A TemplateResult for SVG fragments.
     *
     * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the
     * SVG namespace, then modifies the template to remove the `<svg>` tag so that
     * clones only container the original fragment.
     */class S extends v{getHTML(){return`<svg>${super.getHTML()}</svg>`}getTemplateElement(){const e=super.getTemplateElement(),t=e.content,n=t.firstChild;return t.removeChild(n),a(t,n.firstChild),e}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */const P=e=>null===e||"object"!=typeof e&&"function"!=typeof e;/**
     * Sets attribute values for AttributeParts, so that the value is only set once
     * even if there are multiple parts for an attribute.
     */class x{constructor(e,t,n){this.dirty=!0,this.element=e,this.name=t,this.strings=n,this.parts=[];for(let r=0;r<n.length-1;r++)this.parts[r]=this._createPart()}/**
         * Creates a single part. Override this to create a differnt type of part.
         */_createPart(){return new b(this)}_getValue(){const e=this.strings,t=e.length-1;let n="";for(let r=0;r<t;r++){n+=e[r];const t=this.parts[r];if(void 0!==t){const e=t.value;if(null!=e&&(Array.isArray(e)||// tslint:disable-next-line:no-any
"string"!=typeof e&&e[Symbol.iterator]))for(const r of e)n+="string"==typeof r?r:r+"";else n+="string"==typeof e?e:e+""}}return n+=e[t],n}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class b{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===i||P(e)&&e===this.value||(this.value=e,!s(e)&&(this.committer.dirty=!0))}commit(){for(;s(this.value);){const e=this.value;this.value=i,e(this)}this.value===i||this.committer.commit()}}class N{constructor(e){this.value=void 0,this._pendingValue=void 0,this.options=e}/**
         * Inserts this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */appendInto(e){this.startNode=e.appendChild(m()),this.endNode=e.appendChild(m())}/**
         * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
         * its next sibling must be static, unchanging nodes such as those that appear
         * in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}/**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */appendIntoPart(e){e._insert(this.startNode=m()),e._insert(this.endNode=m())}/**
         * Appends this part after `ref`
         *
         * This part must be empty, as its contents are not automatically moved.
         */insertAfterPart(e){e._insert(this.startNode=m()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this._pendingValue=e}commit(){for(;s(this._pendingValue);){const e=this._pendingValue;this._pendingValue=i,e(this)}const e=this._pendingValue;e===i||(P(e)?e!==this.value&&this._commitText(e):e instanceof v?this._commitTemplateResult(e):e instanceof Node?this._commitNode(e):Array.isArray(e)||// tslint:disable-next-line:no-any
e[Symbol.iterator]?this._commitIterable(e):e===l?(this.value=l,this.clear()):this._commitText(e))}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_commitNode(e){this.value===e||(this.clear(),this._insert(e),this.value=e)}_commitText(e){const t=this.startNode.nextSibling;e=null==e?"":e,t===this.endNode.previousSibling&&3===t.nodeType/* Node.TEXT_NODE */?t.data=e:this._commitNode(document.createTextNode("string"==typeof e?e:e+"")),this.value=e}_commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value instanceof _&&this.value.template===t)this.value.update(e.values);else{// Make sure we propagate the template processor from the TemplateResult
// so that we use its syntax extension, etc. The template factory comes
// from the render function options so that it can control template
// caching and preprocessing.
const n=new _(t,e.processor,this.options),r=n._clone();n.update(e.values),this._commitNode(r),this.value=n}}_commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const t=this.value;let n,r=0;for(const s of e)// Try to reuse an existing part
n=t[r],void 0===n&&(n=new N(this.options),t.push(n),0==r?n.appendIntoPart(this):n.insertAfterPart(t[r-1])),n.setValue(s),n.commit(),r++;r<t.length&&(t.length=r,this.clear(n&&n.endNode))}clear(e=this.startNode){d(this.startNode.parentNode,e.nextSibling,this.endNode)}}/**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */class C{constructor(e,t,n){if(this.value=void 0,this._pendingValue=void 0,2!==n.length||""!==n[0]||""!==n[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=n}setValue(e){this._pendingValue=e}commit(){for(;s(this._pendingValue);){const e=this._pendingValue;this._pendingValue=i,e(this)}if(this._pendingValue!==i){const e=!!this._pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=e,this._pendingValue=i}}}/**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */class T extends x{constructor(e,t,n){super(e,t,n),this.single=2===n.length&&""===n[0]&&""===n[1]}_createPart(){return new E(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class E extends b{}// Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.
let k=!1;try{const e={get capture(){return k=!0,!1}};// tslint:disable-next-line:no-any
// tslint:disable-next-line:no-any
window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}class A{constructor(e,t,n){this.value=void 0,this._pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=n,this._boundHandleEvent=t=>this.handleEvent(t)}setValue(e){this._pendingValue=e}commit(){for(;s(this._pendingValue);){const e=this._pendingValue;this._pendingValue=i,e(this)}if(this._pendingValue===i)return;const e=this._pendingValue,t=this.value,n=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive);n&&this.element.removeEventListener(this.eventName,this._boundHandleEvent,this._options),null!=e&&(null==t||n)&&(this._options=V(e),this.element.addEventListener(this.eventName,this._boundHandleEvent,this._options)),this.value=e,this._pendingValue=i}handleEvent(e){"function"==typeof this.value?this.value.call(this.eventContext||this.element,e):this.value.handleEvent(e)}}// We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.
const V=e=>e&&(k?{capture:e.capture,passive:e.passive,once:e.once}:e.capture);/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * Creates Parts when a template is instantiated.
     */const R=new class{/**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */handleAttributeExpressions(e,t,n,r){const s=t[0];if("."===s){const r=new T(e,t.slice(1),n);return r.parts}if("@"===s)return[new A(e,t.slice(1),r.eventContext)];if("?"===s)return[new C(e,t.slice(1),n)];const o=new x(e,t,n);return o.parts}/**
         * Create parts for a text-position binding.
         * @param templateFactory
         */handleTextExpression(e){return new N(e)}},z=new Map,I=new WeakMap,M=(t,n,r)=>{let s=I.get(n);s===void 0&&(d(n,n.firstChild),I.set(n,s=new N(Object.assign({templateFactory:e},r))),s.appendInto(n)),s.setValue(t),s.commit()};(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.0.0");/**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */const w=(e,...t)=>new v(e,t,"html",R),L=(e,...t)=>new S(e,t,"svg",R),q=133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,O=e=>{let t=11===e.nodeType/* Node.DOCUMENT_FRAGMENT_NODE */?0:1;for(const n=document.createTreeWalker(e,q,null,!1);n.nextNode();)t++;return t},U=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(f(t))return n}return-1},H=(e,t)=>`${e}--${t}`;/**
     * Interprets a template literal as an SVG template that can efficiently
     * render to and update a container.
     */let B=!0;"undefined"==typeof window.ShadyCSS?B=!1:"undefined"==typeof window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."),B=!1);/**
     * Template factory which scopes template DOM using ShadyCSS.
     * @param scopeName {string}
     */const F=e=>t=>{const n=H(t.type,e);let r=z.get(n);void 0===r&&(r={stringsArray:new WeakMap,keyString:new Map},z.set(n,r));let s=r.stringsArray.get(t.strings);if(void 0!==s)return s;const o=t.strings.join(p);if(s=r.keyString.get(o),void 0===s){const n=t.getTemplateElement();B&&window.ShadyCSS.prepareTemplateDom(n,e),s=new h(t,n),r.keyString.set(o,s)}return r.stringsArray.set(t.strings,s),s},W=["html","svg"],j=e=>{W.forEach(n=>{const r=z.get(H(n,e));r!==void 0&&r.keyString.forEach(e=>{const{element:{content:n}}=e,r=new Set;// IE 11 doesn't support the iterable param Set constructor
Array.from(n.querySelectorAll("style")).forEach(e=>{r.add(e)}),t(e,r)})})},D=new Set,$=(e,r,s)=>{D.add(s);// Move styles out of rendered DOM and store.
const o=e.querySelectorAll("style");// If there are no styles, skip unnecessary work
if(0===o.length)return void window.ShadyCSS.prepareTemplateStyles(r.element,s);const a=document.createElement("style");// Collect styles into a single style. This helps us make sure ShadyCSS
// manipulations will not prevent us from being able to fix up template
// part indices.
// NOTE: collecting styles is inefficient for browsers but ShadyCSS
// currently does this anyway. When it does not, this should be changed.
for(let t=0;t<o.length;t++){const e=o[t];e.parentNode.removeChild(e),a.textContent+=e.textContent}// Remove styles from nested templates in this scope.
if(j(s),n(r,a,r.element.content.firstChild),window.ShadyCSS.prepareTemplateStyles(r.element,s),window.ShadyCSS.nativeShadow){// When in native Shadow DOM, re-add styling to rendered content using
// the style ShadyCSS produced.
const t=r.element.content.querySelector("style");e.insertBefore(t.cloneNode(!0),e.firstChild)}else{r.element.content.insertBefore(a,r.element.content.firstChild);const e=new Set;e.add(a),t(r,e)}},G=(e,t,n)=>{const r=n.scopeName,s=I.has(t),o=t instanceof ShadowRoot&&B&&e instanceof v,a=o&&!D.has(r),i=a?document.createDocumentFragment():t;// When performing first scope render,
// (1) We've rendered into a fragment so that there's a chance to
// `prepareTemplateStyles` before sub-elements hit the DOM
// (which might cause them to render based on a common pattern of
// rendering in a custom element's `connectedCallback`);
// (2) Scope the template with ShadyCSS one time only for this scope.
// (3) Render the fragment into the container and make sure the
// container knows its `part` is the one we just rendered. This ensures
// DOM will be re-used on subsequent renders.
if(M(e,i,Object.assign({templateFactory:F(r)},n)),a){const e=I.get(i);I.delete(i),e.value instanceof _&&$(i,e.value.template,r),d(t,t.firstChild),t.appendChild(i),I.set(t,e)}// After elements have hit the DOM, update styling if this is the
// initial render to this container.
// This is needed whenever dynamic changes are made so it would be
// safest to do every render; however, this would regress performance
// so we leave it up to the user to call `ShadyCSSS.styleElement`
// for dynamic changes.
!s&&o&&window.ShadyCSS.styleElement(t.host)},J=e=>e,K=(e,t)=>{if(e in t)for(;t!==Object.prototype;){if(t.hasOwnProperty(e))return Object.getOwnPropertyDescriptor(t,e);t=Object.getPrototypeOf(t)}},Q={toAttribute(e,t){return t===Boolean?e?"":null:t===Object||t===Array?null==e?e:JSON.stringify(e):e},fromAttribute(e,t){return t===Boolean?null!==e:t===Number?null===e?null:+e:t===Object||t===Array?JSON.parse(e):e}},X=(e,t)=>t!==e&&(t===t||e===e),Y={attribute:!0,type:String,converter:Q,reflect:!1,hasChanged:X},Z=Promise.resolve(!0),ee=1,te=4,ne=8,re=16,se=32;/**
     * Base element class which manages element properties and attributes. When
     * properties change, the `update` method is asynchronously called. This method
     * should be supplied by subclassers to render updates as desired.
     */class oe extends HTMLElement{constructor(){/**
             * Map with keys for any properties that have changed since the last
             * update cycle with previous values.
             */ /**
             * Map with keys of properties that should be reflected when updated.
             */super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=Z,this._hasConnectedResolver=void 0,this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}/**
         * Returns a list of attributes corresponding to the registered properties.
         * @nocollapse
         */static get observedAttributes(){this._finalize();const e=[];for(const[t,n]of this._classProperties){const r=this._attributeNameForProperty(t,n);r!==void 0&&(this._attributeToPropertyMap.set(r,t),e.push(r))}return e}/**
         * Ensures the private `_classProperties` property metadata is created.
         * In addition to `_finalize` this is also called in `createProperty` to
         * ensure the `@property` decorator can add property metadata.
         */ /** @nocollapse */static _ensureClassProperties(){// ensure private storage for property declarations.
if(!this.hasOwnProperty(J("_classProperties",this))){this._classProperties=new Map;// NOTE: Workaround IE11 not supporting Map constructor argument.
const e=Object.getPrototypeOf(this)._classProperties;e!==void 0&&e.forEach((e,t)=>this._classProperties.set(t,e))}}/**
         * Creates a property accessor on the element prototype if one does not exist.
         * The property setter calls the property's `hasChanged` property option
         * or uses a strict identity check to determine whether or not to request
         * an update.
         * @nocollapse
         */static createProperty(e,t=Y){if(this._ensureClassProperties(),this._classProperties.set(e,t),!t.noAccessor){const t=K(e,this.prototype);let n;// If there is a super accessor, capture it and "super" to it
if(void 0!==t&&t.set&&t.get){const{set:r,get:s}=t;n={get(){return s.call(this)},set(t){const n=this[e];r.call(this,t),this.requestUpdate(e,n)},configurable:!0,enumerable:!0}}else{const t="symbol"==typeof e?Symbol():`__${e}`;n={get(){return this[t]},set(n){const r=this[e];this[t]=n,this.requestUpdate(e,r)},configurable:!0,enumerable:!0}}Object.defineProperty(this.prototype,e,n)}}/**
         * Creates property accessors for registered properties and ensures
         * any superclasses are also finalized.
         * @nocollapse
         */static _finalize(){if(!(this.hasOwnProperty(J("finalized",this))&&this.finalized)){// finalize any superclasses
const e=Object.getPrototypeOf(this);// make any properties
// Note, only process "own" properties since this element will inherit
// any properties defined on the superClass, and finalization ensures
// the entire prototype chain is finalized.
if("function"==typeof e._finalize&&e._finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(J("properties",this))){const e=this.properties,t=[...Object.getOwnPropertyNames(e),...("function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[])];// support symbols in properties (IE11 does not support this)
for(const n of t)// note, use of `any` is due to TypeSript lack of support for symbol in
// index types
this.createProperty(n,e[n])}}}/**
         * Returns the property name for the given attribute `name`.
         * @nocollapse
         */static _attributeNameForProperty(e,t){const n=t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}/**
         * Returns true if a property should request an update.
         * Called when a property value is set and uses the `hasChanged`
         * option for the property if present or a strict identity check.
         * @nocollapse
         */static _valueHasChanged(e,t,n=X){return n(e,t)}/**
         * Returns the property value for the given attribute value.
         * Called via the `attributeChangedCallback` and uses the property's
         * `converter` or `converter.fromAttribute` property option.
         * @nocollapse
         */static _propertyValueFromAttribute(e,t){const n=t.type,r=t.converter||Q,s="function"==typeof r?r:r.fromAttribute;return s?s(e,n):e}/**
         * Returns the attribute value for the given property value. If this
         * returns undefined, the property will *not* be reflected to an attribute.
         * If this returns null, the attribute will be removed, otherwise the
         * attribute will be set to the value.
         * This uses the property's `reflect` and `type.toAttribute` property options.
         * @nocollapse
         */static _propertyValueToAttribute(e,t){if(void 0===t.reflect)return;const n=t.type,r=t.converter,s=r&&r.toAttribute||Q.toAttribute;return s(e,n)}/**
         * Performs element initialization. By default captures any pre-set values for
         * registered properties.
         */initialize(){this._saveInstanceProperties()}/**
         * Fixes any properties set on the instance before upgrade time.
         * Otherwise these would shadow the accessor and break these properties.
         * The properties are stored in a Map which is played back after the
         * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
         * (<=41), properties created for native platform properties like (`id` or
         * `name`) may not have default values set in the element constructor. On
         * these browsers native properties appear on instances and therefore their
         * default value will overwrite any element default (e.g. if the element sets
         * this.id = 'id' in the constructor, the 'id' will become '' since this is
         * the native platform default).
         */_saveInstanceProperties(){for(const[e]of this.constructor._classProperties)if(this.hasOwnProperty(e)){const t=this[e];delete this[e],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(e,t)}}/**
         * Applies previously saved instance properties.
         */_applyInstanceProperties(){for(const[e,t]of this._instanceProperties)this[e]=t;this._instanceProperties=void 0}connectedCallback(){this._updateState|=se,this._hasConnectedResolver?(this._hasConnectedResolver(),this._hasConnectedResolver=void 0):this.requestUpdate()}/**
         * Allows for `super.disconnectedCallback()` in extensions while
         * reserving the possibility of making non-breaking feature additions
         * when disconnecting at some point in the future.
         */disconnectedCallback(){}/**
         * Synchronizes property values when attributes change.
         */attributeChangedCallback(e,t,n){t!==n&&this._attributeToProperty(e,n)}_propertyToAttribute(e,t,n=Y){const r=this.constructor,s=r._attributeNameForProperty(e,n);if(s!==void 0){const e=r._propertyValueToAttribute(t,n);// an undefined value does not change the attribute.
if(e===void 0)return;// Track if the property is being reflected to avoid
// setting the property again via `attributeChangedCallback`. Note:
// 1. this takes advantage of the fact that the callback is synchronous.
// 2. will behave incorrectly if multiple attributes are in the reaction
// stack at time of calling. However, since we process attributes
// in `update` this should not be possible (or an extreme corner case
// that we'd like to discover).
// mark state reflecting
// mark state not reflecting
this._updateState|=ne,null==e?this.removeAttribute(s):this.setAttribute(s,e),this._updateState&=~ne}}_attributeToProperty(e,t){// Use tracking info to avoid deserializing attribute value if it was
// just set from a property setter.
if(this._updateState&ne)return;const n=this.constructor,r=n._attributeToPropertyMap.get(e);if(r!==void 0){const e=n._classProperties.get(r)||Y;// mark state reflecting
// mark state not reflecting
this._updateState|=re,this[r]=n._propertyValueFromAttribute(t,e),this._updateState&=~re}}/**
         * Requests an update which is processed asynchronously. This should
         * be called when an element should update based on some state not triggered
         * by setting a property. In this case, pass no arguments. It should also be
         * called when manually implementing a property setter. In this case, pass the
         * property `name` and `oldValue` to ensure that any configured property
         * options are honored. Returns the `updateComplete` Promise which is resolved
         * when the update completes.
         *
         * @param name {PropertyKey} (optional) name of requesting property
         * @param oldValue {any} (optional) old value of requesting property
         * @returns {Promise} A Promise that is resolved when the update completes.
         */requestUpdate(e,t){let n=!0;// if we have a property key, perform property update steps.
if(void 0!==e&&!this._changedProperties.has(e)){const r=this.constructor,s=r._classProperties.get(e)||Y;r._valueHasChanged(this[e],t,s.hasChanged)?(this._changedProperties.set(e,t),!0===s.reflect&&!(this._updateState&re)&&(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,s))):n=!1}return!this._hasRequestedUpdate&&n&&this._enqueueUpdate(),this.updateComplete}/**
         * Sets up the element to asynchronously update.
         */async _enqueueUpdate(){this._updateState|=te;let e;const t=this._updatePromise;this._updatePromise=new Promise(t=>e=t),await t,this._hasConnected||(await new Promise(e=>this._hasConnectedResolver=e));// Allow `performUpdate` to be asynchronous to enable scheduling of updates.
const n=this.performUpdate();// Note, this is to avoid delaying an additional microtask unless we need
// to.
null!=n&&"function"==typeof n.then&&(await n),e(!this._hasRequestedUpdate)}get _hasConnected(){return this._updateState&se}get _hasRequestedUpdate(){return this._updateState&te}get hasUpdated(){return this._updateState&ee}/**
         * Performs an element update.
         *
         * You can override this method to change the timing of updates. For instance,
         * to schedule updates to occur just before the next frame:
         *
         * ```
         * protected async performUpdate(): Promise<unknown> {
         *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
         *   super.performUpdate();
         * }
         * ```
         */performUpdate(){if(this._instanceProperties&&this._applyInstanceProperties(),this.shouldUpdate(this._changedProperties)){const e=this._changedProperties;this.update(e),this._markUpdated(),this._updateState&ee||(this._updateState|=ee,this.firstUpdated(e)),this.updated(e)}else this._markUpdated()}_markUpdated(){this._changedProperties=new Map,this._updateState&=~te}/**
         * Returns a Promise that resolves when the element has completed updating.
         * The Promise value is a boolean that is `true` if the element completed the
         * update without triggering another update. The Promise result is `false` if
         * a property was set inside `updated()`. This getter can be implemented to
         * await additional state. For example, it is sometimes useful to await a
         * rendered element before fulfilling this Promise. To do this, first await
         * `super.updateComplete` then any subsequent state.
         *
         * @returns {Promise} The Promise returns a boolean that indicates if the
         * update resolved without triggering another update.
         */get updateComplete(){return this._updatePromise}/**
         * Controls whether or not `update` should be called when the element requests
         * an update. By default, this method always returns `true`, but this can be
         * customized to control when to update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */shouldUpdate(e){return!0}/**
         * Updates the element. This method reflects property values to attributes.
         * It can be overridden to render and keep updated element DOM.
         * Setting properties inside this method will *not* trigger
         * another update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */update(e){if(this._reflectingProperties!==void 0&&0<this._reflectingProperties.size){for(const[e,t]of this._reflectingProperties)this._propertyToAttribute(e,this[e],t);this._reflectingProperties=void 0}}/**
         * Invoked whenever the element is updated. Implement to perform
         * post-updating tasks via DOM APIs, for example, focusing an element.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */updated(e){}/**
         * Invoked when the element is first updated. Implement to perform one time
         * work on the element after update.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */firstUpdated(e){}}/**
     * Marks class as having finished creating properties.
     */oe.finalized=!0;/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
    @license
    Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at
    http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
    http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
    found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
    part of the polymer project is also subject to an additional IP rights grant
    found at http://polymer.github.io/PATENTS.txt
    */const ae="adoptedStyleSheets"in Document.prototype;class de{constructor(e){this.cssText=e}// Note, this is a getter so that it's lazy. In practice, this means
// stylesheets are not created until the first element instance is made.
get styleSheet(){return void 0===this._styleSheet&&(ae?(this._styleSheet=new CSSStyleSheet,this._styleSheet.replaceSync(this.cssText)):this._styleSheet=null),this._styleSheet}}const ie=e=>{if(e instanceof de)return e.cssText;throw new Error(`Value passed to 'css' function must be a 'css' function result: ${e}.`)},le=(e,...t)=>{const n=t.reduce((t,n,r)=>t+ie(n)+e[r+1],e[0]);return new de(n)};/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */class pe extends oe{/**
         * Array of styles to apply to the element. The styles should be defined
         * using the `css` tag function.
         */static get styles(){return[]}static get _uniqueStyles(){if(this._styles===void 0){const e=this.styles,t=e.reduceRight((e,t)=>(e.add(t),e),new Set);// As a performance optimization to avoid duplicated styling that can
// occur especially when composing via subclassing, de-duplicate styles
// preserving the last item in the list. The last item is kept to
// try to preserve cascade order with the assumption that it's most
// important that last added styles override previous styles.
// Array.form does not work on Set in IE
this._styles=[],t.forEach(e=>this._styles.unshift(e))}return this._styles}/**
         * Performs element initialization. By default this calls `createRenderRoot`
         * to create the element `renderRoot` node and captures any pre-set values for
         * registered properties.
         */initialize(){super.initialize(),this.renderRoot=this.createRenderRoot(),window.ShadowRoot&&this.renderRoot instanceof window.ShadowRoot&&this.adoptStyles()}/**
         * Returns the node into which the element should render and by default
         * creates and returns an open shadowRoot. Implement to customize where the
         * element's DOM is rendered. For example, to render into the element's
         * childNodes, return `this`.
         * @returns {Element|DocumentFragment} Returns a node into which to render.
         */createRenderRoot(){return this.attachShadow({mode:"open"})}/**
         * Applies styling to the element shadowRoot using the `static get styles`
         * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
         * available and will fallback otherwise. When Shadow DOM is polyfilled,
         * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
         * is available but `adoptedStyleSheets` is not, styles are appended to the
         * end of the `shadowRoot` to [mimic spec
         * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
         */adoptStyles(){const e=this.constructor._uniqueStyles;0===e.length||(window.ShadyCSS===void 0||window.ShadyCSS.nativeShadow?ae?this.renderRoot.adoptedStyleSheets=e.map(e=>e.styleSheet):this._needsShimAdoptedStyleSheets=!0:window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e=>e.cssText),this.localName));// There are three separate cases here based on Shadow DOM support.
// (1) shadowRoot polyfilled: use ShadyCSS
// (2) shadowRoot.adoptedStyleSheets available: use it.
// (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
// rendering
}connectedCallback(){super.connectedCallback(),this.hasUpdated&&window.ShadyCSS!==void 0&&window.ShadyCSS.styleElement(this)}/**
         * Updates the element. This method reflects property values to attributes
         * and calls `render` to render DOM via lit-html. Setting properties inside
         * this method will *not* trigger another update.
         * * @param _changedProperties Map of changed properties with old values
         */update(e){super.update(e);const t=this.render();t instanceof v&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this}),this._needsShimAdoptedStyleSheets&&(this._needsShimAdoptedStyleSheets=!1,this.constructor._uniqueStyles.forEach(e=>{const t=document.createElement("style");t.textContent=e.cssText,this.renderRoot.appendChild(t)}))}/**
         * Invoked on each update to perform rendering tasks. This method must return
         * a lit-html TemplateResult. Setting properties inside this method will *not*
         * trigger the element to update.
         */render(){}}/**
     * Ensure this class is marked as `finalized` as an optimization ensuring
     * it will not needlessly try to `finalize`.
     */pe.finalized=!0,pe.render=G;var ue={prefix:"fas",iconName:"search",icon:[512,512,[],"f002","M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"]},ce={prefix:"fas",iconName:"spinner",icon:[512,512,[],"f110","M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"]},ge={prefix:"fas",iconName:"ban",icon:[512,512,[],"f05e","M256 8C119.034 8 8 119.033 8 256s111.034 248 248 248 248-111.034 248-248S392.967 8 256 8zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676zM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676z"]},he={prefix:"fas",iconName:"exclamation-triangle",icon:[576,512,[],"f071","M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"]},fe={prefix:"fas",iconName:"question-circle",icon:[512,512,[],"f059","M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z"]},me={prefix:"fas",iconName:"times",icon:[352,512,[],"f00d","M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]},ye={prefix:"fas",iconName:"envelope",icon:[512,512,[],"f0e0","M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"]},_e={prefix:"fas",iconName:"phone",icon:[512,512,[],"f095","M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"]},ve={prefix:"fas",iconName:"home",icon:[576,512,[],"f015","M488 312.7V456c0 13.3-10.7 24-24 24H348c-6.6 0-12-5.4-12-12V356c0-6.6-5.4-12-12-12h-72c-6.6 0-12 5.4-12 12v112c0 6.6-5.4 12-12 12H112c-13.3 0-24-10.7-24-24V312.7c0-3.6 1.6-7 4.4-9.3l188-154.8c4.4-3.6 10.8-3.6 15.3 0l188 154.8c2.7 2.3 4.3 5.7 4.3 9.3zm83.6-60.9L488 182.9V44.4c0-6.6-5.4-12-12-12h-56c-6.6 0-12 5.4-12 12V117l-89.5-73.7c-17.7-14.6-43.3-14.6-61 0L4.4 251.8c-5.1 4.2-5.8 11.8-1.6 16.9l25.5 31c4.2 5.1 11.8 5.8 16.9 1.6l235.2-193.7c4.4-3.6 10.8-3.6 15.3 0l235.2 193.7c5.1 4.2 12.7 3.5 16.9-1.6l25.5-31c4.2-5.2 3.4-12.7-1.7-16.9z"]};/*
     * Copyright 2018 Brigham Young University
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *    http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */const{IntersectionObserver:Se,CustomEvent:Pe}=window;class xe extends pe{static get properties(){return{results:{type:Array},context:{type:String},noAutoselect:{type:Boolean},searchPending:{type:Boolean}}}static get styles(){return[le`
      :host {
        display: block;
      }
      :host[hidden] {
        display: none;
      }
      .modal {
        z-index: 98;
        background-color: rgba(0, 0, 0, 0.6);
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      }
      .results {
        z-index: 99;
        position: fixed;
        left: 0;
        right: 0;
        top: 20vh;
        bottom: 0;
        padding: 0.5rem;
        background-color: white;
        color: #141414;
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto;
        grid-gap: 0.5rem;
        overflow: auto;
      }
      .close-modal {
        z-index: 100;
        position: fixed;
        right: 0;
        top: calc(20vh - 2rem);
        border-radius: 50%;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        padding: 0.3rem;
        border: 1px solid #5199E1;
        cursor: pointer;
        box-shadow: 0rem 0rem 1rem #5199E1;
      }
      h2 {
        margin: 0;
      }
      table {
        border-collapse: collapse;
      }
      th, td {
        padding: 0.5rem;
        border-bottom: 1px solid #666666;
      }
      th {
        text-align: left;
        background-color: #0057B8;
        color: white;
        padding: 1rem;
      }
      tbody tr { cursor: pointer; }
      tbody tr:nth-child(odd) {
        background-color: #E6E6E6;
      }
      tbody tr.placeholder { cursor: default; }
      ol, ul {
        margin: 0;
        padding: 0;
        display: inline-flex;
        flex-direction: column;
      }
      li {
        list-style-type: none;
        margin: 0;
      }
      .nav-btn {
        padding: 0.3rem 1rem;
        border: thin solid #666666;
        border-radius: 0.05rem;
        color: white;
        cursor: pointer;
        justify-self: start;
        align-self: center;
      }
      button {
        font-size: 1.1rem;
        background-color: #0057B8;
      }
      button:hover, button:active {
        box-shadow: inset 0 0 0.2rem rgba(255, 255, 255, 0.5);
        background-color: #5199E1;
      }
      .deck {
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
        grid-gap: 1rem;
      }
      .card {
        border: thin solid #666666;
        border-left: 0.5rem solid #002E5D;
        padding: 0.5rem;
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
        grid-gap: 0.5rem;
        cursor: pointer;
      }
      .card h3 {
        margin: 0;
      }
      .contact {
        display: flex;
        flex-direction: column;
      }
      .contact div {
        display: inline-grid;
        grid-template-columns: auto 1fr;
        grid-gap: 0.25rem;
      }
      .contact div svg {
        margin-top: calc(1rem - 14px);
      }
      .card.placeholder { cursor: default; }
      svg.placeholder { filter: blur(1px); width: 100%; height: 6rem; }
      tr.placeholder svg.placeholder { width: 100%; max-height: 1rem; }
      svg.placeholder rect {
        animation: pulse 1000ms ease-in-out infinite alternate;
      }
      @keyframes pulse {
        from { fill: #999999; }
        70% { fill: #999999; }
        to { fill: #B3B5B7; }
      }
      @media only screen and (min-width: 650px) {
        .deck {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(28rem, 1fr));
          grid-auto-rows: auto;
          grid-gap: 1rem;
        }
        .card {
          border: thin solid #666666;
          border-left: 0.5rem solid #002E5D;
          padding: 0.5rem;
          display: grid;
          grid-template-columns: 1fr 1fr;
          grid-template-rows: auto auto;
          grid-gap: 0.5rem;
          cursor: pointer;
        }
        .card h3 {
          margin: 0;
          grid-column: 1/-1;
        }
      }
      @media only screen and (min-width: 900px) {
        .results {
          left: 10vw;
          right: 10vw;
          top: 10vh;
          max-height: 85vh;
        }
        .close-modal {
          right: calc(10vw - 2rem);
          top: calc(10vh - 2rem);
        }
      }
    `]}constructor(){super(),this.results=null,this.context="directory",this.noAutoselect=!1,this.searchPending=!1,this.isObserving=!1}updated(e){/*
         * changedProperties.forEach((oldValue, propName) => {
         *   console.log(`lookup-results::property changed!
         *     ${propName}: '${oldValue}' => '${this[propName]}'`)
         * })
         */if(this.results&&1===this.results.length&&!this.noAutoselect)// Do Autoselect
return this.select(this.results[0]);if(this.results&&0<this.results.length&&!this.isObserving){// console.log('lookup-results::set up intersection observer')
const e=this.shadowRoot.getElementById("top"),t=this.shadowRoot.getElementById("bottom");if(!Se||!e||!t)return;const n=new Se(n=>{n.forEach(n=>{n.isIntersecting&&(n.target===t?this.next():n.target===e&&this.prev())})},{});// observer.observe(top)
// console.log('lookup-results::observing!', bottom)
n.observe(t),this.isObserving=!0}}render(){// console.log(`byu-person-lookup-results::_render::searchPending=${searchPending}`)
const e=()=>[1,2,3,4,5,6].map(()=>w`
      <tr class="placeholder"><td colspan="5">
        <svg class="placeholder" viewBox="0 0 100 5" preserveAspectRatio="none">
          ${L`<rect x="1" y="1" width="98" height="3" fill="#999999"></rect>`}
        </svg>
      </td></tr>
    `),t=()=>[1,2,3,4,5,6].map(()=>w`
      <div class="card placeholder">
        <svg class="placeholder" viewBox="0 0 50 40" preserveAspectRatio="none">
          <rect x="1" y="1" width="40" height="15" fill="#999999"></rect>
          <rect x="1" y="25" width="45" height="5" fill="#999999"></rect>
          <rect x="1" y="33" width="30" height="5" fill="#999999"></rect>
        </svg>
        <svg class="placeholder" viewBox="0 0 50 40" preserveAspectRatio="none">
          <rect x="1" y="17" width="45" height="5" fill="#999999"></rect>
          <rect x="1" y="25" width="30" height="5" fill="#999999"></rect>
          <rect x="1" y="33" width="35" height="5" fill="#999999"></rect>
        </svg>
      </div>
    `),n=e=>w`
      <ul>
        ${e.map(e=>w`<li>${e}</li>`)}
      </ul>
    `,s=e=>w`
      <tr @click=${()=>this.select(e)}>
        <td>${e.name}</td>
        <td>${e.byuId}</td>
        <td>${e.netId}</td>
        <td>${e.employeeStatus}</td>
        <td>${e.studentStatus}</td>
      </tr>
    `,o=e=>e.showAdditionalInfo&&e.additionalInfo?w`
          <ul>
            ${e.additionalInfo.map(e=>w`<li>${e}</li>`)}
          </ul>
        `:w`<div></div>`,[,,,,a]=ye.icon,[,,,,d]=_e.icon,[,,,,i]=ve.icon,[,,,,l]=me.icon,p=L`
    <path d=${l} fill="white" transform="translate(90)"/>
    `,u=e=>w`
      <svg width="14" height="14" viewBox="0 0 512 512">
        ${L`<path d=${e} fill="#666666"/>`}
      </svg>
    `,c=e=>w`
      <div class="card" @click=${()=>this.select(e)}>
        <h3>${e.name}</h3>
        ${o(e)}
        <div class="contact">
          <div>${u(a)}${e.email}</div>
          <div>${u(d)}${e.phone}</div>
          <div>${u(i)}${e.address?n(e.address):""}</div>
        </div>
      </div>
    `;return this.results&&this.results.map&&!(1>this.results.length)?w`
      <div class="modal">
        <div class="results">
          <h2 id="top">Lookup Results</h2>
          ${this.context&&"admin"===this.context?(t=>w`
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>BYU ID</th>
            <th>Net ID</th>
            <th>EMP Status</th>
            <th>STD Status</th>
          </tr>
        </thead>
        <tbody>
          ${t.map(e=>s(e))}
          ${this.searchPending?e():""}
        </tbody>
      </table>
    `)(this.results):(e=>w`
      <div class="deck">
        ${e.map(e=>c(e))}
        ${this.searchPending?t():""}
      </div>
    `)(this.results)}
          <div class="spacer"></div>
          ${Se?w`<button id="bottom" class="nav-btn" @click=${this.close}>Close</button>`:w`<div>
             <button class="nav-btn" @click=${this.prev}>Prev</button>
             <button class="nav-btn" @click=${this.next}>Next</button>
           </div>`}
        </div>
        <button class="close-modal" @click=${()=>this.close()}>
          <svg alt="Search" width="24" height="24" viewBox="0 0 512 512">
            ${p}
          </svg>
        </button>
      </div>
    `:w``}dispatch(e,t){const n=t?{detail:t,bubbles:!0,composed:!0}:{bubbles:!0,composed:!0},r=new Pe(e,n);this.dispatchEvent(r)}select(e){const{personId:t,byuId:n,netId:r,name:s}=e;this.dispatch("byu-lookup-results-select",{personId:t,byuId:n,netId:r,name:s}),this.close()}close(){this.dispatch("byu-lookup-results-close"),this.isObserving=!1}next(){this.searchPending||this.dispatch("byu-lookup-next-page")}prev(){this.searchPending||this.dispatch("byu-lookup-prev-page")}}/*
     * Copyright 2018 Brigham Young University
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *    http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */class be extends pe{static get properties(){return{context:{type:String,reflect:!0},compact:{type:Boolean},noAutoselect:{type:Boolean,attribute:"no-autoselect"}}}static get styles(){return[le` :host { display: inline-block; } :host([hidden]) { display: none; } `,le` div { position: relative; padding: 1rem; } `,le` .small-padding { padding: 0.25rem; } `,le` label { position: absolute; left: 1rem; top: -0.1rem; font-size: 0.7rem; color: #999; } `,le` input[type="search"] {
        padding: 0.3rem;
        border: thin solid #666666;
        border-radius: 0.2rem;
        margin-right: 0.2rem;
        min-width: 15rem;
        font-size: 1.1rem;
      } `,le` button {
        padding: 0.3rem 1rem;
        border: thin solid #666666;
        border-radius: 0.05rem;
        background-color: #0057B8;
        color: white;
        cursor: pointer;
        font-size: 1.1rem;
      } `,le` button:hover, button:active { box-shadow: inset 0 0 0.2rem rgba(255, 255, 255, 0.5); background-color: #5199E1; } `,le` .spin { animation: spin 1500ms linear infinite; } `,le` .container { position: relative; font-size: 1.1rem; } `,le` .hidden { display: none; } `,le` .error-display {
        background-color: rgba(179, 4, 26, 0.95);
        color: white;
        position: absolute;
        top: 3.7rem;
        box-shadow: 0rem 0.1rem 0.1rem rgba(0, 0, 0, 0.2);
        z-index: 19;
      } `,le` .error-handle { position: absolute; top: -10px; } `,le` @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } .search-btn-label { display: none; } `,le` .compact { display: flex; padding: 0; }`,le` .compact > label { position: static; font-size: 0.9rem; align-self: center; margin: 0rem 0.2rem; } `,le` .compact > input[type="search"] { border-radius: 0; margin-right: 0; min-width: 10rem; font-size: 0.9rem; }`,le` .compact > button { border-radius: 0; font-size: 0.9rem; }`,le` .compact > button .search-btn-label { display: none; } `,le` .compact .error-display { top: 2.5rem; } `,le` @media not speech { .sr-only { display: none; } } `,le` @media only screen and (min-width: 470px) { .search-btn-label { display: inline-block; } } `,le` .center-vertically {
        padding: 0 0.3rem;
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        top: 0.3rem;
      }`,le` .compact > .center-vertically {
        top: 0;
      }`,le` .search-info-icon > .search-info {
        transform-origin: top right;
        transform: scale(0, 0);
        opacity: 0;
        position: absolute;
        top: calc(0.3rem + 23px);
        background-color: rgba(20,20,20,0.9);
        width: 20rem;
        padding; 0.5rem;
        z-index: 19;
        transition: opacity 120ms ease-out, transform 500ms ease 120ms;
      }`,le` .search-info { right: 0rem; }`,le` .search-info.position-to-right { transform-origin: top; left: -8rem; }`,le` .compact > .center-vertically > .search-info { top: 30px; }`,le` .search-info div { padding: 0; color: white; }`,le` .search-info-handle {
        position: absolute;
        top: -10px;
        right: 11px;
      }`,le` .position-to-right > .search-info-handle { left: calc(8rem + 11px); }`,le` .search-info-icon:hover > .search-info { transform: scale(1, 1); opacity: 1; }`,le` .hidden { display: none; }`]}constructor(){super(),this.context="directory",this.compact=!1,this.noAutoselect=!1,this.errorMessage="",this.errorType="",this.results=null,this.search="",this.searchPending=!1,this.hasSearchInfoSlotted=!1}render(){const{context:e,results:t,search:n}=this,[,,,,r]=ue.icon,[,,,,s]=ce.icon,[,,,,o]=ge.icon,[,,,,a]=he.icon,[,,,,d]=fe.icon,i=this.getBoundingClientRect();// console.log(`search=${search}, context=${context}`)
console.log("Bounding Rect:\n",i);const l=i.left<i.width,p=w`
    <div class=${this.hasSearchInfoSlotted?"search-info-icon center-vertically":"hidden search-info-icon center-vertically"}>
      <svg alt="How to use" width="21" height="21" viewBox="0 0 578 512">
        <circle cx="260" cy="260" r="260" fill="white" />
      ${L`
        <path
          d=${d}
          fill="#0057B8"
        />
      `}
      </svg>
      <div class=${l?"search-info position-to-right":"search-info"}>
        <svg class="search-info-handle" width="10" height="10" viewBox="0 0 100 100">
          <path d="M50,0 L100,100 L0,100 Z" fill="rgba(20, 20, 20, 0.9)">
        </svg>
        <div>
          <slot @slotchange=${this.helpTextSlotChange} name="help-text"></slot>
        </div>
      </div>
    </div>
    `;return w`
    <div class=${this.compact?"compact container":"container"}>
      <label for="search">
        <slot>
          No Data Provider
        </slot>
      </label>
      <input
        id="search"
        type="search"
        size="12"
        .value=${n}
        @input=${this.searchChange}
        @search=${this.doSearch}
        @keyup=${this.submitOnEnter}
      >
      <button @click=${this.doSearch}>
        <svg class=${this.searchPending?"spin":""} alt="Search" width="14" height="14" viewBox="0 0 512 512">
          ${L`
            <path
              d=${this.searchPending?s:r}
              fill="white"
            />
          `}
        </svg>
        <span class="search-btn-label">
          ${this.searchPending?"Searching":"Search"}
        </span>
      </button>
      ${p}
      <slot name="error">
        <div class=${""===this.errorType?"hidden":"error-display"}>
          <svg class="error-handle" width="10" height="10" viewBox="0 0 100 100">
            <path d="M50,0 L100,100 L0,100 Z" fill="rgba(179, 4, 26, 0.8)">
          </svg>
          <svg alt=${this.errorType} width="14" height="14" viewBox="0 0 578 512">
          ${L`
            <path
              d=${"No Results"===this.errorType?o:a}
              fill="white"
            />
          `}
          </svg>
          ${"No Results"===this.errorType?this.errorMessage:w`
          Oops! Something went wrong. <div class="small-padding"><small>${this.errorMessage}</small></div>
          `}
        </div>
      </slot>
    </div>
    <slot name="results">
      <byu-person-lookup-results
        class=${t&&0<t.length?"":"hidden"}
        .results=${t}
        .context=${e}
        .searchPending=${this.searchPending}
        .noAutoselect=${this.noAutoselect}
        @byu-lookup-results-close=${this.closeResults}
        @byu-lookup-next-page=${this.loadNextPage}
        @byu-lookup-prev-page=${this.loadPrevPage}
      ></byu-person-lookup-results>
    </slot>
    `}closeResults(){this.results=null,this.requestUpdate(),this.setPropsOnSearchResults({results:null})}registerProvider(e){this.__lookupProvider=e,this.addEventListener("byu-lookup-datasource-result",this.searchResults),this.addEventListener("byu-lookup-datasource-error",this.searchError),this.addEventListener("byu-lookup-datasource-searching",this.searchBegun),this.addEventListener("byu-lookup-results-close",this.closeResults),this.addEventListener("byu-lookup-next-page",this.loadNextPage),this.addEventListener("byu-lookup-prev-page",this.loadPrevPage),this.fetchFromProvider=this.__lookupProvider.performSearch,this.nextPageFromProvider=this.__lookupProvider.nextPage,this.prevPageFromProvider=this.__lookupProvider.prevPage}async connectedCallback(){super.connectedCallback(),await this.requestUpdate();const e=this.shadowRoot.querySelector("slot");if(e){const t=Array.from(e.assignedNodes()),n=t.find(t=>t.performSearch);if(n)return void this.registerProvider(n)}const t=setTimeout(()=>{throw new Error("No valid lookup provider found!")},1e4);this.addEventListener("byu-lookup-datasource-register",n=>{n.stopPropagation(),this.registerProvider(n.target),clearTimeout(t)});const n=this.shadowRoot.querySelector("slot[name='help-text'"),r=n.assignedNodes();0<r.length&&(this.hasSearchInfoSlotted=!0),this.requestUpdate()}setPropsOnSearchResults(e){const t=this.shadowRoot.querySelector("slot[name='results'"),n=t.assignedNodes();if(0===n.length)return;const r=n[0];Object.entries(e).forEach(([e,t])=>{r[e]=t})}searchResults(t){return t.stopPropagation(),this.searchPending=!1,0===t.detail.length&&0===this.results.length?(this.errorMessage="Hmmm, we couldn't find anyone.",this.errorType="No Results",void this.requestUpdate()):void(this.results=this.results.concat(t.detail),this.requestUpdate(),this.setPropsOnSearchResults({searchPending:!1,results:this.results}))}searchError(t){// Don't trigger any other lookup components
// window.alert(e.detail)
t.stopPropagation(),this.searchPending=!1,this.errorMessage=t.detail,this.errorType="Service Error",console.error("search error:\n",t.detail),this.requestUpdate(),this.setPropsOnSearchResults({searchPending:!1})}searchBegun(t){// Don't trigger any other lookup components
t.stopPropagation(),this.searchPending=!0,this.requestUpdate(),this.setPropsOnSearchResults({searchPending:!0})}searchChange(t){// console.log(`search=${this.search}`)
if(this.errorMessage="",this.errorType="",this.search=t.target.value,this.__lookupProvider){const e=this.search;this.__lookupProvider.search=e}this.requestUpdate()}submitOnEnter(t){"Enter"===t.key&&this.doSearch()}helpTextSlotChange(t){const e=this.shadowRoot.querySelector("slot[name='help-text'"),n=e.assignedNodes();this.hasSearchInfoSlotted=!!(0<n.length),this.requestUpdate()}doSearch(){this.errorMessage="",this.errorType="",this.results=[];const e=this.search.trim();0<e.length&&this.fetchFromProvider.call(this.__lookupProvider,e),this.requestUpdate()}loadNextPage(){// console.log(`loadNextPage`)
this.nextPageFromProvider.call(this.__lookupProvider)}loadPrevPage(){// console.log(`loadPrevPage`)
this.prevPageFromProvider.call(this.__lookupProvider)}}console.log("registering person lookup"),window.customElements.define("byu-person-lookup",be),console.log("registering person lookup results"),window.customElements.define("byu-person-lookup-results",xe)})();
