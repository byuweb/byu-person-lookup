const EVENT_PREFIX="byu-browser-oauth",EVENT_STATE_CHANGE=`${"byu-browser-oauth"}-state-changed`,EVENT_CURRENT_INFO_REQUESTED=`${"byu-browser-oauth"}-current-info-requested`;/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AuthenticationObserver{constructor(t,{notifyCurrent:n=!0}={}){this._listener=function(n){t(n.detail)},document.addEventListener(EVENT_STATE_CHANGE,this._listener,!1),n&&dispatch(EVENT_CURRENT_INFO_REQUESTED,{callback:t})}disconnect(){document.removeEventListener(EVENT_STATE_CHANGE,this._listener,!1)}}function dispatch(e,t){let n;"function"==typeof window.CustomEvent?n=new CustomEvent(e,{detail:t}):(n=document.createEvent("CustomEvent"),n.initCustomEvent(e,!0,!1,t)),document.dispatchEvent(n)}var commonjsGlobal="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?{}:self:global:window,FUNC_ERROR_TEXT="Expected a function",HASH_UNDEFINED="__lodash_hash_undefined__",INFINITY=1/0,funcTag="[object Function]",genTag="[object GeneratorFunction]",symbolTag="[object Symbol]",reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reEscapeChar=/\\(\\)?/g,reIsHostCtor=/^\[object .+?Constructor\]$/,freeGlobal="object"==typeof commonjsGlobal&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal,freeSelf="object"==typeof self&&self&&self.Object===Object&&self,root=freeGlobal||freeSelf||Function("return this")();/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ /**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(e,t){return null==e?void 0:e[t]}/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */function isHostObject(e){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(t){}return t}/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype,coreJsData=root["__core-js_shared__"],maskSrcKey=function(){var e=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),funcToString=funcProto.toString,hasOwnProperty=objectProto.hasOwnProperty,objectToString=objectProto.toString,reIsNative=RegExp("^"+funcToString.call(hasOwnProperty).replace(reRegExpChar,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Symbol$1=root.Symbol,splice=arrayProto.splice,Map$1=getNative(root,"Map"),nativeCreate=getNative(Object,"create"),symbolProto=Symbol$1?Symbol$1.prototype:void 0,symbolToString=symbolProto?symbolProto.toString:void 0;/** Used to detect overreaching core-js shims. */ /**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{}}/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(e){return this.has(e)&&delete this.__data__[e]}/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(e){var t=this.__data__;if(nativeCreate){var n=t[e];return n===HASH_UNDEFINED?void 0:n}return hasOwnProperty.call(t,e)?t[e]:void 0}/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(e){var t=this.__data__;return nativeCreate?t[e]!==void 0:hasOwnProperty.call(t,e)}/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(e,t){var n=this.__data__;return n[e]=nativeCreate&&void 0===t?HASH_UNDEFINED:t,this}// Add methods to `Hash`.
Hash.prototype.clear=hashClear,Hash.prototype["delete"]=hashDelete,Hash.prototype.get=hashGet,Hash.prototype.has=hashHas,Hash.prototype.set=hashSet;/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[]}/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(e){var t=this.__data__,n=assocIndexOf(t,e);if(0>n)return!1;var a=t.length-1;return n==a?t.pop():splice.call(t,n,1),!0}/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(e){var t=this.__data__,n=assocIndexOf(t,e);return 0>n?void 0:t[n][1]}/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(e){return-1<assocIndexOf(this.__data__,e)}/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(e,t){var n=this.__data__,a=assocIndexOf(n,e);return 0>a?n.push([e,t]):n[a][1]=t,this}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear,ListCache.prototype["delete"]=listCacheDelete,ListCache.prototype.get=listCacheGet,ListCache.prototype.has=listCacheHas,ListCache.prototype.set=listCacheSet;/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.__data__={hash:new Hash,map:new(Map$1||ListCache),string:new Hash}}/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(e){return getMapData(this,e)["delete"](e)}/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(e){return getMapData(this,e).get(e)}/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(e){return getMapData(this,e).has(e)}/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(e,t){return getMapData(this,e).set(e,t),this}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear,MapCache.prototype["delete"]=mapCacheDelete,MapCache.prototype.get=mapCacheGet,MapCache.prototype.has=mapCacheHas,MapCache.prototype.set=mapCacheSet;/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(e,t){for(var n=e.length;n--;)if(eq(e[n][0],t))return n;return-1}/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */function baseGet(e,t){t=isKey(t,e)?[t]:castPath(t);for(var n=0,a=t.length;null!=e&&n<a;)e=e[toKey(t[n++])];return n&&n==a?e:void 0}/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(e){if(!isObject(e)||isMasked(e))return!1;var t=isFunction(e)||isHostObject(e)?reIsNative:reIsHostCtor;return t.test(toSource(e))}/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */function baseToString(e){// Exit early for strings to avoid a performance hit in some environments.
if("string"==typeof e)return e;if(isSymbol(e))return symbolToString?symbolToString.call(e):"";var t=e+"";return"0"==t&&1/e==-INFINITY?"-0":t}/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */function castPath(e){return isArray(e)?e:stringToPath(e)}/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(e,t){var n=e.__data__;return isKeyable(t)?n["string"==typeof t?"string":"hash"]:n.map}/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(e,t){var n=getValue(e,t);return baseIsNative(n)?n:void 0}/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */function isKey(e,t){if(isArray(e))return!1;var n=typeof e;return!!("number"==n||"symbol"==n||"boolean"==n||null==e||isSymbol(e))||reIsPlainProp.test(e)||!reIsDeepProp.test(e)||null!=t&&e in Object(t)}/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(e){return!!maskSrcKey&&maskSrcKey in e}/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */var stringToPath=memoize(function(e){e=toString(e);var t=[];return reLeadingDot.test(e)&&t.push(""),e.replace(rePropName,function(e,n,a,r){t.push(a?r.replace(reEscapeChar,"$1"):n||e)}),t});/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */function toKey(e){if("string"==typeof e||isSymbol(e))return e;var t=e+"";return"0"==t&&1/e==-INFINITY?"-0":t}/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */function toSource(e){if(null!=e){try{return funcToString.call(e)}catch(t){}try{return e+""}catch(t){}}return""}/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */function memoize(e,t){if("function"!=typeof e||t&&"function"!=typeof t)throw new TypeError(FUNC_ERROR_TEXT);var n=function(){var a=arguments,r=t?t.apply(this,a):a[0],d=n.cache;if(d.has(r))return d.get(r);var i=e.apply(this,a);return n.cache=d.set(r,i),i};return n.cache=new(memoize.Cache||MapCache),n}// Assign cache to `_.memoize`.
memoize.Cache=MapCache;/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(e,t){return e===t||e!==e&&t!==t}/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(e){// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 8-9 which returns 'object' for typed array and other constructors.
var t=isObject(e)?objectToString.call(e):"";return t==funcTag||t==genTag}/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(e){return!!e&&"object"==typeof e}/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */function isSymbol(e){return"symbol"==typeof e||isObjectLike(e)&&objectToString.call(e)==symbolTag}/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */function toString(e){return null==e?"":baseToString(e)}/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */function get(e,t,n){var a=null==e?void 0:baseGet(e,t);return a===void 0?n:a}var lodash_get=get;/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const pickFirst=(e,t)=>e||t;function parseLinks(e){const t=lodash_get(e,"persons__next.href"),n=lodash_get(e,"persons__prev.href");return{next:t,prev:n}}function parseAddresses(e){return 400<=e.metadata.validation_response.code?null:e.values.reduce((e,t)=>{const n=[lodash_get(t,"address_line_1.value",""),lodash_get(t,"address_line_2.value",""),lodash_get(t,"address_line_3.value",""),lodash_get(t,"address_line_4.value","")].filter(e=>0<e.trim().length),a={MAL:"mailing",RES:"residential",WRK:"work",PRM:"permanent"}[t.address_type.value]||t.address_type.value;return Object.assign({},e,{[a]:n})},{})}function parseBasic(e){const t=e=>{const t=lodash_get(e,"preferred_surname.value",""),n=lodash_get(e,"preferred_first_name.value","");return`${t}, ${n}`},n=lodash_get(e,"name_lnf.value",t(e))||t(e),a=lodash_get(e,"byu_id.value",""),r=lodash_get(e,"net_id.value",""),d=lodash_get(e,"person_id.value","");return{name:n,byuId:a,netId:r,personId:d}}function parseEmailAddresses(e){return 400<=e.metadata.validation_response.code?null:e.values.map(t=>lodash_get(t,"email_address.value","")).filter(t=>!!t).reduce(pickFirst,"")}function parsePhones(e){return 400<=e.metadata.validation_response.code?null:e.values.map(e=>lodash_get(e,"phone_number.value","")).filter(e=>!!e).reduce(pickFirst,"")}function parseEmployeeSummaries(e){return 400<=e.metadata.validation_response.code?null:{employeeType:lodash_get(e,"employee_type.value"),department:lodash_get(e,"department.value"),jobTitle:lodash_get(e,"job_title.description")}}function parseStudentSummaries(e){if(400<=e.metadata.validation_response.code)return null;const t=lodash_get(e,"student_status.value");return{studentStatus:t}}function parsePerson(e){return Object.assign({addresses:parseAddresses(e.addresses),email:parseEmailAddresses(e.email_addresses),phone:parsePhones(e.phones)},parseBasic(e.basic),parseEmployeeSummaries(e.employee_summaries),parseStudentSummaries(e.student_summaries))}function parsePersonV2(e){const t=e.values.map(parsePerson);console.log(t);const{next:n,prev:a}=parseLinks(e.links);return{next:n,prev:a,people:t}}/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let authHeader=null,observer=null;function connect(){observer||(observer=new AuthenticationObserver(({state:e,token:t,user:n,error:a})=>{// React to change
authHeader=t?t.authorizationHeader:null}))}function nameParams(e){let t="",n="";if(/,/.test(e))// Assume 'Last, First'
[t,n]=e.split(",").map(e=>e.trim());else{// Assume 'First Middle Last'
const a=e.split(" ");t=a.slice(-1),n=a.slice(0,-1).join(" ")}return`?surname=${t}&rest_of_name=${n}`}function resolveSearchType(e){return 1>e.length?{q:`?surname=${e}`,label:"Search"}:/^\d{3,9}$/.test(e)?{q:`?byu_id=${e}`,label:"BYU ID"}:/^[a-z][a-z0-9]{2,7}$/.test(e)?{q:`?net_id=${e}`,label:"Net ID"}:/^[^@]+@.+$/.test(e)?{q:`?email_address=${e}`,label:"Email"}:/^[^ ]+ +[^ ]+[^0-9]*$/.test(e)?{q:`${nameParams(e)}`,label:"Name"}:{q:`?surname=${e}`,label:"Name"}}async function search(e,t){if(!authHeader)throw new Error("Not authenticated!");const{q:n}=resolveSearchType(e),a={method:"GET",headers:new window.Headers({Authorization:authHeader})},r=await window.fetch(t||`${"https://api.byu.edu:443/byuapi/persons/v2/"}${n}&field_sets=${"basic,addresses,email_addresses,phones,employee_summaries,student_summaries"}&page_size=50`,a);if(r.ok){const e=await r.json();return parsePersonV2(e)}if(404===r.status)return{};const d=`Error ${r.status} while querying personsv2`;throw new Error(d)}// in disconnectedCallback():
function disconnect(){observer&&observer.disconnect(),observer=null}/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /* eslint-disable no-unused-vars */ /**
 * When using Closure Compiler, JSCompiler_renameProperty(property, object) is replaced by the munged name for object[property]
 * We cannot alias this function, so we have to use a small shim that has the same behavior when not compiling.
 *
 * @param {string} prop Property name
 * @param {?Object} obj Reference object
 * @return {string} Potentially renamed property name
 */window.JSCompiler_renameProperty=function(e){return e};/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ // unique global id for deduping mixins.
let dedupeId=0;/* eslint-disable valid-jsdoc */ /**
 * Wraps an ES6 class expression mixin such that the mixin is only applied
 * if it has not already been applied its base argument. Also memoizes mixin
 * applications.
 *
 * @template T
 * @param {T} mixin ES6 class expression mixin to wrap
 * @return {T}
 * @suppress {invalidCasts}
 */const dedupingMixin=function(e){function t(t){let r=/** @type {!MixinFunction} */t.__mixinSet;if(r&&r[a])return t;let d=n,i=d.get(t);i||(i=/** @type {!Function} */e(t),d.set(t,i));// copy inherited mixin set from the extended class, or the base class
// NOTE: we avoid use of Set here because some browser (IE11)
// cannot extend a base Set via the constructor.
let s=Object.create(/** @type {!MixinFunction} */i.__mixinSet||r||null);return s[a]=!0,i.__mixinSet=s,i}let n=/** @type {!MixinFunction} */e.__mixinApplications;n||(n=new WeakMap,e.__mixinApplications=n);// maintain a unique id for each mixin
let a=dedupeId++;return t};/* eslint-enable valid-jsdoc */ /**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ // Microtask implemented using Mutation Observer
let microtaskCurrHandle=0,microtaskLastHandle=0,microtaskCallbacks=[],microtaskNodeContent=0,microtaskNode=document.createTextNode("");new window.MutationObserver(microtaskFlush).observe(microtaskNode,{characterData:!0});function microtaskFlush(){const e=microtaskCallbacks.length;for(let t,n=0;n<e;n++)if(t=microtaskCallbacks[n],t)try{t()}catch(t){setTimeout(()=>{throw t})}microtaskCallbacks.splice(0,e),microtaskLastHandle+=e}/**
 * Async interface for enqueuing callbacks that run at microtask timing.
 *
 * Note that microtask timing is achieved via a single `MutationObserver`,
 * and thus callbacks enqueued with this API will all run in a single
 * batch, and not interleaved with other microtasks such as promises.
 * Promises are avoided as an implementation choice for the time being
 * due to Safari bugs that cause Promises to lack microtask guarantees.
 *
 * @namespace
 * @summary Async interface for enqueuing callbacks that run at microtask
 *   timing.
 */const microTask={/**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */run(e){return microtaskNode.textContent=microtaskNodeContent++,microtaskCallbacks.push(e),microtaskCurrHandle++},/**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */cancel(e){const t=e-microtaskLastHandle;if(0<=t){if(!microtaskCallbacks[t])throw new Error("invalid async handle: "+e);microtaskCallbacks[t]=null}}},microtask=microTask,PropertiesChanged=dedupingMixin(/**
     * @template T
     * @param {function(new:T)} superClass Class to apply mixin to.
     * @return {function(new:T)} superClass with mixin applied.
     */e=>{/**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertiesChanged}
   * @unrestricted
   */return class extends e{/**
     * Creates property accessors for the given property names.
     * @param {!Object} props Object whose keys are names of accessors.
     * @return {void}
     * @protected
     */static createProperties(e){const t=this.prototype;for(let n in e)// don't stomp an existing accessor
n in t||t._createPropertyAccessor(n)}/**
     * Returns an attribute name that corresponds to the given property.
     * The attribute name is the lowercased property name. Override to
     * customize this mapping.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     */static attributeNameForProperty(e){return e.toLowerCase()}/**
     * Override point to provide a type to which to deserialize a value to
     * a given property.
     * @param {string} name Name of property
     *
     * @protected
     */static typeForProperty(){}//eslint-disable-line no-unused-vars
/**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @return {void}
     * @protected
     * @override
     */_createPropertyAccessor(e,t){this._addPropertyToAttributeMap(e),this.hasOwnProperty("__dataHasAccessor")||(this.__dataHasAccessor=Object.assign({},this.__dataHasAccessor)),this.__dataHasAccessor[e]||(this.__dataHasAccessor[e]=!0,this._definePropertyAccessor(e,t))}/**
     * Adds the given `property` to a map matching attribute names
     * to property names, using `attributeNameForProperty`. This map is
     * used when deserializing attribute values to properties.
     *
     * @param {string} property Name of the property
     * @override
     */_addPropertyToAttributeMap(e){if(this.hasOwnProperty("__dataAttributes")||(this.__dataAttributes=Object.assign({},this.__dataAttributes)),!this.__dataAttributes[e]){const t=this.constructor.attributeNameForProperty(e);this.__dataAttributes[t]=e}}/**
     * Defines a property accessor for the given property.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     * @return {void}
     * @override
     */_definePropertyAccessor(e,t){Object.defineProperty(this,e,{/* eslint-disable valid-jsdoc */ /** @this {PropertiesChanged} */get(){return this._getProperty(e)},/** @this {PropertiesChanged} */set:t?function(){}:function(t){this._setProperty(e,t)}/* eslint-enable */})}constructor(){super(),this.__dataEnabled=!1,this.__dataReady=!1,this.__dataInvalid=!1,this.__data={},this.__dataPending=null,this.__dataOld=null,this.__dataInstanceProps=null,this.__serializing=!1,this._initializeProperties()}/**
     * Lifecycle callback called when properties are enabled via
     * `_enableProperties`.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its property data initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @return {void}
     * @public
     * @override
     */ready(){this.__dataReady=!0,this._flushProperties()}/**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @return {void}
     * @protected
     * @override
     */_initializeProperties(){// Capture instance properties; these will be set into accessors
// during first flush. Don't set them here, since we want
// these to overwrite defaults/constructor assignments
for(let e in this.__dataHasAccessor)this.hasOwnProperty(e)&&(this.__dataInstanceProps=this.__dataInstanceProps||{},this.__dataInstanceProps[e]=this[e],delete this[e])}/**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */_initializeInstanceProperties(e){Object.assign(this,e)}/**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     * @protected
     * @override
     */_setProperty(e,t){this._setPendingProperty(e,t)&&this._invalidateProperties()}/**
     * Returns the value for the given property.
     * @param {string} property Name of property
     * @return {*} Value for the given property
     * @protected
     * @override
     */_getProperty(e){return this.__data[e]}/* eslint-disable no-unused-vars */ /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} ext Not used here; affordance for closure
     * @return {boolean} Returns true if the property changed
     * @protected
     * @override
     */_setPendingProperty(e,t){let n=this.__data[e],a=this._shouldPropertyChange(e,t,n);return a&&(!this.__dataPending&&(this.__dataPending={},this.__dataOld={}),this.__dataOld&&!(e in this.__dataOld)&&(this.__dataOld[e]=n),this.__data[e]=t,this.__dataPending[e]=t),a}/* eslint-enable */ /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @return {void}
     * @protected
     * @override
     */_invalidateProperties(){!this.__dataInvalid&&this.__dataReady&&(this.__dataInvalid=!0,microtask.run(()=>{this.__dataInvalid&&(this.__dataInvalid=!1,this._flushProperties())}))}/**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     *
     * @return {void}
     * @protected
     * @override
     */_enableProperties(){this.__dataEnabled||(this.__dataEnabled=!0,this.__dataInstanceProps&&(this._initializeInstanceProperties(this.__dataInstanceProps),this.__dataInstanceProps=null),this.ready())}/**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     * @return {void}
     * @protected
     * @override
     */_flushProperties(){const e=this.__data,t=this.__dataPending,n=this.__dataOld;this._shouldPropertiesChange(e,t,n)&&(this.__dataPending=null,this.__dataOld=null,this._propertiesChanged(e,t,n))}/**
     * Called in `_flushProperties` to determine if `_propertiesChanged`
     * should be called. The default implementation returns true if
     * properties are pending. Override to customize when
     * `_propertiesChanged` is called.
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {boolean} true if changedProps is truthy
     * @override
     */_shouldPropertiesChange(e,t){// eslint-disable-line no-unused-vars
return!!t}/**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     * @protected
     * @override
     */_propertiesChanged(){}// eslint-disable-line no-unused-vars
/**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` if a strict equality
     * check fails. The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     * @override
     */_shouldPropertyChange(e,t,n){return(// Strict equality check
n!==t&&(// This ensures (old==NaN, value==NaN) always returns false
n===n||t===t))}/**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     * @param {?string} namespace Attribute namespace.
     * @return {void}
     * @suppress {missingProperties} Super may or may not implement the callback
     * @override
     */attributeChangedCallback(e,t,n,a){t!==n&&this._attributeToProperty(e,n),super.attributeChangedCallback&&super.attributeChangedCallback(e,t,n,a)}/**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to, defaults to the value
     * returned from `typeForProperty`
     * @return {void}
     * @override
     */_attributeToProperty(e,t,n){if(!this.__serializing){const a=this.__dataAttributes,r=a&&a[e]||e;this[r]=this._deserializeValue(t,n||this.constructor.typeForProperty(r))}}/**
     * Serializes a property to its associated attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is an element.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect to.
     * @param {*=} value Property value to refect.
     * @return {void}
     * @override
     */_propertyToAttribute(e,t,n){this.__serializing=!0,n=3>arguments.length?this[e]:n,this._valueToNodeAttribute(/** @type {!HTMLElement} */this,n,t||this.constructor.attributeNameForProperty(e)),this.__serializing=!1}/**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @return {void}
     * @override
     */_valueToNodeAttribute(e,t,n){const a=this._serializeValue(t);a===void 0?e.removeAttribute(n):e.setAttribute(n,a)}/**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called when setting JS property values to
     * HTML attributes.  Users may override this method to provide
     * serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided
     * property  value.
     * @override
     */_serializeValue(e){switch(typeof e){case"boolean":return e?"":void 0;default:return null==e?void 0:e.toString();}}/**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called when reading HTML attribute values to
     * JS properties.  Users may override this method to provide
     * deserialization for custom `type`s. Types for `Boolean`, `String`,
     * and `Number` convert attributes to the expected types.
     *
     * @param {?string} value Value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */_deserializeValue(e,t){return t===Boolean?null!==e:t===Number?+e:e}}});/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /** @const {!AsyncInterface} */ /**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * Creates a copy of `props` with each property normalized such that
 * upgraded it is an object with at least a type property { type: Type}.
 *
 * @param {Object} props Properties to normalize
 * @return {Object} Copy of input `props` with normalized properties that
 * are in the form {type: Type}
 * @private
 */function normalizeProperties(e){const t={};for(let n in e){const a=e[n];t[n]="function"==typeof a?{type:a}:a}return t}/**
 * Mixin that provides a minimal starting point to using the PropertiesChanged
 * mixin by providing a mechanism to declare properties in a static
 * getter (e.g. static get properties() { return { foo: String } }). Changes
 * are reported via the `_propertiesChanged` method.
 *
 * This mixin provides no specific support for rendering. Users are expected
 * to create a ShadowRoot and put content into it and update it in whatever
 * way makes sense. This can be done in reaction to properties changing by
 * implementing `_propertiesChanged`.
 *
 * @mixinFunction
 * @polymer
 * @appliesMixin PropertiesChanged
 * @summary Mixin that provides a minimal starting point for using
 * the PropertiesChanged mixin by providing a declarative `properties` object.
 */const PropertiesMixin=dedupingMixin(e=>{/**
  * Returns the super class constructor for the given class, if it is an
  * instance of the PropertiesMixin.
  *
  * @param {!PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {?PropertiesMixinConstructor} Super class constructor
  */function t(e){const t=Object.getPrototypeOf(e);// Note, the `PropertiesMixin` class below only refers to the class
// generated by this call to the mixin; the instanceof test only works
// because the mixin is deduped and guaranteed only to apply once, hence
// all constructors in a proto chain will see the same `PropertiesMixin`
return t.prototype instanceof r?/** @type {!PropertiesMixinConstructor} */t:null}/**
  * Returns a memoized version of the `properties` object for the
  * given class. Properties not in object format are converted to at
  * least {type}.
  *
  * @param {PropertiesMixinConstructor} constructor PropertiesMixin constructor
  * @return {Object} Memoized properties object
  */function n(e){if(!e.hasOwnProperty(JSCompiler_renameProperty("__ownProperties",e))){let t=null;if(e.hasOwnProperty(JSCompiler_renameProperty("properties",e))){const n=e.properties;n&&(t=normalizeProperties(n))}e.__ownProperties=t}return e.__ownProperties}/**
  * @polymer
  * @mixinClass
  * @extends {base}
  * @implements {Polymer_PropertiesMixin}
  * @unrestricted
  */ /**
  * @constructor
  * @implements {Polymer_PropertiesChanged}
  * @private
  */const a=PropertiesChanged(e);class r extends a{/**
    * Implements standard custom elements getter to observes the attributes
    * listed in `properties`.
    * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
    */static get observedAttributes(){const e=this._properties;return e?Object.keys(e).map(e=>this.attributeNameForProperty(e)):[]}/**
    * Finalizes an element definition, including ensuring any super classes
    * are also finalized. This includes ensuring property
    * accessors exist on the element prototype. This method calls
    * `_finalizeClass` to finalize each constructor in the prototype chain.
    * @return {void}
    */static finalize(){if(!this.hasOwnProperty(JSCompiler_renameProperty("__finalized",this))){const e=t(/** @type {!PropertiesMixinConstructor} */this);e&&e.finalize(),this.__finalized=!0,this._finalizeClass()}}/**
    * Finalize an element class. This includes ensuring property
    * accessors exist on the element prototype. This method is called by
    * `finalize` and finalizes the class constructor.
    *
    * @protected
    */static _finalizeClass(){const e=n(/** @type {!PropertiesMixinConstructor} */this);e&&this.createProperties(e)}/**
    * Returns a memoized version of all properties, including those inherited
    * from super classes. Properties not in object format are converted to
    * at least {type}.
    *
    * @return {Object} Object containing properties for this class
    * @protected
    */static get _properties(){if(!this.hasOwnProperty(JSCompiler_renameProperty("__properties",this))){const e=t(/** @type {!PropertiesMixinConstructor} */this);this.__properties=Object.assign({},e&&e._properties,n(/** @type {PropertiesMixinConstructor} */this))}return this.__properties}/**
    * Overrides `PropertiesChanged` method to return type specified in the
    * static `properties` object for the given property.
    * @param {string} name Name of property
    * @return {*} Type to which to deserialize attribute
    *
    * @protected
    */static typeForProperty(e){const t=this._properties[e];return t&&t.type}/**
    * Overrides `PropertiesChanged` method and adds a call to
    * `finalize` which lazily configures the element's property accessors.
    * @override
    * @return {void}
    */_initializeProperties(){this.constructor.finalize(),super._initializeProperties()}/**
    * Called when the element is added to a document.
    * Calls `_enableProperties` to turn on property system from
    * `PropertiesChanged`.
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    * @override
    */connectedCallback(){super.connectedCallback&&super.connectedCallback(),this._enableProperties()}/**
    * Called when the element is removed from a document
    * @suppress {missingProperties} Super may or may not implement the callback
    * @return {void}
    * @override
    */disconnectedCallback(){super.disconnectedCallback&&super.disconnectedCallback()}}return r}),templateCaches=new Map;/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/ /**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ // The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */class TemplateResult{constructor(e,t,n,a=defaultPartCallback){this.strings=e,this.values=t,this.type=n,this.partCallback=a}/**
     * Returns a string of HTML used to create a <template> element.
     */getHTML(){const e=this.strings.length-1;let t="",n=!0;for(let a=0;a<e;a++){const e=this.strings[a];t+=e;// We're in a text position if the previous string closed its tags.
// If it doesn't have any tags, then we use the previous text position
// state.
const r=findTagClose(e);n=-1<r?r<e.length:n,t+=n?nodeMarker:marker}return t+=this.strings[e],t}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}/**
 * An expression marker with embedded unique key to avoid collision with
 * possible text in templates.
 */const marker=`{{lit-${(Math.random()+"").slice(2)}}}`,nodeMarker=`<!--${marker}-->`,markerRegex=new RegExp(`${marker}|${nodeMarker}`),lastAttributeNameRegex=/[ \x09\x0a\x0c\x0d]([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)[ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*)$/;/**
 * An expression marker used text-positions, not attribute positions,
 * in template.
 */ /**
 * Finds the closing index of the last closed HTML tag.
 * This has 3 possible return values:
 *   - `-1`, meaning there is no tag in str.
 *   - `string.length`, meaning the last opened tag is unclosed.
 *   - Some positive number < str.length, meaning the index of the closing '>'.
 */function findTagClose(e){const t=e.lastIndexOf(">"),n=e.indexOf("<",t+1);return-1<n?e.length:t}/**
 * A placeholder for a dynamic expression in an HTML template.
 *
 * There are two built-in part types: AttributePart and NodePart. NodeParts
 * always represent a single dynamic expression, while AttributeParts may
 * represent as many expressions are contained in the attribute.
 *
 * A Template's parts are mutable, so parts can be replaced or modified
 * (possibly to implement different template semantics). The contract is that
 * parts can only be replaced, not removed, added or reordered, and parts must
 * always consume the correct number of values in their `update()` method.
 *
 * TODO(justinfagnani): That requirement is a little fragile. A
 * TemplateInstance could instead be more careful about which values it gives
 * to Part.update().
 */class TemplatePart{constructor(e,t,n,a,r){this.type=e,this.index=t,this.name=n,this.rawName=a,this.strings=r}}const isTemplatePartActive=e=>-1!==e.index;/**
 * An updateable Template that tracks the location of dynamic parts.
 */class Template{constructor(e,t){this.parts=[],this.element=t;const n=this.element.content,a=document.createTreeWalker(n,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
               NodeFilter.SHOW_TEXT */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
let r=-1,d=0;const i=[];// The actual previous node, accounting for removals: if a node is removed
// it will never be the previousNode.
let s,o;// Used to set previousNode at the top of the loop.
for(;a.nextNode();){r++,s=o;const t=o=a.currentNode;if(1===t.nodeType/* Node.ELEMENT_NODE */){if(!t.hasAttributes())continue;const n=t.attributes;// Per https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order. In
// particular, Edge/IE can return them out of order, so we cannot assume
// a correspondance between part index and attribute index.
let a=0;for(let e=0;e<n.length;e++)0<=n[e].value.indexOf(marker)&&a++;for(;0<a--;){// Get the template literal section leading up to the first
// expression in this attribute
const a=e.strings[d],i=lastAttributeNameRegex.exec(a)[1],s=n.getNamedItem(i),o=s.value.split(markerRegex);// Find the attribute name
this.parts.push(new TemplatePart("attribute",r,s.name,i,o)),t.removeAttribute(s.name),d+=o.length-1}}else if(3===t.nodeType/* Node.TEXT_NODE */){const e=t.nodeValue;if(0>e.indexOf(marker))continue;const n=t.parentNode,a=e.split(markerRegex),s=a.length-1;d+=s;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let e=0;e<s;e++)n.insertBefore(""===a[e]?document.createComment(""):document.createTextNode(a[e]),t),this.parts.push(new TemplatePart("node",r++));n.insertBefore(""===a[s]?document.createComment(""):document.createTextNode(a[s]),t),i.push(t)}else if(8===t.nodeType/* Node.COMMENT_NODE */&&t.nodeValue===marker){const e=t.parentNode,n=t.previousSibling;// Add a new marker node to be the startNode of the Part if any of the
// following are true:
//  * We don't have a previousSibling
//  * previousSibling is being removed (thus it's not the
//    `previousNode`)
//  * previousSibling is not a Text node
//
// TODO(justinfagnani): We should be able to use the previousNode here
// as the marker node and reduce the number of extra nodes we add to a
// template. See https://github.com/PolymerLabs/lit-html/issues/147
null===n||n!==s||n.nodeType!==Node.TEXT_NODE?e.insertBefore(document.createComment(""),t):r--,this.parts.push(new TemplatePart("node",r++)),i.push(t),null===t.nextSibling?e.insertBefore(document.createComment(""),t):r--,o=s,d++}}// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const a of i)a.parentNode.removeChild(a)}}/**
 * Returns a value ready to be inserted into a Part from a user-provided value.
 *
 * If the user value is a directive, this invokes the directive with the given
 * part. If the value is null, it's converted to undefined to work better
 * with certain DOM APIs, like textContent.
 */const getValue$1=(e,t)=>isDirective(t)?(t=t(e),noChange):null===t?void 0:t,isDirective=e=>"function"==typeof e&&!0===e.__litDirective,noChange={},isPrimitiveValue=e=>null===e||"object"!=typeof e&&"function"!=typeof e;class AttributePart{constructor(e,t,n,a){this.instance=e,this.element=t,this.name=n,this.strings=a,this.size=a.length-1,this._previousValues=[]}_interpolate(e,t){const n=this.strings,a=n.length-1;let r="";for(let d=0;d<a;d++){r+=n[d];const a=getValue$1(this,e[t+d]);if(a&&a!==noChange&&(Array.isArray(a)||"string"!=typeof a&&a[Symbol.iterator]))for(const e of a)// TODO: we need to recursively call getValue into iterables...
r+=e;else r+=a}return r+n[a]}_equalToPreviousValues(e,t){for(let n=t;n<t+this.size;n++)if(this._previousValues[n]!==e[n]||!isPrimitiveValue(e[n]))return!1;return!0}setValue(e,t){if(this._equalToPreviousValues(e,t))return;const n=this.strings;let a;2===n.length&&""===n[0]&&""===n[1]?(a=getValue$1(this,e[t]),Array.isArray(a)&&(a=a.join(""))):a=this._interpolate(e,t),a!==noChange&&this.element.setAttribute(this.name,a),this._previousValues=e}}class NodePart{constructor(e,t,n){this.instance=e,this.startNode=t,this.endNode=n,this._previousValue=void 0}setValue(e){if(e=getValue$1(this,e),e!==noChange)if(isPrimitiveValue(e)){// Handle primitive values
// If the value didn't change, do nothing
if(e===this._previousValue)return;this._setText(e)}else e instanceof TemplateResult?this._setTemplateResult(e):Array.isArray(e)||e[Symbol.iterator]?this._setIterable(e):e instanceof Node?this._setNode(e):void 0===e.then?// Fallback, will render the string representation
this._setText(e):this._setPromise(e)}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_setNode(e){this._previousValue===e||(this.clear(),this._insert(e),this._previousValue=e)}_setText(e){const t=this.startNode.nextSibling;e=e===void 0?"":e,t===this.endNode.previousSibling&&t.nodeType===Node.TEXT_NODE?t.textContent=e:this._setNode(document.createTextNode(e)),this._previousValue=e}_setTemplateResult(e){const t=this.instance._getTemplate(e);let n;this._previousValue&&this._previousValue.template===t?n=this._previousValue:(n=new TemplateInstance(t,this.instance._partCallback,this.instance._getTemplate),this._setNode(n._clone()),this._previousValue=n),n.update(e.values)}_setIterable(e){Array.isArray(this._previousValue)||(this.clear(),this._previousValue=[]);// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const t=this._previousValue;let n=0;for(const a of e){// Try to reuse an existing part
let e=t[n];// If no existing part, create a new one
if(e===void 0){// If we're creating the first item part, it's startNode should be the
// container's startNode
let a=this.startNode;// If we're not creating the first part, create a new separator marker
// node, and fix up the previous part's endNode to point to it
if(0<n){const e=t[n-1];a=e.endNode=document.createTextNode(""),this._insert(a)}e=new NodePart(this.instance,a,this.endNode),t.push(e)}e.setValue(a),n++}if(0==n)this.clear(),this._previousValue=void 0;else if(n<t.length){const e=t[n-1];// Truncate the parts array so _previousValue reflects the current state
t.length=n,this.clear(e.endNode.previousSibling),e.endNode=this.endNode}}_setPromise(e){this._previousValue=e,e.then(t=>{this._previousValue===e&&this.setValue(t)})}clear(e=this.startNode){removeNodes(this.startNode.parentNode,e.nextSibling,this.endNode)}}const defaultPartCallback=(e,t,n)=>{if("attribute"===t.type)return new AttributePart(e,n,t.name,t.strings);if("node"===t.type)return new NodePart(e,n,n.nextSibling);throw new Error(`Unknown part type ${t.type}`)};/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */class TemplateInstance{constructor(e,t,n){this._parts=[],this.template=e,this._partCallback=t,this._getTemplate=n}update(e){let t=0;for(const n of this._parts)n?void 0===n.size?(n.setValue(e[t]),t++):(n.setValue(e,t),t+=n.size):t++}_clone(){// Clone the node, rather than importing it, to keep the fragment in the
// template's document. This leaves the fragment inert so custom elements
// won't upgrade until after the main document adopts the node.
const e=this.template.element.content.cloneNode(!0),t=this.template.parts;if(0<t.length){// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const n=document.createTreeWalker(e,133/* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
                   NodeFilter.SHOW_TEXT */,null,!1);let a=-1;for(let e=0;e<t.length;e++){const r=t[e],d=isTemplatePartActive(r);// An inactive part has no coresponding Template node.
if(d)for(;a<r.index;)a++,n.nextNode();this._parts.push(d?this._partCallback(this,r,n.currentNode):void 0)}}return e}}/**
 * Removes nodes, starting from `startNode` (inclusive) to `endNode`
 * (exclusive), from `container`.
 */const removeNodes=(e,t,n=null)=>{for(let a=t;a!==n;){const t=a.nextSibling;e.removeChild(a),a=t}},walkerNodeFilter=NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT|NodeFilter.SHOW_TEXT;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1, removed 4 nodes)
 */function removeNodesFromTemplate(e,t){const{element:{content:a},parts:n}=e,r=document.createTreeWalker(a,walkerNodeFilter,null,!1);let d=0,i=n[0],s=-1,o=0;const l=[];for(let a=null;r.nextNode();){s++;const e=r.currentNode;// End removal if stepped past the removing node
for(e.previousSibling===a&&(a=null),t.has(e)&&(l.push(e),null===a&&(a=e)),null!==a&&o++;i!==void 0&&i.index===s;)// If part is in a removed node deactivate it by setting index to -1 or
// adjust the index as needed.
i.index=null===a?i.index-o:-1,i=n[++d]}l.forEach(e=>e.parentNode.removeChild(e))}const countNodes=e=>{let t=1;for(const n=document.createTreeWalker(e,walkerNodeFilter,null,!1);n.nextNode();)t++;return t},nextActiveIndexInTemplateParts=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(isTemplatePartActive(t))return n}return-1};/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */function insertNodeIntoTemplate(e,t,n=null){const{element:{content:r},parts:a}=e;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===n||void 0===n)return void r.appendChild(t);const d=document.createTreeWalker(r,walkerNodeFilter,null,!1);let i=nextActiveIndexInTemplateParts(a),s=0,o=-1;for(;d.nextNode();){o++;const e=d.currentNode;for(e===n&&(n.parentNode.insertBefore(t,n),s=countNodes(t));-1!==i&&a[i].index===o;){// If we've inserted the node, simply adjust all subsequent parts
if(0<s){for(;-1!==i;)a[i].index+=s,i=nextActiveIndexInTemplateParts(a,i);return}i=nextActiveIndexInTemplateParts(a,i)}}}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ // Get a key to lookup in `templateCaches`.
const getTemplateCacheKey=(e,t)=>`${e}--${t}`,shadyTemplateFactory=e=>t=>{const n=getTemplateCacheKey(t.type,e);let a=templateCaches.get(n);a===void 0&&(a=new Map,templateCaches.set(n,a));let r=a.get(t.strings);if(r===void 0){const n=t.getTemplateElement();"object"==typeof window.ShadyCSS&&window.ShadyCSS.prepareTemplateDom(n,e),r=new Template(t,n),a.set(t.strings,r)}return r},TEMPLATE_TYPES=["html","svg"];/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */ /**
 * Removes all style elements from Templates for the given scopeName.
 */function removeStylesFromLitTemplates(e){TEMPLATE_TYPES.forEach(t=>{const n=templateCaches.get(getTemplateCacheKey(t,e));n!==void 0&&n.forEach(e=>{const{element:{content:t}}=e,n=t.querySelectorAll("style");removeNodesFromTemplate(e,new Set(Array.from(n)))})})}const shadyRenderSet=new Set,ensureStylesScoped=(e,t,n)=>{// only scope element template once per scope name
if(!shadyRenderSet.has(n)){shadyRenderSet.add(n);const a=document.createElement("template");// ApplyShim case
if(Array.from(e.querySelectorAll("style")).forEach(e=>{a.content.appendChild(e)}),window.ShadyCSS.prepareTemplateStyles(a,n),removeStylesFromLitTemplates(n),window.ShadyCSS.nativeShadow){const n=a.content.querySelector("style");null!==n&&(e.insertBefore(n,e.firstChild),insertNodeIntoTemplate(t,n.cloneNode(!0),t.element.content.firstChild))}}};/**
 * For the given scope name, ensures that ShadyCSS style scoping is performed.
 * This is done just once per scope name so the fragment and template cannot
 * be modified.
 * (1) extracts styles from the rendered fragment and hands them to ShadyCSS
 * to be scoped and appended to the document
 * (2) removes style elements from all lit-html Templates for this scope name.
 *
 * Note, <style> elements can only be placed into templates for the
 * initial rendering of the scope. If <style> elements are included in templates
 * dynamically rendered to the scope (after the first scope render), they will
 * not be scoped and the <style> will be left in the template and rendered output.
 */ // NOTE: We're copying code from lit-html's `render` method here.
// We're doing this explicitly because the API for rendering templates is likely
// to change in the near term.
function render$1(e,t,n){const a=shadyTemplateFactory(n),r=a(e);let d=t.__templateInstance;// Repeat render, just call update()
if(void 0!==d&&d.template===r&&d._partCallback===e.partCallback)return void d.update(e.values);// First render, create a new TemplateInstance and append it
d=new TemplateInstance(r,e.partCallback,a),t.__templateInstance=d;const i=d._clone();d.update(e.values);const s=t instanceof ShadowRoot?t.host:void 0;// If there's a shadow host, do ShadyCSS scoping...
s!==void 0&&"object"==typeof window.ShadyCSS&&(ensureStylesScoped(i,r,n),window.ShadyCSS.styleElement(s)),removeNodes(t,t.firstChild),t.appendChild(i)}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * Interprets a template literal as a lit-extended HTML template.
 */const html$1=(e,...t)=>new TemplateResult(e,t,"html",extendedPartCallback),extendedPartCallback=(e,t,n)=>{if("attribute"===t.type){if("on-"===t.rawName.substr(0,3)){const a=t.rawName.slice(3);return new EventPart(e,n,a)}const a=t.name.substr(t.name.length-1);if("$"===a){const a=t.name.slice(0,-1);return new AttributePart(e,n,a,t.strings)}if("?"===a){const a=t.name.slice(0,-1);return new BooleanAttributePart(e,n,a,t.strings)}return new PropertyPart(e,n,t.rawName,t.strings)}return defaultPartCallback(e,t,n)};/**
 * A PartCallback which allows templates to set properties and declarative
 * event handlers.
 *
 * Properties are set by default, instead of attributes. Attribute names in
 * lit-html templates preserve case, so properties are case sensitive. If an
 * expression takes up an entire attribute value, then the property is set to
 * that value. If an expression is interpolated with a string or other
 * expressions then the property is set to the string result of the
 * interpolation.
 *
 * To set an attribute instead of a property, append a `$` suffix to the
 * attribute name.
 *
 * Example:
 *
 *     html`<button class$="primary">Buy Now</button>`
 *
 * To set an event handler, prefix the attribute name with `on-`:
 *
 * Example:
 *
 *     html`<button on-click=${(e)=> this.onClickHandler(e)}>Buy Now</button>`
 *
 */ /**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */class BooleanAttributePart extends AttributePart{setValue(e,t){const n=this.strings;if(2===n.length&&""===n[0]&&""===n[1]){const n=getValue$1(this,e[t]);if(n===noChange)return;n?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)}else throw new Error("boolean attributes can only contain a single expression")}}class PropertyPart extends AttributePart{setValue(e,t){const n=this.strings;let a;this._equalToPreviousValues(e,t)||(a=2===n.length&&""===n[0]&&""===n[1]?getValue$1(this,e[t]):this._interpolate(e,t),a!==noChange&&(this.element[this.name]=a),this._previousValues=e)}}class EventPart{constructor(e,t,n){this.instance=e,this.element=t,this.eventName=n}setValue(e){const t=getValue$1(this,e);t===this._listener||(null==t?this.element.removeEventListener(this.eventName,this):null==this._listener&&this.element.addEventListener(this.eventName,this),this._listener=t)}handleEvent(e){"function"==typeof this._listener?this._listener.call(this.element,e):"function"==typeof this._listener.handleEvent&&this._listener.handleEvent(e)}}class LitElement extends PropertiesMixin(HTMLElement){constructor(){super(...arguments),this.__renderComplete=null,this.__resolveRenderComplete=null,this.__isInvalid=!1,this.__isChanging=!1}/**
     * Override which sets up element rendering by calling* `_createRoot`
     * and `_firstRendered`.
     */ready(){this._root=this._createRoot(),super.ready(),this._firstRendered()}connectedCallback(){window.ShadyCSS&&this._root&&window.ShadyCSS.styleElement(this),super.connectedCallback()}/**
     * Called after the element DOM is rendered for the first time.
     * Implement to perform tasks after first rendering like capturing a
     * reference to a static node which must be directly manipulated.
     * This should not be commonly needed. For tasks which should be performed
     * before first render, use the element constructor.
     */_firstRendered(){}/**
     * Implement to customize where the element's template is rendered by
     * returning an element into which to render. By default this creates
     * a shadowRoot for the element. To render into the element's childNodes,
     * return `this`.
     * @returns {Element|DocumentFragment} Returns a node into which to render.
     */_createRoot(){return this.attachShadow({mode:"open"})}/**
     * Override which returns the value of `_shouldRender` which users
     * should implement to control rendering. If this method returns false,
     * _propertiesChanged will not be called and no rendering will occur even
     * if property values change or `requestRender` is called.
     * @param _props Current element properties
     * @param _changedProps Changing element properties
     * @param _prevProps Previous element properties
     * @returns {boolean} Default implementation always returns true.
     */_shouldPropertiesChange(e,t,n){const a=this._shouldRender(e,t,n);return!a&&this.__resolveRenderComplete&&this.__resolveRenderComplete(!1),a}/**
     * Implement to control if rendering should occur when property values
     * change or `requestRender` is called. By default, this method always
     * returns true, but this can be customized as an optimization to avoid
     * rendering work when changes occur which should not be rendered.
     * @param _props Current element properties
     * @param _changedProps Changing element properties
     * @param _prevProps Previous element properties
     * @returns {boolean} Default implementation always returns true.
     */_shouldRender(){return!0}/**
     * Override which performs element rendering by calling
     * `_render`, `_applyRender`, and finally `_didRender`.
     * @param props Current element properties
     * @param changedProps Changing element properties
     * @param prevProps Previous element properties
     */_propertiesChanged(e,t,n){super._propertiesChanged(e,t,n);const a=this._render(e);a&&this._root!==void 0&&this._applyRender(a,this._root),this._didRender(e,t,n),this.__resolveRenderComplete&&this.__resolveRenderComplete(!0)}_flushProperties(){this.__isChanging=!0,this.__isInvalid=!1,super._flushProperties(),this.__isChanging=!1}/**
     * Override which warns when a user attempts to change a property during
     * the rendering lifecycle. This is an anti-pattern and should be avoided.
     * @param property {string}
     * @param value {any}
     * @param old {any}
     */ // tslint:disable-next-line no-any
_shouldPropertyChange(e,t,n){const a=super._shouldPropertyChange(e,t,n);return a&&this.__isChanging&&console.trace(`Setting properties in response to other properties changing `+`considered harmful. Setting '${e}' from `+`'${this._getProperty(e)}' to '${t}'.`),a}/**
     * Implement to describe the DOM which should be rendered in the element.
     * Ideally, the implementation is a pure function using only props to describe
     * the element template. The implementation must return a `lit-html`
     * TemplateResult. By default this template is rendered into the element's
     * shadowRoot. This can be customized by implementing `_createRoot`. This
     * method must be implemented.
     * @param {*} _props Current element properties
     * @returns {TemplateResult} Must return a lit-html TemplateResult.
     */_render(){throw new Error("_render() not implemented")}/**
     * Renders the given lit-html template `result` into the given `node`.
     * Implement to customize the way rendering is applied. This is should not
     * typically be needed and is provided for advanced use cases.
     * @param result {TemplateResult} `lit-html` template result to render
     * @param node {Element|DocumentFragment} node into which to render
     */_applyRender(e,t){render$1(e,t,this.localName)}/**
     * Called after element DOM has been rendered. Implement to
     * directly control rendered DOM. Typically this is not needed as `lit-html`
     * can be used in the `_render` method to set properties, attributes, and
     * event listeners. However, it is sometimes useful for calling methods on
     * rendered elements, like calling `focus()` on an element to focus it.
     * @param _props Current element properties
     * @param _changedProps Changing element properties
     * @param _prevProps Previous element properties
     */_didRender(){}/**
     * Call to request the element to asynchronously re-render regardless
     * of whether or not any property changes are pending.
     */requestRender(){this._invalidateProperties()}/**
     * Override which provides tracking of invalidated state.
     */_invalidateProperties(){this.__isInvalid=!0,super._invalidateProperties()}/**
     * Returns a promise which resolves after the element next renders.
     * The promise resolves to `true` if the element rendered and `false` if the
     * element did not render.
     * This is useful when users (e.g. tests) need to react to the rendered state
     * of the element after a change is made.
     * This can also be useful in event handlers if it is desireable to wait
     * to send an event until after rendering. If possible implement the
     * `_didRender` method to directly respond to rendering within the
     * rendering lifecycle.
     */get renderComplete(){return this.__renderComplete||(this.__renderComplete=new Promise(e=>{this.__resolveRenderComplete=t=>{this.__resolveRenderComplete=this.__renderComplete=null,e(t)}}),!this.__isInvalid&&this.__resolveRenderComplete&&Promise.resolve().then(()=>this.__resolveRenderComplete(!1))),this.__renderComplete}}/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const{CustomEvent:CustomEvent$1}=window,executePersonsv2Request=async(e,t,n)=>{try{const a=await search(e,n);if(!a)return console.error("results is null or undefined!"),{};const{next:r,prev:d,people:i}=a;return t.dispatchEvent(new CustomEvent$1("byu-lookup-datasource-result",{bubbles:!0,detail:i})),{next:r,prev:d}}catch(e){return console.error(e),t.dispatchEvent(new CustomEvent$1("byu-lookup-datasource-error",{bubbles:!0,detail:e})),{}}},setPendingSearch=e=>{const t=new CustomEvent$1("byu-lookup-datasource-searching",{bubbles:!0});e.dispatchEvent(t)};class ByuPersonsv2Datasource extends LitElement{connectedCallback(){super.connectedCallback(),connect();const e=new CustomEvent$1("byu-lookup-datasource-register",{bubbles:!0});this.dispatchEvent(e)}disconnectedCallback(){super.disconnectedCallback(),disconnect()}static get properties(){return{search:String,next:String,prev:String}}_render({search:e}){e||(e="");const{label:t}=resolveSearchType(e);return html$1`${t}`}async performSearch(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{setPendingSearch(this);const e=(await executePersonsv2Request(this.search,this))||{};if(e){const{next:t,prev:n}=e;this.next=t,this.prev=n}},100)}async nextPage(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{if(this.next){setPendingSearch(this);const e=(await executePersonsv2Request(this.search,this,this.next))||{};if(e){const{next:t,prev:n}=e;this.next=t,this.prev=n}}},100)}async prevPage(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{if(this.prev){setPendingSearch(this);const e=(await executePersonsv2Request(this.search,this,this.prev))||{},{next:t,prev:n}=e;this.next=t,this.prev=n}},100)}}console.log("registering personsv2 datasource"),window.customElements.define("byu-personsv2-datasource",ByuPersonsv2Datasource);
