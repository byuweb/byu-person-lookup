const EVENT_PREFIX="byu-browser-oauth",EVENT_STATE_CHANGE=`${"byu-browser-oauth"}-state-changed`,EVENT_CURRENT_INFO_REQUESTED=`${"byu-browser-oauth"}-current-info-requested`;/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */class AuthenticationObserver{constructor(t,{notifyCurrent:n=!0}={}){this._listener=function(n){t(n.detail)},document.addEventListener(EVENT_STATE_CHANGE,this._listener,!1),n&&dispatch(EVENT_CURRENT_INFO_REQUESTED,{callback:t})}disconnect(){document.removeEventListener(EVENT_STATE_CHANGE,this._listener,!1)}}function dispatch(e,t){let n;"function"==typeof window.CustomEvent?n=new CustomEvent(e,{detail:t}):(n=document.createEvent("CustomEvent"),n.initCustomEvent(e,!0,!1,t)),document.dispatchEvent(n)}var commonjsGlobal="undefined"==typeof window?"undefined"==typeof global?"undefined"==typeof self?{}:self:global:window,FUNC_ERROR_TEXT="Expected a function",HASH_UNDEFINED="__lodash_hash_undefined__",INFINITY=1/0,funcTag="[object Function]",genTag="[object GeneratorFunction]",symbolTag="[object Symbol]",reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,reLeadingDot=/^\./,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reEscapeChar=/\\(\\)?/g,reIsHostCtor=/^\[object .+?Constructor\]$/,freeGlobal="object"==typeof commonjsGlobal&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal,freeSelf="object"==typeof self&&self&&self.Object===Object&&self,root=freeGlobal||freeSelf||Function("return this")();/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ /**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */function getValue(e,t){return null==e?void 0:e[t]}/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */function isHostObject(e){// Many host objects are `Object` objects that can coerce to strings
// despite having improperly defined `toString` methods.
var t=!1;if(null!=e&&"function"!=typeof e.toString)try{t=!!(e+"")}catch(t){}return t}/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype,coreJsData=root["__core-js_shared__"],maskSrcKey=function(){var e=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}(),funcToString=funcProto.toString,hasOwnProperty=objectProto.hasOwnProperty,objectToString=objectProto.toString,reIsNative=RegExp("^"+funcToString.call(hasOwnProperty).replace(reRegExpChar,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Symbol$1=root.Symbol,splice=arrayProto.splice,Map$1=getNative(root,"Map"),nativeCreate=getNative(Object,"create"),symbolProto=Symbol$1?Symbol$1.prototype:void 0,symbolToString=symbolProto?symbolProto.toString:void 0;/** Used to detect overreaching core-js shims. */ /**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function Hash(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{}}/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function hashDelete(e){return this.has(e)&&delete this.__data__[e]}/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function hashGet(e){var t=this.__data__;if(nativeCreate){var n=t[e];return n===HASH_UNDEFINED?void 0:n}return hasOwnProperty.call(t,e)?t[e]:void 0}/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function hashHas(e){var t=this.__data__;return nativeCreate?t[e]!==void 0:hasOwnProperty.call(t,e)}/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */function hashSet(e,t){var n=this.__data__;return n[e]=nativeCreate&&void 0===t?HASH_UNDEFINED:t,this}// Add methods to `Hash`.
Hash.prototype.clear=hashClear,Hash.prototype["delete"]=hashDelete,Hash.prototype.get=hashGet,Hash.prototype.has=hashHas,Hash.prototype.set=hashSet;/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function ListCache(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */function listCacheClear(){this.__data__=[]}/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function listCacheDelete(e){var t=this.__data__,n=assocIndexOf(t,e);if(0>n)return!1;var a=t.length-1;return n==a?t.pop():splice.call(t,n,1),!0}/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function listCacheGet(e){var t=this.__data__,n=assocIndexOf(t,e);return 0>n?void 0:t[n][1]}/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function listCacheHas(e){return-1<assocIndexOf(this.__data__,e)}/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */function listCacheSet(e,t){var n=this.__data__,a=assocIndexOf(n,e);return 0>a?n.push([e,t]):n[a][1]=t,this}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear,ListCache.prototype["delete"]=listCacheDelete,ListCache.prototype.get=listCacheGet,ListCache.prototype.has=listCacheHas,ListCache.prototype.set=listCacheSet;/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */function MapCache(e){var t=-1,n=e?e.length:0;for(this.clear();++t<n;){var a=e[t];this.set(a[0],a[1])}}/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */function mapCacheClear(){this.__data__={hash:new Hash,map:new(Map$1||ListCache),string:new Hash}}/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */function mapCacheDelete(e){return getMapData(this,e)["delete"](e)}/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */function mapCacheGet(e){return getMapData(this,e).get(e)}/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */function mapCacheHas(e){return getMapData(this,e).has(e)}/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */function mapCacheSet(e,t){return getMapData(this,e).set(e,t),this}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear,MapCache.prototype["delete"]=mapCacheDelete,MapCache.prototype.get=mapCacheGet,MapCache.prototype.has=mapCacheHas,MapCache.prototype.set=mapCacheSet;/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */function assocIndexOf(e,t){for(var n=e.length;n--;)if(eq(e[n][0],t))return n;return-1}/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */function baseGet(e,t){t=isKey(t,e)?[t]:castPath(t);for(var n=0,a=t.length;null!=e&&n<a;)e=e[toKey(t[n++])];return n&&n==a?e:void 0}/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */function baseIsNative(e){if(!isObject(e)||isMasked(e))return!1;var t=isFunction(e)||isHostObject(e)?reIsNative:reIsHostCtor;return t.test(toSource(e))}/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */function baseToString(e){// Exit early for strings to avoid a performance hit in some environments.
if("string"==typeof e)return e;if(isSymbol(e))return symbolToString?symbolToString.call(e):"";var t=e+"";return"0"==t&&1/e==-INFINITY?"-0":t}/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */function castPath(e){return isArray(e)?e:stringToPath(e)}/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */function getMapData(e,t){var n=e.__data__;return isKeyable(t)?n["string"==typeof t?"string":"hash"]:n.map}/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */function getNative(e,t){var n=getValue(e,t);return baseIsNative(n)?n:void 0}/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */function isKey(e,t){if(isArray(e))return!1;var n=typeof e;return!!("number"==n||"symbol"==n||"boolean"==n||null==e||isSymbol(e))||reIsPlainProp.test(e)||!reIsDeepProp.test(e)||null!=t&&e in Object(t)}/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */function isKeyable(e){var t=typeof e;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==e:null===e}/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */function isMasked(e){return!!maskSrcKey&&maskSrcKey in e}/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */var stringToPath=memoize(function(e){e=toString(e);var t=[];return reLeadingDot.test(e)&&t.push(""),e.replace(rePropName,function(e,n,a,r){t.push(a?r.replace(reEscapeChar,"$1"):n||e)}),t});/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */function toKey(e){if("string"==typeof e||isSymbol(e))return e;var t=e+"";return"0"==t&&1/e==-INFINITY?"-0":t}/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */function toSource(e){if(null!=e){try{return funcToString.call(e)}catch(t){}try{return e+""}catch(t){}}return""}/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */function memoize(e,t){if("function"!=typeof e||t&&"function"!=typeof t)throw new TypeError(FUNC_ERROR_TEXT);var n=function(){var a=arguments,r=t?t.apply(this,a):a[0],s=n.cache;if(s.has(r))return s.get(r);var d=e.apply(this,a);return n.cache=s.set(r,d),d};return n.cache=new(memoize.Cache||MapCache),n}// Assign cache to `_.memoize`.
memoize.Cache=MapCache;/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */function eq(e,t){return e===t||e!==e&&t!==t}/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */var isArray=Array.isArray;/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */function isFunction(e){// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 8-9 which returns 'object' for typed array and other constructors.
var t=isObject(e)?objectToString.call(e):"";return t==funcTag||t==genTag}/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */function isObject(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */function isObjectLike(e){return!!e&&"object"==typeof e}/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */function isSymbol(e){return"symbol"==typeof e||isObjectLike(e)&&objectToString.call(e)==symbolTag}/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */function toString(e){return null==e?"":baseToString(e)}/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */function get(e,t,n){var a=null==e?void 0:baseGet(e,t);return a===void 0?n:a}var lodash_get=get;/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const pickFirst=(e,t)=>e||t;function parseLinks(e){const t=lodash_get(e,"persons__next.href"),n=lodash_get(e,"persons__prev.href");return{next:t,prev:n}}function parseAddresses(e){return 400<=e.metadata.validation_response.code?null:e.values.reduce((e,t)=>{const n=[lodash_get(t,"address_line_1.value",""),lodash_get(t,"address_line_2.value",""),lodash_get(t,"address_line_3.value",""),lodash_get(t,"address_line_4.value","")].filter(e=>0<e.trim().length),a={MAL:"mailing",RES:"residential",WRK:"work",PRM:"permanent"}[t.address_type.value]||t.address_type.value;return Object.assign({},e,{[a]:n})},{})}function parseBasic(e){const t=e=>{const t=lodash_get(e,"preferred_surname.value",""),n=lodash_get(e,"preferred_first_name.value","");return`${t}, ${n}`},n=lodash_get(e,"name_lnf.value",t(e))||t(e),a=lodash_get(e,"byu_id.value",""),r=lodash_get(e,"net_id.value",""),s=lodash_get(e,"person_id.value","");return{name:n,byuId:a,netId:r,personId:s}}function parseEmailAddresses(e){return 400<=e.metadata.validation_response.code?null:e.values.map(t=>lodash_get(t,"email_address.value","")).filter(t=>!!t).reduce(pickFirst,"")}function parsePhones(e){return 400<=e.metadata.validation_response.code?null:e.values.map(e=>lodash_get(e,"phone_number.value","")).filter(e=>!!e).reduce(pickFirst,"")}function parseEmployeeSummaries(e){return 400<=e.metadata.validation_response.code?null:{employeeType:lodash_get(e,"employee_type.value"),department:lodash_get(e,"department.value"),jobTitle:lodash_get(e,"job_title.description")}}function parseStudentSummaries(e){if(400<=e.metadata.validation_response.code)return null;const t=lodash_get(e,"student_status.value");return{studentStatus:t}}function parsePerson(e){return Object.assign({addresses:parseAddresses(e.addresses),email:parseEmailAddresses(e.email_addresses),phone:parsePhones(e.phones)},parseBasic(e.basic),parseEmployeeSummaries(e.employee_summaries),parseStudentSummaries(e.student_summaries))}function parsePersonV2(e){const t=e.values.map(parsePerson),{next:n,prev:a}=parseLinks(e.links);return{next:n,prev:a,people:t}}/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let authHeader=null,observer=null;function connect(){observer||(observer=new AuthenticationObserver(({state:e,token:t,user:n,error:a})=>{// React to change
authHeader=t?t.authorizationHeader:null}))}function nameParams(e){let t="",n="";if(/,/.test(e))// Assume 'Last, First'
[t,n]=e.split(",").map(e=>e.trim());else{// Assume 'First Middle Last'
const a=e.split(" ");t=a.slice(-1),n=a.slice(0,-1).join(" ")}return`?surname=${t}&rest_of_name=${n}`}function resolveSearchType(e){return 1>e.length?{q:`?surname=${e}`,label:"Search"}:/^\d{3,9}$/.test(e)?{q:`?byu_id=${e}`,label:"BYU ID"}:/^[a-z][a-z0-9]{2,7}$/.test(e)?{q:`?net_id=${e}`,label:"Net ID"}:/^[^@]+@.+$/.test(e)?{q:`?email_address=${e}`,label:"Email"}:/^[^ ]+ +[^ ]+[^0-9]*$/.test(e)?{q:`${nameParams(e)}`,label:"Name"}:{q:`?surname=${e}`,label:"Name"}}async function search(e,t){if(!authHeader)throw new Error("Not authenticated!");const{q:n}=resolveSearchType(e),a={method:"GET",headers:new window.Headers({Authorization:authHeader})},r=await window.fetch(t||`${"https://api.byu.edu:443/byuapi/persons/v2/"}${n}&field_sets=${"basic,addresses,email_addresses,phones,employee_summaries,student_summaries"}&page_size=50`,a);if(r.ok){const e=await r.json();return parsePersonV2(e)}if(404===r.status)return{};const s=`Error ${r.status} while querying personsv2`;throw new Error(s)}// in disconnectedCallback():
function disconnect(){observer&&observer.disconnect(),observer=null}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const directives=new WeakMap,isDirective=e=>"function"==typeof e&&directives.has(e),isCEPolyfill=window.customElements!==void 0&&window.customElements.polyfillWrapFlushCallback!==void 0,removeNodes=(e,t,n=null)=>{for(let a=t;a!==n;){const t=a.nextSibling;e.removeChild(a),a=t}},noChange={},nothing={},marker=`{{lit-${(Math.random()+"").slice(2)}}}`,nodeMarker=`<!--${marker}-->`,markerRegex=new RegExp(`${marker}|${nodeMarker}`),boundAttributeSuffix="$lit$";/**
 * An updateable Template that tracks the location of dynamic parts.
 */class Template{constructor(e,t){this.parts=[],this.element=t;let n=-1,a=0;const r=[],s=t=>{const d=t.content,i=document.createTreeWalker(d,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
for(// Keeps track of the last index associated with a part. We try to delete
// unnecessary nodes, but we never want to associate two different parts
// to the same index. They must have a constant node between.
let d=0;i.nextNode();){n++;const t=i.currentNode;if(1===t.nodeType/* Node.ELEMENT_NODE */){if(t.hasAttributes()){const r=t.attributes;// Per
// https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order.
// In particular, Edge/IE can return them out of order, so we cannot
// assume a correspondance between part index and attribute index.
let s=0;for(let e=0;e<r.length;e++)0<=r[e].value.indexOf(marker)&&s++;for(;0<s--;){// Get the template literal section leading up to the first
// expression in this attribute
const r=e.strings[a],s=lastAttributeNameRegex.exec(r)[2],d=s.toLowerCase()+boundAttributeSuffix,i=t.getAttribute(d),o=i.split(markerRegex);// Find the attribute name
this.parts.push({type:"attribute",index:n,name:s,strings:o}),t.removeAttribute(d),a+=o.length-1}}"TEMPLATE"===t.tagName&&s(t)}else if(3===t.nodeType/* Node.TEXT_NODE */){const e=t.data;if(0<=e.indexOf(marker)){const s=t.parentNode,d=e.split(markerRegex),o=d.length-1;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let e=0;e<o;e++)s.insertBefore(""===d[e]?createMarker():document.createTextNode(d[e]),t),this.parts.push({type:"node",index:++n});// If there's no text, we must insert a comment to mark our place.
// Else, we can trust it will stick around after cloning.
// We have a part for each match found
""===d[o]?(s.insertBefore(createMarker(),t),r.push(t)):t.data=d[o],a+=o}}else if(8===t.nodeType/* Node.COMMENT_NODE */)if(t.data===marker){const e=t.parentNode;// Add a new marker node to be the startNode of the Part if any of
// the following are true:
//  * We don't have a previousSibling
//  * The previousSibling is already the start of a previous part
(null===t.previousSibling||n===d)&&(n++,e.insertBefore(createMarker(),t)),d=n,this.parts.push({type:"node",index:n}),null===t.nextSibling?t.data="":(r.push(t),n--),a++}else for(let e=-1;-1!==(e=t.data.indexOf(marker,e+1));)// Comment node has a binding marker inside, make an inactive part
// The binding won't work, but subsequent bindings will
// TODO (justinfagnani): consider whether it's even worth it to
// make bindings in comments work
this.parts.push({type:"node",index:-1})}};s(t);// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const a of r)a.parentNode.removeChild(a)}}const isTemplatePartActive=e=>-1!==e.index,createMarker=()=>document.createComment(""),lastAttributeNameRegex=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */class TemplateInstance{constructor(e,t,n){this._parts=[],this.template=e,this.processor=t,this.options=n}update(e){let t=0;for(const n of this._parts)void 0!==n&&n.setValue(e[t]),t++;for(const t of this._parts)void 0!==t&&t.commit()}_clone(){// When using the Custom Elements polyfill, clone the node, rather than
// importing it, to keep the fragment in the template's document. This
// leaves the fragment inert so custom elements won't upgrade and
// potentially modify their contents by creating a polyfilled ShadowRoot
// while we traverse the tree.
const e=isCEPolyfill?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=this.template.parts;let n=0,a=0;const r=e=>{// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const s=document.createTreeWalker(e,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Loop through all the nodes and parts of a template
for(let d=s.nextNode();n<t.length&&null!==d;){const e=t[n];// Consecutive Parts may have the same node index, in the case of
// multiple bound attributes on an element. So each iteration we either
// increment the nodeIndex, if we aren't on a node with a part, or the
// partIndex if we are. By not incrementing the nodeIndex when we find a
// part, we allow for the next part to be associated with the current
// node if neccessasry.
if(!isTemplatePartActive(e))this._parts.push(void 0),n++;else if(a===e.index){if("node"===e.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(d.previousSibling),this._parts.push(e)}else this._parts.push(...this.processor.handleAttributeExpressions(d,e.name,e.strings,this.options));n++}else a++,"TEMPLATE"===d.nodeName&&r(d.content),d=s.nextNode()}};return r(e),isCEPolyfill&&(document.adoptNode(e),customElements.upgrade(e)),e}}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */class TemplateResult{constructor(e,t,n,a){this.strings=e,this.values=t,this.type=n,this.processor=a}/**
     * Returns a string of HTML used to create a `<template>` element.
     */getHTML(){const e=this.strings.length-1;let t="";for(let n=0;n<e;n++){const e=this.strings[n],a=lastAttributeNameRegex.exec(e);// This exec() call does two things:
// 1) Appends a suffix to the bound attribute name to opt out of special
// attribute value parsing that IE11 and Edge do, like for style and
// many SVG attributes. The Template class also appends the same suffix
// when looking up attributes to create Parts.
// 2) Adds an unquoted-attribute-safe marker for the first expression in
// an attribute. Subsequent attribute expressions will use node markers,
// and this is safe since attributes with multiple expressions are
// guaranteed to be quoted.
t+=a?e.substr(0,a.index)+a[1]+a[2]+boundAttributeSuffix+a[3]+marker:e+nodeMarker}return t+this.strings[e]}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const isPrimitive=e=>null===e||"object"!=typeof e&&"function"!=typeof e;/**
 * Sets attribute values for AttributeParts, so that the value is only set once
 * even if there are multiple parts for an attribute.
 */class AttributeCommitter{constructor(e,t,n){this.dirty=!0,this.element=e,this.name=t,this.strings=n,this.parts=[];for(let a=0;a<n.length-1;a++)this.parts[a]=this._createPart()}/**
     * Creates a single part. Override this to create a differnt type of part.
     */_createPart(){return new AttributePart(this)}_getValue(){const e=this.strings,t=e.length-1;let n="";for(let a=0;a<t;a++){n+=e[a];const t=this.parts[a];if(void 0!==t){const e=t.value;if(null!=e&&(Array.isArray(e)||// tslint:disable-next-line:no-any
"string"!=typeof e&&e[Symbol.iterator]))for(const a of e)n+="string"==typeof a?a:a+"";else n+="string"==typeof e?e:e+""}}return n+=e[t],n}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class AttributePart{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===noChange||isPrimitive(e)&&e===this.value||(this.value=e,!isDirective(e)&&(this.committer.dirty=!0))}commit(){for(;isDirective(this.value);){const e=this.value;this.value=noChange,e(this)}this.value===noChange||this.committer.commit()}}class NodePart{constructor(e){this.value=void 0,this._pendingValue=void 0,this.options=e}/**
     * Inserts this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */appendInto(e){this.startNode=e.appendChild(createMarker()),this.endNode=e.appendChild(createMarker())}/**
     * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
     * its next sibling must be static, unchanging nodes such as those that appear
     * in a literal section of a template.
     *
     * This part must be empty, as its contents are not automatically moved.
     */insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}/**
     * Appends this part into a parent part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */appendIntoPart(e){e._insert(this.startNode=createMarker()),e._insert(this.endNode=createMarker())}/**
     * Appends this part after `ref`
     *
     * This part must be empty, as its contents are not automatically moved.
     */insertAfterPart(e){e._insert(this.startNode=createMarker()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}const e=this._pendingValue;e===noChange||(isPrimitive(e)?e!==this.value&&this._commitText(e):e instanceof TemplateResult?this._commitTemplateResult(e):e instanceof Node?this._commitNode(e):Array.isArray(e)||// tslint:disable-next-line:no-any
e[Symbol.iterator]?this._commitIterable(e):e===nothing?(this.value=nothing,this.clear()):this._commitText(e))}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_commitNode(e){this.value===e||(this.clear(),this._insert(e),this.value=e)}_commitText(e){const t=this.startNode.nextSibling;e=null==e?"":e,t===this.endNode.previousSibling&&3===t.nodeType/* Node.TEXT_NODE */?t.data=e:this._commitNode(document.createTextNode("string"==typeof e?e:e+"")),this.value=e}_commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value instanceof TemplateInstance&&this.value.template===t)this.value.update(e.values);else{// Make sure we propagate the template processor from the TemplateResult
// so that we use its syntax extension, etc. The template factory comes
// from the render function options so that it can control template
// caching and preprocessing.
const n=new TemplateInstance(t,e.processor,this.options),a=n._clone();n.update(e.values),this._commitNode(a),this.value=n}}_commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const t=this.value;let n,a=0;for(const r of e)// Try to reuse an existing part
n=t[a],void 0===n&&(n=new NodePart(this.options),t.push(n),0==a?n.appendIntoPart(this):n.insertAfterPart(t[a-1])),n.setValue(r),n.commit(),a++;a<t.length&&(t.length=a,this.clear(n&&n.endNode))}clear(e=this.startNode){removeNodes(this.startNode.parentNode,e.nextSibling,this.endNode)}}/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */class BooleanAttributePart{constructor(e,t,n){if(this.value=void 0,this._pendingValue=void 0,2!==n.length||""!==n[0]||""!==n[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=n}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}if(this._pendingValue!==noChange){const e=!!this._pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=e,this._pendingValue=noChange}}}/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */class PropertyCommitter extends AttributeCommitter{constructor(e,t,n){super(e,t,n),this.single=2===n.length&&""===n[0]&&""===n[1]}_createPart(){return new PropertyPart(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class PropertyPart extends AttributePart{}// Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.
let eventOptionsSupported=!1;try{const e={get capture(){return eventOptionsSupported=!0,!1}};// tslint:disable-next-line:no-any
// tslint:disable-next-line:no-any
window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}class EventPart{constructor(e,t,n){this.value=void 0,this._pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=n,this._boundHandleEvent=t=>this.handleEvent(t)}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}if(this._pendingValue===noChange)return;const e=this._pendingValue,t=this.value,n=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive);n&&this.element.removeEventListener(this.eventName,this._boundHandleEvent,this._options),null!=e&&(null==t||n)&&(this._options=getOptions(e),this.element.addEventListener(this.eventName,this._boundHandleEvent,this._options)),this.value=e,this._pendingValue=noChange}handleEvent(e){"function"==typeof this.value?this.value.call(this.eventContext||this.element,e):this.value.handleEvent(e)}}// We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.
const getOptions=e=>e&&(eventOptionsSupported?{capture:e.capture,passive:e.passive,once:e.once}:e.capture);/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * Creates Parts when a template is instantiated.
 */class DefaultTemplateProcessor{/**
     * Create parts for an attribute-position binding, given the event, attribute
     * name, and string literals.
     *
     * @param element The element containing the binding
     * @param name  The attribute name
     * @param strings The string literals. There are always at least two strings,
     *   event for fully-controlled bindings with a single expression.
     */handleAttributeExpressions(e,t,n,a){const r=t[0];if("."===r){const a=new PropertyCommitter(e,t.slice(1),n);return a.parts}if("@"===r)return[new EventPart(e,t.slice(1),a.eventContext)];if("?"===r)return[new BooleanAttributePart(e,t.slice(1),n)];const s=new AttributeCommitter(e,t,n);return s.parts}/**
     * Create parts for a text-position binding.
     * @param templateFactory
     */handleTextExpression(e){return new NodePart(e)}}const defaultTemplateProcessor=new DefaultTemplateProcessor;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */function templateFactory(e){let t=templateCaches.get(e.type);void 0===t&&(t={stringsArray:new WeakMap,keyString:new Map},templateCaches.set(e.type,t));let n=t.stringsArray.get(e.strings);if(void 0!==n)return n;// If the TemplateStringsArray is new, generate a key from the strings
// This key is shared between all templates with identical content
const a=e.strings.join(marker);// Check if we already have a Template for this key
return n=t.keyString.get(a),void 0===n&&(n=new Template(e,e.getTemplateElement()),t.keyString.set(a,n)),t.stringsArray.set(e.strings,n),n}const templateCaches=new Map,parts=new WeakMap,render=(e,t,n)=>{let a=parts.get(t);a===void 0&&(removeNodes(t,t.firstChild),parts.set(t,a=new NodePart(Object.assign({templateFactory},n))),a.appendInto(t)),a.setValue(e),a.commit()};/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.0.0");/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */const html=(e,...t)=>new TemplateResult(e,t,"html",defaultTemplateProcessor),walkerNodeFilter=133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1,
 * removed 4 nodes)
 */function removeNodesFromTemplate(e,t){const{element:{content:a},parts:n}=e,r=document.createTreeWalker(a,walkerNodeFilter,null,!1);let s=nextActiveIndexInTemplateParts(n),d=n[s],i=-1,o=0;const l=[];for(let a=null;r.nextNode();){i++;const e=r.currentNode;// End removal if stepped past the removing node
for(e.previousSibling===a&&(a=null),t.has(e)&&(l.push(e),null===a&&(a=e)),null!==a&&o++;d!==void 0&&d.index===i;)// If part is in a removed node deactivate it by setting index to -1 or
// adjust the index as needed.
// go to the next active part.
d.index=null===a?d.index-o:-1,s=nextActiveIndexInTemplateParts(n,s),d=n[s]}l.forEach(e=>e.parentNode.removeChild(e))}const countNodes=e=>{let t=11===e.nodeType/* Node.DOCUMENT_FRAGMENT_NODE */?0:1;for(const n=document.createTreeWalker(e,walkerNodeFilter,null,!1);n.nextNode();)t++;return t},nextActiveIndexInTemplateParts=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(isTemplatePartActive(t))return n}return-1};/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */function insertNodeIntoTemplate(e,t,n=null){const{element:{content:r},parts:a}=e;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===n||void 0===n)return void r.appendChild(t);const s=document.createTreeWalker(r,walkerNodeFilter,null,!1);let d=nextActiveIndexInTemplateParts(a),i=0,o=-1;for(;s.nextNode();){o++;const e=s.currentNode;for(e===n&&(i=countNodes(t),n.parentNode.insertBefore(t,n));-1!==d&&a[d].index===o;){// If we've inserted the node, simply adjust all subsequent parts
if(0<i){for(;-1!==d;)a[d].index+=i,d=nextActiveIndexInTemplateParts(a,d);return}d=nextActiveIndexInTemplateParts(a,d)}}}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ // Get a key to lookup in `templateCaches`.
const getTemplateCacheKey=(e,t)=>`${e}--${t}`;let compatibleShadyCSSVersion=!0;"undefined"==typeof window.ShadyCSS?compatibleShadyCSSVersion=!1:"undefined"==typeof window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."),compatibleShadyCSSVersion=!1);/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */const shadyTemplateFactory=e=>t=>{const n=getTemplateCacheKey(t.type,e);let a=templateCaches.get(n);void 0===a&&(a={stringsArray:new WeakMap,keyString:new Map},templateCaches.set(n,a));let r=a.stringsArray.get(t.strings);if(void 0!==r)return r;const s=t.strings.join(marker);if(r=a.keyString.get(s),void 0===r){const n=t.getTemplateElement();compatibleShadyCSSVersion&&window.ShadyCSS.prepareTemplateDom(n,e),r=new Template(t,n),a.keyString.set(s,r)}return a.stringsArray.set(t.strings,r),r},TEMPLATE_TYPES=["html","svg"],removeStylesFromLitTemplates=e=>{TEMPLATE_TYPES.forEach(t=>{const n=templateCaches.get(getTemplateCacheKey(t,e));n!==void 0&&n.keyString.forEach(e=>{const{element:{content:t}}=e,n=new Set;// IE 11 doesn't support the iterable param Set constructor
Array.from(t.querySelectorAll("style")).forEach(e=>{n.add(e)}),removeNodesFromTemplate(e,n)})})},shadyRenderSet=new Set,prepareTemplateStyles=(e,t,n)=>{shadyRenderSet.add(n);// Move styles out of rendered DOM and store.
const a=e.querySelectorAll("style");// If there are no styles, skip unnecessary work
if(0===a.length)return void window.ShadyCSS.prepareTemplateStyles(t.element,n);const r=document.createElement("style");// Collect styles into a single style. This helps us make sure ShadyCSS
// manipulations will not prevent us from being able to fix up template
// part indices.
// NOTE: collecting styles is inefficient for browsers but ShadyCSS
// currently does this anyway. When it does not, this should be changed.
for(let s=0;s<a.length;s++){const e=a[s];e.parentNode.removeChild(e),r.textContent+=e.textContent}// Remove styles from nested templates in this scope.
if(removeStylesFromLitTemplates(n),insertNodeIntoTemplate(t,r,t.element.content.firstChild),window.ShadyCSS.prepareTemplateStyles(t.element,n),window.ShadyCSS.nativeShadow){// When in native Shadow DOM, re-add styling to rendered content using
// the style ShadyCSS produced.
const n=t.element.content.querySelector("style");e.insertBefore(n.cloneNode(!0),e.firstChild)}else{t.element.content.insertBefore(r,t.element.content.firstChild);const e=new Set;e.add(r),removeNodesFromTemplate(t,e)}},render$1=(e,t,n)=>{const a=n.scopeName,r=parts.has(t),s=t instanceof ShadowRoot&&compatibleShadyCSSVersion&&e instanceof TemplateResult,d=s&&!shadyRenderSet.has(a),i=d?document.createDocumentFragment():t;// When performing first scope render,
// (1) We've rendered into a fragment so that there's a chance to
// `prepareTemplateStyles` before sub-elements hit the DOM
// (which might cause them to render based on a common pattern of
// rendering in a custom element's `connectedCallback`);
// (2) Scope the template with ShadyCSS one time only for this scope.
// (3) Render the fragment into the container and make sure the
// container knows its `part` is the one we just rendered. This ensures
// DOM will be re-used on subsequent renders.
if(render(e,i,Object.assign({templateFactory:shadyTemplateFactory(a)},n)),d){const e=parts.get(i);parts.delete(i),e.value instanceof TemplateInstance&&prepareTemplateStyles(i,e.value.template,a),removeNodes(t,t.firstChild),t.appendChild(i),parts.set(t,e)}// After elements have hit the DOM, update styling if this is the
// initial render to this container.
// This is needed whenever dynamic changes are made so it would be
// safest to do every render; however, this would regress performance
// so we leave it up to the user to call `ShadyCSSS.styleElement`
// for dynamic changes.
!r&&s&&window.ShadyCSS.styleElement(t.host)},JSCompiler_renameProperty=e=>e,descriptorFromPrototype=(e,t)=>{if(e in t)for(;t!==Object.prototype;){if(t.hasOwnProperty(e))return Object.getOwnPropertyDescriptor(t,e);t=Object.getPrototypeOf(t)}},defaultConverter={toAttribute(e,t){return t===Boolean?e?"":null:t===Object||t===Array?null==e?e:JSON.stringify(e):e},fromAttribute(e,t){return t===Boolean?null!==e:t===Number?null===e?null:+e:t===Object||t===Array?JSON.parse(e):e}},notEqual=(e,t)=>t!==e&&(t===t||e===e),defaultPropertyDeclaration={attribute:!0,type:String,converter:defaultConverter,reflect:!1,hasChanged:notEqual},microtaskPromise=Promise.resolve(!0),STATE_HAS_UPDATED=1,STATE_UPDATE_REQUESTED=4,STATE_IS_REFLECTING_TO_ATTRIBUTE=8,STATE_IS_REFLECTING_TO_PROPERTY=16,STATE_HAS_CONNECTED=32;/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 */class UpdatingElement extends HTMLElement{constructor(){/**
         * Map with keys for any properties that have changed since the last
         * update cycle with previous values.
         */ /**
         * Map with keys of properties that should be reflected when updated.
         */super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=microtaskPromise,this._hasConnectedResolver=void 0,this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}/**
     * Returns a list of attributes corresponding to the registered properties.
     * @nocollapse
     */static get observedAttributes(){this._finalize();const e=[];for(const[t,n]of this._classProperties){const a=this._attributeNameForProperty(t,n);a!==void 0&&(this._attributeToPropertyMap.set(a,t),e.push(a))}return e}/**
     * Ensures the private `_classProperties` property metadata is created.
     * In addition to `_finalize` this is also called in `createProperty` to
     * ensure the `@property` decorator can add property metadata.
     */ /** @nocollapse */static _ensureClassProperties(){// ensure private storage for property declarations.
if(!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties",this))){this._classProperties=new Map;// NOTE: Workaround IE11 not supporting Map constructor argument.
const e=Object.getPrototypeOf(this)._classProperties;e!==void 0&&e.forEach((e,t)=>this._classProperties.set(t,e))}}/**
     * Creates a property accessor on the element prototype if one does not exist.
     * The property setter calls the property's `hasChanged` property option
     * or uses a strict identity check to determine whether or not to request
     * an update.
     * @nocollapse
     */static createProperty(e,t=defaultPropertyDeclaration){if(this._ensureClassProperties(),this._classProperties.set(e,t),!t.noAccessor){const t=descriptorFromPrototype(e,this.prototype);let n;// If there is a super accessor, capture it and "super" to it
if(void 0!==t&&t.set&&t.get){const{set:a,get:r}=t;n={get(){return r.call(this)},set(t){const n=this[e];a.call(this,t),this.requestUpdate(e,n)},configurable:!0,enumerable:!0}}else{const t="symbol"==typeof e?Symbol():`__${e}`;n={get(){return this[t]},set(n){const a=this[e];this[t]=n,this.requestUpdate(e,a)},configurable:!0,enumerable:!0}}Object.defineProperty(this.prototype,e,n)}}/**
     * Creates property accessors for registered properties and ensures
     * any superclasses are also finalized.
     * @nocollapse
     */static _finalize(){if(!(this.hasOwnProperty(JSCompiler_renameProperty("finalized",this))&&this.finalized)){// finalize any superclasses
const e=Object.getPrototypeOf(this);// make any properties
// Note, only process "own" properties since this element will inherit
// any properties defined on the superClass, and finalization ensures
// the entire prototype chain is finalized.
if("function"==typeof e._finalize&&e._finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(JSCompiler_renameProperty("properties",this))){const e=this.properties,t=[...Object.getOwnPropertyNames(e),...("function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[])];// support symbols in properties (IE11 does not support this)
for(const n of t)// note, use of `any` is due to TypeSript lack of support for symbol in
// index types
this.createProperty(n,e[n])}}}/**
     * Returns the property name for the given attribute `name`.
     * @nocollapse
     */static _attributeNameForProperty(e,t){const n=t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}/**
     * Returns true if a property should request an update.
     * Called when a property value is set and uses the `hasChanged`
     * option for the property if present or a strict identity check.
     * @nocollapse
     */static _valueHasChanged(e,t,n=notEqual){return n(e,t)}/**
     * Returns the property value for the given attribute value.
     * Called via the `attributeChangedCallback` and uses the property's
     * `converter` or `converter.fromAttribute` property option.
     * @nocollapse
     */static _propertyValueFromAttribute(e,t){const n=t.type,a=t.converter||defaultConverter,r="function"==typeof a?a:a.fromAttribute;return r?r(e,n):e}/**
     * Returns the attribute value for the given property value. If this
     * returns undefined, the property will *not* be reflected to an attribute.
     * If this returns null, the attribute will be removed, otherwise the
     * attribute will be set to the value.
     * This uses the property's `reflect` and `type.toAttribute` property options.
     * @nocollapse
     */static _propertyValueToAttribute(e,t){if(void 0===t.reflect)return;const n=t.type,a=t.converter,r=a&&a.toAttribute||defaultConverter.toAttribute;return r(e,n)}/**
     * Performs element initialization. By default captures any pre-set values for
     * registered properties.
     */initialize(){this._saveInstanceProperties()}/**
     * Fixes any properties set on the instance before upgrade time.
     * Otherwise these would shadow the accessor and break these properties.
     * The properties are stored in a Map which is played back after the
     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
     * (<=41), properties created for native platform properties like (`id` or
     * `name`) may not have default values set in the element constructor. On
     * these browsers native properties appear on instances and therefore their
     * default value will overwrite any element default (e.g. if the element sets
     * this.id = 'id' in the constructor, the 'id' will become '' since this is
     * the native platform default).
     */_saveInstanceProperties(){for(const[e]of this.constructor._classProperties)if(this.hasOwnProperty(e)){const t=this[e];delete this[e],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(e,t)}}/**
     * Applies previously saved instance properties.
     */_applyInstanceProperties(){for(const[e,t]of this._instanceProperties)this[e]=t;this._instanceProperties=void 0}connectedCallback(){this._updateState|=STATE_HAS_CONNECTED,this._hasConnectedResolver?(this._hasConnectedResolver(),this._hasConnectedResolver=void 0):this.requestUpdate()}/**
     * Allows for `super.disconnectedCallback()` in extensions while
     * reserving the possibility of making non-breaking feature additions
     * when disconnecting at some point in the future.
     */disconnectedCallback(){}/**
     * Synchronizes property values when attributes change.
     */attributeChangedCallback(e,t,n){t!==n&&this._attributeToProperty(e,n)}_propertyToAttribute(e,t,n=defaultPropertyDeclaration){const a=this.constructor,r=a._attributeNameForProperty(e,n);if(r!==void 0){const e=a._propertyValueToAttribute(t,n);// an undefined value does not change the attribute.
if(e===void 0)return;// Track if the property is being reflected to avoid
// setting the property again via `attributeChangedCallback`. Note:
// 1. this takes advantage of the fact that the callback is synchronous.
// 2. will behave incorrectly if multiple attributes are in the reaction
// stack at time of calling. However, since we process attributes
// in `update` this should not be possible (or an extreme corner case
// that we'd like to discover).
// mark state reflecting
// mark state not reflecting
this._updateState|=STATE_IS_REFLECTING_TO_ATTRIBUTE,null==e?this.removeAttribute(r):this.setAttribute(r,e),this._updateState&=~STATE_IS_REFLECTING_TO_ATTRIBUTE}}_attributeToProperty(e,t){// Use tracking info to avoid deserializing attribute value if it was
// just set from a property setter.
if(this._updateState&STATE_IS_REFLECTING_TO_ATTRIBUTE)return;const n=this.constructor,a=n._attributeToPropertyMap.get(e);if(a!==void 0){const e=n._classProperties.get(a)||defaultPropertyDeclaration;// mark state reflecting
// mark state not reflecting
this._updateState|=STATE_IS_REFLECTING_TO_PROPERTY,this[a]=n._propertyValueFromAttribute(t,e),this._updateState&=~STATE_IS_REFLECTING_TO_PROPERTY}}/**
     * Requests an update which is processed asynchronously. This should
     * be called when an element should update based on some state not triggered
     * by setting a property. In this case, pass no arguments. It should also be
     * called when manually implementing a property setter. In this case, pass the
     * property `name` and `oldValue` to ensure that any configured property
     * options are honored. Returns the `updateComplete` Promise which is resolved
     * when the update completes.
     *
     * @param name {PropertyKey} (optional) name of requesting property
     * @param oldValue {any} (optional) old value of requesting property
     * @returns {Promise} A Promise that is resolved when the update completes.
     */requestUpdate(e,t){let n=!0;// if we have a property key, perform property update steps.
if(void 0!==e&&!this._changedProperties.has(e)){const a=this.constructor,r=a._classProperties.get(e)||defaultPropertyDeclaration;a._valueHasChanged(this[e],t,r.hasChanged)?(this._changedProperties.set(e,t),!0===r.reflect&&!(this._updateState&STATE_IS_REFLECTING_TO_PROPERTY)&&(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,r))):n=!1}return!this._hasRequestedUpdate&&n&&this._enqueueUpdate(),this.updateComplete}/**
     * Sets up the element to asynchronously update.
     */async _enqueueUpdate(){this._updateState|=STATE_UPDATE_REQUESTED;let e;const t=this._updatePromise;this._updatePromise=new Promise(t=>e=t),await t,this._hasConnected||(await new Promise(e=>this._hasConnectedResolver=e));// Allow `performUpdate` to be asynchronous to enable scheduling of updates.
const n=this.performUpdate();// Note, this is to avoid delaying an additional microtask unless we need
// to.
null!=n&&"function"==typeof n.then&&(await n),e(!this._hasRequestedUpdate)}get _hasConnected(){return this._updateState&STATE_HAS_CONNECTED}get _hasRequestedUpdate(){return this._updateState&STATE_UPDATE_REQUESTED}get hasUpdated(){return this._updateState&STATE_HAS_UPDATED}/**
     * Performs an element update.
     *
     * You can override this method to change the timing of updates. For instance,
     * to schedule updates to occur just before the next frame:
     *
     * ```
     * protected async performUpdate(): Promise<unknown> {
     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
     *   super.performUpdate();
     * }
     * ```
     */performUpdate(){if(this._instanceProperties&&this._applyInstanceProperties(),this.shouldUpdate(this._changedProperties)){const e=this._changedProperties;this.update(e),this._markUpdated(),this._updateState&STATE_HAS_UPDATED||(this._updateState|=STATE_HAS_UPDATED,this.firstUpdated(e)),this.updated(e)}else this._markUpdated()}_markUpdated(){this._changedProperties=new Map,this._updateState&=~STATE_UPDATE_REQUESTED}/**
     * Returns a Promise that resolves when the element has completed updating.
     * The Promise value is a boolean that is `true` if the element completed the
     * update without triggering another update. The Promise result is `false` if
     * a property was set inside `updated()`. This getter can be implemented to
     * await additional state. For example, it is sometimes useful to await a
     * rendered element before fulfilling this Promise. To do this, first await
     * `super.updateComplete` then any subsequent state.
     *
     * @returns {Promise} The Promise returns a boolean that indicates if the
     * update resolved without triggering another update.
     */get updateComplete(){return this._updatePromise}/**
     * Controls whether or not `update` should be called when the element requests
     * an update. By default, this method always returns `true`, but this can be
     * customized to control when to update.
     *
     * * @param _changedProperties Map of changed properties with old values
     */shouldUpdate(){return!0}/**
     * Updates the element. This method reflects property values to attributes.
     * It can be overridden to render and keep updated element DOM.
     * Setting properties inside this method will *not* trigger
     * another update.
     *
     * * @param _changedProperties Map of changed properties with old values
     */update(){if(this._reflectingProperties!==void 0&&0<this._reflectingProperties.size){for(const[e,t]of this._reflectingProperties)this._propertyToAttribute(e,this[e],t);this._reflectingProperties=void 0}}/**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param _changedProperties Map of changed properties with old values
     */updated(){}/**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param _changedProperties Map of changed properties with old values
     */firstUpdated(){}}/**
 * Marks class as having finished creating properties.
 */UpdatingElement.finalized=!0;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/const supportsAdoptingStyleSheets="adoptedStyleSheets"in Document.prototype;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class LitElement extends UpdatingElement{/**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */static get styles(){return[]}static get _uniqueStyles(){if(this._styles===void 0){const e=this.styles,t=e.reduceRight((e,t)=>(e.add(t),e),new Set);// As a performance optimization to avoid duplicated styling that can
// occur especially when composing via subclassing, de-duplicate styles
// preserving the last item in the list. The last item is kept to
// try to preserve cascade order with the assumption that it's most
// important that last added styles override previous styles.
// Array.form does not work on Set in IE
this._styles=[],t.forEach(e=>this._styles.unshift(e))}return this._styles}/**
     * Performs element initialization. By default this calls `createRenderRoot`
     * to create the element `renderRoot` node and captures any pre-set values for
     * registered properties.
     */initialize(){super.initialize(),this.renderRoot=this.createRenderRoot(),window.ShadowRoot&&this.renderRoot instanceof window.ShadowRoot&&this.adoptStyles()}/**
     * Returns the node into which the element should render and by default
     * creates and returns an open shadowRoot. Implement to customize where the
     * element's DOM is rendered. For example, to render into the element's
     * childNodes, return `this`.
     * @returns {Element|DocumentFragment} Returns a node into which to render.
     */createRenderRoot(){return this.attachShadow({mode:"open"})}/**
     * Applies styling to the element shadowRoot using the `static get styles`
     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
     * available and will fallback otherwise. When Shadow DOM is polyfilled,
     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
     * is available but `adoptedStyleSheets` is not, styles are appended to the
     * end of the `shadowRoot` to [mimic spec
     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
     */adoptStyles(){const e=this.constructor._uniqueStyles;0===e.length||(window.ShadyCSS===void 0||window.ShadyCSS.nativeShadow?supportsAdoptingStyleSheets?this.renderRoot.adoptedStyleSheets=e.map(e=>e.styleSheet):this._needsShimAdoptedStyleSheets=!0:window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e=>e.cssText),this.localName));// There are three separate cases here based on Shadow DOM support.
// (1) shadowRoot polyfilled: use ShadyCSS
// (2) shadowRoot.adoptedStyleSheets available: use it.
// (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
// rendering
}connectedCallback(){super.connectedCallback(),this.hasUpdated&&window.ShadyCSS!==void 0&&window.ShadyCSS.styleElement(this)}/**
     * Updates the element. This method reflects property values to attributes
     * and calls `render` to render DOM via lit-html. Setting properties inside
     * this method will *not* trigger another update.
     * * @param _changedProperties Map of changed properties with old values
     */update(e){super.update(e);const t=this.render();t instanceof TemplateResult&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this}),this._needsShimAdoptedStyleSheets&&(this._needsShimAdoptedStyleSheets=!1,this.constructor._uniqueStyles.forEach(e=>{const t=document.createElement("style");t.textContent=e.cssText,this.renderRoot.appendChild(t)}))}/**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */render(){}}/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 */LitElement.finalized=!0,LitElement.render=render$1;/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const{CustomEvent:CustomEvent$1}=window,executePersonsv2Request=async(e,t,n)=>{try{const a=await search(e,n);if(!a)return console.error("results is null or undefined!"),{};const{next:r,prev:s,people:d}=a;return t.dispatchEvent(new CustomEvent$1("byu-lookup-datasource-result",{bubbles:!0,detail:d})),{next:r,prev:s}}catch(e){return console.error(e),t.dispatchEvent(new CustomEvent$1("byu-lookup-datasource-error",{bubbles:!0,detail:e})),{}}},setPendingSearch=e=>{const t=new CustomEvent$1("byu-lookup-datasource-searching",{bubbles:!0});e.dispatchEvent(t)};class ByuPersonsv2Datasource extends LitElement{connectedCallback(){super.connectedCallback(),connect();const e=new CustomEvent$1("byu-lookup-datasource-register",{bubbles:!0});this.dispatchEvent(e)}disconnectedCallback(){super.disconnectedCallback(),disconnect()}static get properties(){return{search:{type:String},next:{type:String},prev:{type:String}}}render(){this.search||(this.search="");const{label:e}=resolveSearchType(this.search);return html`${e}`}async performSearch(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{setPendingSearch(this);const e=(await executePersonsv2Request(this.search,this))||{};if(e){const{next:t,prev:n}=e;this.next=t,this.prev=n}},100)}async nextPage(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{if(this.next){setPendingSearch(this);const e=(await executePersonsv2Request(this.search,this,this.next))||{};if(e){const{next:t,prev:n}=e;this.next=t,this.prev=n}}},100)}async prevPage(){this.timeout&&clearTimeout(this.timeout),this.timeout=setTimeout(async()=>{if(this.prev){setPendingSearch(this);const e=(await executePersonsv2Request(this.search,this,this.prev))||{},{next:t,prev:n}=e;this.next=t,this.prev=n}},100)}}console.log("registering personsv2 datasource"),window.customElements.define("byu-personsv2-datasource",ByuPersonsv2Datasource);
