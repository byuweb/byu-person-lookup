/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const directives=new WeakMap,isDirective=e=>"function"==typeof e&&directives.has(e),isCEPolyfill=window.customElements!==void 0&&window.customElements.polyfillWrapFlushCallback!==void 0,reparentNodes=(e,t,n=null,r=null)=>{for(let s=t;s!==n;){const t=s.nextSibling;e.insertBefore(s,r),s=t}},removeNodes=(e,t,n=null)=>{for(let r=t;r!==n;){const t=r.nextSibling;e.removeChild(r),r=t}},noChange={},nothing={},marker=`{{lit-${(Math.random()+"").slice(2)}}}`,nodeMarker=`<!--${marker}-->`,markerRegex=new RegExp(`${marker}|${nodeMarker}`),boundAttributeSuffix="$lit$";/**
 * An updateable Template that tracks the location of dynamic parts.
 */class Template{constructor(e,t){this.parts=[],this.element=t;let n=-1,r=0;const s=[],a=t=>{const d=t.content,i=document.createTreeWalker(d,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
for(// Keeps track of the last index associated with a part. We try to delete
// unnecessary nodes, but we never want to associate two different parts
// to the same index. They must have a constant node between.
let d=0;i.nextNode();){n++;const t=i.currentNode;if(1===t.nodeType/* Node.ELEMENT_NODE */){if(t.hasAttributes()){const s=t.attributes;// Per
// https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order.
// In particular, Edge/IE can return them out of order, so we cannot
// assume a correspondance between part index and attribute index.
let a=0;for(let e=0;e<s.length;e++)0<=s[e].value.indexOf(marker)&&a++;for(;0<a--;){// Get the template literal section leading up to the first
// expression in this attribute
const s=e.strings[r],a=lastAttributeNameRegex.exec(s)[2],d=a.toLowerCase()+boundAttributeSuffix,i=t.getAttribute(d),o=i.split(markerRegex);// Find the attribute name
this.parts.push({type:"attribute",index:n,name:a,strings:o}),t.removeAttribute(d),r+=o.length-1}}"TEMPLATE"===t.tagName&&a(t)}else if(3===t.nodeType/* Node.TEXT_NODE */){const e=t.data;if(0<=e.indexOf(marker)){const a=t.parentNode,d=e.split(markerRegex),o=d.length-1;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let e=0;e<o;e++)a.insertBefore(""===d[e]?createMarker():document.createTextNode(d[e]),t),this.parts.push({type:"node",index:++n});// If there's no text, we must insert a comment to mark our place.
// Else, we can trust it will stick around after cloning.
// We have a part for each match found
""===d[o]?(a.insertBefore(createMarker(),t),s.push(t)):t.data=d[o],r+=o}}else if(8===t.nodeType/* Node.COMMENT_NODE */)if(t.data===marker){const e=t.parentNode;// Add a new marker node to be the startNode of the Part if any of
// the following are true:
//  * We don't have a previousSibling
//  * The previousSibling is already the start of a previous part
(null===t.previousSibling||n===d)&&(n++,e.insertBefore(createMarker(),t)),d=n,this.parts.push({type:"node",index:n}),null===t.nextSibling?t.data="":(s.push(t),n--),r++}else for(let e=-1;-1!==(e=t.data.indexOf(marker,e+1));)// Comment node has a binding marker inside, make an inactive part
// The binding won't work, but subsequent bindings will
// TODO (justinfagnani): consider whether it's even worth it to
// make bindings in comments work
this.parts.push({type:"node",index:-1})}};a(t);// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const r of s)r.parentNode.removeChild(r)}}const isTemplatePartActive=e=>-1!==e.index,createMarker=()=>document.createComment(""),lastAttributeNameRegex=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */class TemplateInstance{constructor(e,t,n){this._parts=[],this.template=e,this.processor=t,this.options=n}update(e){let t=0;for(const n of this._parts)void 0!==n&&n.setValue(e[t]),t++;for(const t of this._parts)void 0!==t&&t.commit()}_clone(){// When using the Custom Elements polyfill, clone the node, rather than
// importing it, to keep the fragment in the template's document. This
// leaves the fragment inert so custom elements won't upgrade and
// potentially modify their contents by creating a polyfilled ShadowRoot
// while we traverse the tree.
const e=isCEPolyfill?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=this.template.parts;let n=0,r=0;const s=e=>{// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const a=document.createTreeWalker(e,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Loop through all the nodes and parts of a template
for(let d=a.nextNode();n<t.length&&null!==d;){const e=t[n];// Consecutive Parts may have the same node index, in the case of
// multiple bound attributes on an element. So each iteration we either
// increment the nodeIndex, if we aren't on a node with a part, or the
// partIndex if we are. By not incrementing the nodeIndex when we find a
// part, we allow for the next part to be associated with the current
// node if neccessasry.
if(!isTemplatePartActive(e))this._parts.push(void 0),n++;else if(r===e.index){if("node"===e.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(d.previousSibling),this._parts.push(e)}else this._parts.push(...this.processor.handleAttributeExpressions(d,e.name,e.strings,this.options));n++}else r++,"TEMPLATE"===d.nodeName&&s(d.content),d=a.nextNode()}};return s(e),isCEPolyfill&&(document.adoptNode(e),customElements.upgrade(e)),e}}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */class TemplateResult{constructor(e,t,n,r){this.strings=e,this.values=t,this.type=n,this.processor=r}/**
     * Returns a string of HTML used to create a `<template>` element.
     */getHTML(){const e=this.strings.length-1;let t="";for(let n=0;n<e;n++){const e=this.strings[n],r=lastAttributeNameRegex.exec(e);// This exec() call does two things:
// 1) Appends a suffix to the bound attribute name to opt out of special
// attribute value parsing that IE11 and Edge do, like for style and
// many SVG attributes. The Template class also appends the same suffix
// when looking up attributes to create Parts.
// 2) Adds an unquoted-attribute-safe marker for the first expression in
// an attribute. Subsequent attribute expressions will use node markers,
// and this is safe since attributes with multiple expressions are
// guaranteed to be quoted.
t+=r?e.substr(0,r.index)+r[1]+r[2]+boundAttributeSuffix+r[3]+marker:e+nodeMarker}return t+this.strings[e]}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}/**
 * A TemplateResult for SVG fragments.
 *
 * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the
 * SVG namespace, then modifies the template to remove the `<svg>` tag so that
 * clones only container the original fragment.
 */class SVGTemplateResult extends TemplateResult{getHTML(){return`<svg>${super.getHTML()}</svg>`}getTemplateElement(){const e=super.getTemplateElement(),t=e.content,n=t.firstChild;return t.removeChild(n),reparentNodes(t,n.firstChild),e}}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const isPrimitive=e=>null===e||"object"!=typeof e&&"function"!=typeof e;/**
 * Sets attribute values for AttributeParts, so that the value is only set once
 * even if there are multiple parts for an attribute.
 */class AttributeCommitter{constructor(e,t,n){this.dirty=!0,this.element=e,this.name=t,this.strings=n,this.parts=[];for(let r=0;r<n.length-1;r++)this.parts[r]=this._createPart()}/**
     * Creates a single part. Override this to create a differnt type of part.
     */_createPart(){return new AttributePart(this)}_getValue(){const e=this.strings,t=e.length-1;let n="";for(let r=0;r<t;r++){n+=e[r];const t=this.parts[r];if(void 0!==t){const e=t.value;if(null!=e&&(Array.isArray(e)||// tslint:disable-next-line:no-any
"string"!=typeof e&&e[Symbol.iterator]))for(const r of e)n+="string"==typeof r?r:r+"";else n+="string"==typeof e?e:e+""}}return n+=e[t],n}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class AttributePart{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===noChange||isPrimitive(e)&&e===this.value||(this.value=e,!isDirective(e)&&(this.committer.dirty=!0))}commit(){for(;isDirective(this.value);){const e=this.value;this.value=noChange,e(this)}this.value===noChange||this.committer.commit()}}class NodePart{constructor(e){this.value=void 0,this._pendingValue=void 0,this.options=e}/**
     * Inserts this part into a container.
     *
     * This part must be empty, as its contents are not automatically moved.
     */appendInto(e){this.startNode=e.appendChild(createMarker()),this.endNode=e.appendChild(createMarker())}/**
     * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
     * its next sibling must be static, unchanging nodes such as those that appear
     * in a literal section of a template.
     *
     * This part must be empty, as its contents are not automatically moved.
     */insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}/**
     * Appends this part into a parent part.
     *
     * This part must be empty, as its contents are not automatically moved.
     */appendIntoPart(e){e._insert(this.startNode=createMarker()),e._insert(this.endNode=createMarker())}/**
     * Appends this part after `ref`
     *
     * This part must be empty, as its contents are not automatically moved.
     */insertAfterPart(e){e._insert(this.startNode=createMarker()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}const e=this._pendingValue;e===noChange||(isPrimitive(e)?e!==this.value&&this._commitText(e):e instanceof TemplateResult?this._commitTemplateResult(e):e instanceof Node?this._commitNode(e):Array.isArray(e)||// tslint:disable-next-line:no-any
e[Symbol.iterator]?this._commitIterable(e):e===nothing?(this.value=nothing,this.clear()):this._commitText(e))}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_commitNode(e){this.value===e||(this.clear(),this._insert(e),this.value=e)}_commitText(e){const t=this.startNode.nextSibling;e=null==e?"":e,t===this.endNode.previousSibling&&3===t.nodeType/* Node.TEXT_NODE */?t.data=e:this._commitNode(document.createTextNode("string"==typeof e?e:e+"")),this.value=e}_commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value instanceof TemplateInstance&&this.value.template===t)this.value.update(e.values);else{// Make sure we propagate the template processor from the TemplateResult
// so that we use its syntax extension, etc. The template factory comes
// from the render function options so that it can control template
// caching and preprocessing.
const n=new TemplateInstance(t,e.processor,this.options),r=n._clone();n.update(e.values),this._commitNode(r),this.value=n}}_commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const t=this.value;let n,r=0;for(const s of e)// Try to reuse an existing part
n=t[r],void 0===n&&(n=new NodePart(this.options),t.push(n),0==r?n.appendIntoPart(this):n.insertAfterPart(t[r-1])),n.setValue(s),n.commit(),r++;r<t.length&&(t.length=r,this.clear(n&&n.endNode))}clear(e=this.startNode){removeNodes(this.startNode.parentNode,e.nextSibling,this.endNode)}}/**
 * Implements a boolean attribute, roughly as defined in the HTML
 * specification.
 *
 * If the value is truthy, then the attribute is present with a value of
 * ''. If the value is falsey, the attribute is removed.
 */class BooleanAttributePart{constructor(e,t,n){if(this.value=void 0,this._pendingValue=void 0,2!==n.length||""!==n[0]||""!==n[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=n}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}if(this._pendingValue!==noChange){const e=!!this._pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=e,this._pendingValue=noChange}}}/**
 * Sets attribute values for PropertyParts, so that the value is only set once
 * even if there are multiple parts for a property.
 *
 * If an expression controls the whole property value, then the value is simply
 * assigned to the property under control. If there are string literals or
 * multiple expressions, then the strings are expressions are interpolated into
 * a string first.
 */class PropertyCommitter extends AttributeCommitter{constructor(e,t,n){super(e,t,n),this.single=2===n.length&&""===n[0]&&""===n[1]}_createPart(){return new PropertyPart(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class PropertyPart extends AttributePart{}// Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.
let eventOptionsSupported=!1;try{const e={get capture(){return eventOptionsSupported=!0,!1}};// tslint:disable-next-line:no-any
// tslint:disable-next-line:no-any
window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}class EventPart{constructor(e,t,n){this.value=void 0,this._pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=n,this._boundHandleEvent=t=>this.handleEvent(t)}setValue(e){this._pendingValue=e}commit(){for(;isDirective(this._pendingValue);){const e=this._pendingValue;this._pendingValue=noChange,e(this)}if(this._pendingValue===noChange)return;const e=this._pendingValue,t=this.value,n=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive);n&&this.element.removeEventListener(this.eventName,this._boundHandleEvent,this._options),null!=e&&(null==t||n)&&(this._options=getOptions(e),this.element.addEventListener(this.eventName,this._boundHandleEvent,this._options)),this.value=e,this._pendingValue=noChange}handleEvent(e){"function"==typeof this.value?this.value.call(this.eventContext||this.element,e):this.value.handleEvent(e)}}// We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.
const getOptions=e=>e&&(eventOptionsSupported?{capture:e.capture,passive:e.passive,once:e.once}:e.capture);/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * Creates Parts when a template is instantiated.
 */class DefaultTemplateProcessor{/**
     * Create parts for an attribute-position binding, given the event, attribute
     * name, and string literals.
     *
     * @param element The element containing the binding
     * @param name  The attribute name
     * @param strings The string literals. There are always at least two strings,
     *   event for fully-controlled bindings with a single expression.
     */handleAttributeExpressions(e,t,n,r){const s=t[0];if("."===s){const r=new PropertyCommitter(e,t.slice(1),n);return r.parts}if("@"===s)return[new EventPart(e,t.slice(1),r.eventContext)];if("?"===s)return[new BooleanAttributePart(e,t.slice(1),n)];const a=new AttributeCommitter(e,t,n);return a.parts}/**
     * Create parts for a text-position binding.
     * @param templateFactory
     */handleTextExpression(e){return new NodePart(e)}}const defaultTemplateProcessor=new DefaultTemplateProcessor;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
 * The default TemplateFactory which caches Templates keyed on
 * result.type and result.strings.
 */function templateFactory(e){let t=templateCaches.get(e.type);void 0===t&&(t={stringsArray:new WeakMap,keyString:new Map},templateCaches.set(e.type,t));let n=t.stringsArray.get(e.strings);if(void 0!==n)return n;// If the TemplateStringsArray is new, generate a key from the strings
// This key is shared between all templates with identical content
const r=e.strings.join(marker);// Check if we already have a Template for this key
return n=t.keyString.get(r),void 0===n&&(n=new Template(e,e.getTemplateElement()),t.keyString.set(r,n)),t.stringsArray.set(e.strings,n),n}const templateCaches=new Map,parts=new WeakMap,render=(e,t,n)=>{let r=parts.get(t);r===void 0&&(removeNodes(t,t.firstChild),parts.set(t,r=new NodePart(Object.assign({templateFactory},n))),r.appendInto(t)),r.setValue(e),r.commit()};/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.0.0");/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */const html=(e,...t)=>new TemplateResult(e,t,"html",defaultTemplateProcessor),svg=(e,...t)=>new SVGTemplateResult(e,t,"svg",defaultTemplateProcessor),walkerNodeFilter=133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */ /**
 * Removes the list of nodes from a Template safely. In addition to removing
 * nodes from the Template, the Template part indices are updated to match
 * the mutated Template DOM.
 *
 * As the template is walked the removal state is tracked and
 * part indices are adjusted as needed.
 *
 * div
 *   div#1 (remove) <-- start removing (removing node is div#1)
 *     div
 *       div#2 (remove)  <-- continue removing (removing node is still div#1)
 *         div
 * div <-- stop removing since previous sibling is the removing node (div#1,
 * removed 4 nodes)
 */function removeNodesFromTemplate(e,t){const{element:{content:r},parts:n}=e,s=document.createTreeWalker(r,walkerNodeFilter,null,!1);let a=nextActiveIndexInTemplateParts(n),d=n[a],i=-1,o=0;const l=[];for(let r=null;s.nextNode();){i++;const e=s.currentNode;// End removal if stepped past the removing node
for(e.previousSibling===r&&(r=null),t.has(e)&&(l.push(e),null===r&&(r=e)),null!==r&&o++;d!==void 0&&d.index===i;)// If part is in a removed node deactivate it by setting index to -1 or
// adjust the index as needed.
// go to the next active part.
d.index=null===r?d.index-o:-1,a=nextActiveIndexInTemplateParts(n,a),d=n[a]}l.forEach(e=>e.parentNode.removeChild(e))}const countNodes=e=>{let t=11===e.nodeType/* Node.DOCUMENT_FRAGMENT_NODE */?0:1;for(const n=document.createTreeWalker(e,walkerNodeFilter,null,!1);n.nextNode();)t++;return t},nextActiveIndexInTemplateParts=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(isTemplatePartActive(t))return n}return-1};/**
 * Inserts the given node into the Template, optionally before the given
 * refNode. In addition to inserting the node into the Template, the Template
 * part indices are updated to match the mutated Template DOM.
 */function insertNodeIntoTemplate(e,t,n=null){const{element:{content:s},parts:r}=e;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===n||void 0===n)return void s.appendChild(t);const a=document.createTreeWalker(s,walkerNodeFilter,null,!1);let d=nextActiveIndexInTemplateParts(r),i=0,o=-1;for(;a.nextNode();){o++;const e=a.currentNode;for(e===n&&(i=countNodes(t),n.parentNode.insertBefore(t,n));-1!==d&&r[d].index===o;){// If we've inserted the node, simply adjust all subsequent parts
if(0<i){for(;-1!==d;)r[d].index+=i,d=nextActiveIndexInTemplateParts(r,d);return}d=nextActiveIndexInTemplateParts(r,d)}}}/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ // Get a key to lookup in `templateCaches`.
const getTemplateCacheKey=(e,t)=>`${e}--${t}`;let compatibleShadyCSSVersion=!0;"undefined"==typeof window.ShadyCSS?compatibleShadyCSSVersion=!1:"undefined"==typeof window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."),compatibleShadyCSSVersion=!1);/**
 * Template factory which scopes template DOM using ShadyCSS.
 * @param scopeName {string}
 */const shadyTemplateFactory=e=>t=>{const n=getTemplateCacheKey(t.type,e);let r=templateCaches.get(n);void 0===r&&(r={stringsArray:new WeakMap,keyString:new Map},templateCaches.set(n,r));let s=r.stringsArray.get(t.strings);if(void 0!==s)return s;const a=t.strings.join(marker);if(s=r.keyString.get(a),void 0===s){const n=t.getTemplateElement();compatibleShadyCSSVersion&&window.ShadyCSS.prepareTemplateDom(n,e),s=new Template(t,n),r.keyString.set(a,s)}return r.stringsArray.set(t.strings,s),s},TEMPLATE_TYPES=["html","svg"],removeStylesFromLitTemplates=e=>{TEMPLATE_TYPES.forEach(t=>{const n=templateCaches.get(getTemplateCacheKey(t,e));n!==void 0&&n.keyString.forEach(e=>{const{element:{content:t}}=e,n=new Set;// IE 11 doesn't support the iterable param Set constructor
Array.from(t.querySelectorAll("style")).forEach(e=>{n.add(e)}),removeNodesFromTemplate(e,n)})})},shadyRenderSet=new Set,prepareTemplateStyles=(e,t,n)=>{shadyRenderSet.add(n);// Move styles out of rendered DOM and store.
const r=e.querySelectorAll("style");// If there are no styles, skip unnecessary work
if(0===r.length)return void window.ShadyCSS.prepareTemplateStyles(t.element,n);const s=document.createElement("style");// Collect styles into a single style. This helps us make sure ShadyCSS
// manipulations will not prevent us from being able to fix up template
// part indices.
// NOTE: collecting styles is inefficient for browsers but ShadyCSS
// currently does this anyway. When it does not, this should be changed.
for(let a=0;a<r.length;a++){const e=r[a];e.parentNode.removeChild(e),s.textContent+=e.textContent}// Remove styles from nested templates in this scope.
if(removeStylesFromLitTemplates(n),insertNodeIntoTemplate(t,s,t.element.content.firstChild),window.ShadyCSS.prepareTemplateStyles(t.element,n),window.ShadyCSS.nativeShadow){// When in native Shadow DOM, re-add styling to rendered content using
// the style ShadyCSS produced.
const n=t.element.content.querySelector("style");e.insertBefore(n.cloneNode(!0),e.firstChild)}else{t.element.content.insertBefore(s,t.element.content.firstChild);const e=new Set;e.add(s),removeNodesFromTemplate(t,e)}},render$1=(e,t,n)=>{const r=n.scopeName,s=parts.has(t),a=t instanceof ShadowRoot&&compatibleShadyCSSVersion&&e instanceof TemplateResult,d=a&&!shadyRenderSet.has(r),i=d?document.createDocumentFragment():t;// When performing first scope render,
// (1) We've rendered into a fragment so that there's a chance to
// `prepareTemplateStyles` before sub-elements hit the DOM
// (which might cause them to render based on a common pattern of
// rendering in a custom element's `connectedCallback`);
// (2) Scope the template with ShadyCSS one time only for this scope.
// (3) Render the fragment into the container and make sure the
// container knows its `part` is the one we just rendered. This ensures
// DOM will be re-used on subsequent renders.
if(render(e,i,Object.assign({templateFactory:shadyTemplateFactory(r)},n)),d){const e=parts.get(i);parts.delete(i),e.value instanceof TemplateInstance&&prepareTemplateStyles(i,e.value.template,r),removeNodes(t,t.firstChild),t.appendChild(i),parts.set(t,e)}// After elements have hit the DOM, update styling if this is the
// initial render to this container.
// This is needed whenever dynamic changes are made so it would be
// safest to do every render; however, this would regress performance
// so we leave it up to the user to call `ShadyCSSS.styleElement`
// for dynamic changes.
!s&&a&&window.ShadyCSS.styleElement(t.host)},JSCompiler_renameProperty=e=>e,descriptorFromPrototype=(e,t)=>{if(e in t)for(;t!==Object.prototype;){if(t.hasOwnProperty(e))return Object.getOwnPropertyDescriptor(t,e);t=Object.getPrototypeOf(t)}},defaultConverter={toAttribute(e,t){return t===Boolean?e?"":null:t===Object||t===Array?null==e?e:JSON.stringify(e):e},fromAttribute(e,t){return t===Boolean?null!==e:t===Number?null===e?null:+e:t===Object||t===Array?JSON.parse(e):e}},notEqual=(e,t)=>t!==e&&(t===t||e===e),defaultPropertyDeclaration={attribute:!0,type:String,converter:defaultConverter,reflect:!1,hasChanged:notEqual},microtaskPromise=Promise.resolve(!0),STATE_HAS_UPDATED=1,STATE_UPDATE_REQUESTED=4,STATE_IS_REFLECTING_TO_ATTRIBUTE=8,STATE_IS_REFLECTING_TO_PROPERTY=16,STATE_HAS_CONNECTED=32;/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclassers to render updates as desired.
 */class UpdatingElement extends HTMLElement{constructor(){/**
         * Map with keys for any properties that have changed since the last
         * update cycle with previous values.
         */ /**
         * Map with keys of properties that should be reflected when updated.
         */super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=microtaskPromise,this._hasConnectedResolver=void 0,this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}/**
     * Returns a list of attributes corresponding to the registered properties.
     * @nocollapse
     */static get observedAttributes(){this._finalize();const e=[];for(const[t,n]of this._classProperties){const r=this._attributeNameForProperty(t,n);r!==void 0&&(this._attributeToPropertyMap.set(r,t),e.push(r))}return e}/**
     * Ensures the private `_classProperties` property metadata is created.
     * In addition to `_finalize` this is also called in `createProperty` to
     * ensure the `@property` decorator can add property metadata.
     */ /** @nocollapse */static _ensureClassProperties(){// ensure private storage for property declarations.
if(!this.hasOwnProperty(JSCompiler_renameProperty("_classProperties",this))){this._classProperties=new Map;// NOTE: Workaround IE11 not supporting Map constructor argument.
const e=Object.getPrototypeOf(this)._classProperties;e!==void 0&&e.forEach((e,t)=>this._classProperties.set(t,e))}}/**
     * Creates a property accessor on the element prototype if one does not exist.
     * The property setter calls the property's `hasChanged` property option
     * or uses a strict identity check to determine whether or not to request
     * an update.
     * @nocollapse
     */static createProperty(e,t=defaultPropertyDeclaration){if(this._ensureClassProperties(),this._classProperties.set(e,t),!t.noAccessor){const t=descriptorFromPrototype(e,this.prototype);let n;// If there is a super accessor, capture it and "super" to it
if(void 0!==t&&t.set&&t.get){const{set:r,get:s}=t;n={get(){return s.call(this)},set(t){const n=this[e];r.call(this,t),this.requestUpdate(e,n)},configurable:!0,enumerable:!0}}else{const t="symbol"==typeof e?Symbol():`__${e}`;n={get(){return this[t]},set(n){const r=this[e];this[t]=n,this.requestUpdate(e,r)},configurable:!0,enumerable:!0}}Object.defineProperty(this.prototype,e,n)}}/**
     * Creates property accessors for registered properties and ensures
     * any superclasses are also finalized.
     * @nocollapse
     */static _finalize(){if(!(this.hasOwnProperty(JSCompiler_renameProperty("finalized",this))&&this.finalized)){// finalize any superclasses
const e=Object.getPrototypeOf(this);// make any properties
// Note, only process "own" properties since this element will inherit
// any properties defined on the superClass, and finalization ensures
// the entire prototype chain is finalized.
if("function"==typeof e._finalize&&e._finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(JSCompiler_renameProperty("properties",this))){const e=this.properties,t=[...Object.getOwnPropertyNames(e),...("function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[])];// support symbols in properties (IE11 does not support this)
for(const n of t)// note, use of `any` is due to TypeSript lack of support for symbol in
// index types
this.createProperty(n,e[n])}}}/**
     * Returns the property name for the given attribute `name`.
     * @nocollapse
     */static _attributeNameForProperty(e,t){const n=t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}/**
     * Returns true if a property should request an update.
     * Called when a property value is set and uses the `hasChanged`
     * option for the property if present or a strict identity check.
     * @nocollapse
     */static _valueHasChanged(e,t,n=notEqual){return n(e,t)}/**
     * Returns the property value for the given attribute value.
     * Called via the `attributeChangedCallback` and uses the property's
     * `converter` or `converter.fromAttribute` property option.
     * @nocollapse
     */static _propertyValueFromAttribute(e,t){const n=t.type,r=t.converter||defaultConverter,s="function"==typeof r?r:r.fromAttribute;return s?s(e,n):e}/**
     * Returns the attribute value for the given property value. If this
     * returns undefined, the property will *not* be reflected to an attribute.
     * If this returns null, the attribute will be removed, otherwise the
     * attribute will be set to the value.
     * This uses the property's `reflect` and `type.toAttribute` property options.
     * @nocollapse
     */static _propertyValueToAttribute(e,t){if(void 0===t.reflect)return;const n=t.type,r=t.converter,s=r&&r.toAttribute||defaultConverter.toAttribute;return s(e,n)}/**
     * Performs element initialization. By default captures any pre-set values for
     * registered properties.
     */initialize(){this._saveInstanceProperties()}/**
     * Fixes any properties set on the instance before upgrade time.
     * Otherwise these would shadow the accessor and break these properties.
     * The properties are stored in a Map which is played back after the
     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
     * (<=41), properties created for native platform properties like (`id` or
     * `name`) may not have default values set in the element constructor. On
     * these browsers native properties appear on instances and therefore their
     * default value will overwrite any element default (e.g. if the element sets
     * this.id = 'id' in the constructor, the 'id' will become '' since this is
     * the native platform default).
     */_saveInstanceProperties(){for(const[e]of this.constructor._classProperties)if(this.hasOwnProperty(e)){const t=this[e];delete this[e],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(e,t)}}/**
     * Applies previously saved instance properties.
     */_applyInstanceProperties(){for(const[e,t]of this._instanceProperties)this[e]=t;this._instanceProperties=void 0}connectedCallback(){this._updateState|=STATE_HAS_CONNECTED,this._hasConnectedResolver?(this._hasConnectedResolver(),this._hasConnectedResolver=void 0):this.requestUpdate()}/**
     * Allows for `super.disconnectedCallback()` in extensions while
     * reserving the possibility of making non-breaking feature additions
     * when disconnecting at some point in the future.
     */disconnectedCallback(){}/**
     * Synchronizes property values when attributes change.
     */attributeChangedCallback(e,t,n){t!==n&&this._attributeToProperty(e,n)}_propertyToAttribute(e,t,n=defaultPropertyDeclaration){const r=this.constructor,s=r._attributeNameForProperty(e,n);if(s!==void 0){const e=r._propertyValueToAttribute(t,n);// an undefined value does not change the attribute.
if(e===void 0)return;// Track if the property is being reflected to avoid
// setting the property again via `attributeChangedCallback`. Note:
// 1. this takes advantage of the fact that the callback is synchronous.
// 2. will behave incorrectly if multiple attributes are in the reaction
// stack at time of calling. However, since we process attributes
// in `update` this should not be possible (or an extreme corner case
// that we'd like to discover).
// mark state reflecting
// mark state not reflecting
this._updateState|=STATE_IS_REFLECTING_TO_ATTRIBUTE,null==e?this.removeAttribute(s):this.setAttribute(s,e),this._updateState&=~STATE_IS_REFLECTING_TO_ATTRIBUTE}}_attributeToProperty(e,t){// Use tracking info to avoid deserializing attribute value if it was
// just set from a property setter.
if(this._updateState&STATE_IS_REFLECTING_TO_ATTRIBUTE)return;const n=this.constructor,r=n._attributeToPropertyMap.get(e);if(r!==void 0){const e=n._classProperties.get(r)||defaultPropertyDeclaration;// mark state reflecting
// mark state not reflecting
this._updateState|=STATE_IS_REFLECTING_TO_PROPERTY,this[r]=n._propertyValueFromAttribute(t,e),this._updateState&=~STATE_IS_REFLECTING_TO_PROPERTY}}/**
     * Requests an update which is processed asynchronously. This should
     * be called when an element should update based on some state not triggered
     * by setting a property. In this case, pass no arguments. It should also be
     * called when manually implementing a property setter. In this case, pass the
     * property `name` and `oldValue` to ensure that any configured property
     * options are honored. Returns the `updateComplete` Promise which is resolved
     * when the update completes.
     *
     * @param name {PropertyKey} (optional) name of requesting property
     * @param oldValue {any} (optional) old value of requesting property
     * @returns {Promise} A Promise that is resolved when the update completes.
     */requestUpdate(e,t){let n=!0;// if we have a property key, perform property update steps.
if(void 0!==e&&!this._changedProperties.has(e)){const r=this.constructor,s=r._classProperties.get(e)||defaultPropertyDeclaration;r._valueHasChanged(this[e],t,s.hasChanged)?(this._changedProperties.set(e,t),!0===s.reflect&&!(this._updateState&STATE_IS_REFLECTING_TO_PROPERTY)&&(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,s))):n=!1}return!this._hasRequestedUpdate&&n&&this._enqueueUpdate(),this.updateComplete}/**
     * Sets up the element to asynchronously update.
     */async _enqueueUpdate(){this._updateState|=STATE_UPDATE_REQUESTED;let e;const t=this._updatePromise;this._updatePromise=new Promise(t=>e=t),await t,this._hasConnected||(await new Promise(e=>this._hasConnectedResolver=e));// Allow `performUpdate` to be asynchronous to enable scheduling of updates.
const n=this.performUpdate();// Note, this is to avoid delaying an additional microtask unless we need
// to.
null!=n&&"function"==typeof n.then&&(await n),e(!this._hasRequestedUpdate)}get _hasConnected(){return this._updateState&STATE_HAS_CONNECTED}get _hasRequestedUpdate(){return this._updateState&STATE_UPDATE_REQUESTED}get hasUpdated(){return this._updateState&STATE_HAS_UPDATED}/**
     * Performs an element update.
     *
     * You can override this method to change the timing of updates. For instance,
     * to schedule updates to occur just before the next frame:
     *
     * ```
     * protected async performUpdate(): Promise<unknown> {
     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
     *   super.performUpdate();
     * }
     * ```
     */performUpdate(){if(this._instanceProperties&&this._applyInstanceProperties(),this.shouldUpdate(this._changedProperties)){const e=this._changedProperties;this.update(e),this._markUpdated(),this._updateState&STATE_HAS_UPDATED||(this._updateState|=STATE_HAS_UPDATED,this.firstUpdated(e)),this.updated(e)}else this._markUpdated()}_markUpdated(){this._changedProperties=new Map,this._updateState&=~STATE_UPDATE_REQUESTED}/**
     * Returns a Promise that resolves when the element has completed updating.
     * The Promise value is a boolean that is `true` if the element completed the
     * update without triggering another update. The Promise result is `false` if
     * a property was set inside `updated()`. This getter can be implemented to
     * await additional state. For example, it is sometimes useful to await a
     * rendered element before fulfilling this Promise. To do this, first await
     * `super.updateComplete` then any subsequent state.
     *
     * @returns {Promise} The Promise returns a boolean that indicates if the
     * update resolved without triggering another update.
     */get updateComplete(){return this._updatePromise}/**
     * Controls whether or not `update` should be called when the element requests
     * an update. By default, this method always returns `true`, but this can be
     * customized to control when to update.
     *
     * * @param _changedProperties Map of changed properties with old values
     */shouldUpdate(){return!0}/**
     * Updates the element. This method reflects property values to attributes.
     * It can be overridden to render and keep updated element DOM.
     * Setting properties inside this method will *not* trigger
     * another update.
     *
     * * @param _changedProperties Map of changed properties with old values
     */update(){if(this._reflectingProperties!==void 0&&0<this._reflectingProperties.size){for(const[e,t]of this._reflectingProperties)this._propertyToAttribute(e,this[e],t);this._reflectingProperties=void 0}}/**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param _changedProperties Map of changed properties with old values
     */updated(){}/**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param _changedProperties Map of changed properties with old values
     */firstUpdated(){}}/**
 * Marks class as having finished creating properties.
 */UpdatingElement.finalized=!0;/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */ /**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at
http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
part of the polymer project is also subject to an additional IP rights grant
found at http://polymer.github.io/PATENTS.txt
*/const supportsAdoptingStyleSheets="adoptedStyleSheets"in Document.prototype;class CSSResult{constructor(e){this.cssText=e}// Note, this is a getter so that it's lazy. In practice, this means
// stylesheets are not created until the first element instance is made.
get styleSheet(){return void 0===this._styleSheet&&(supportsAdoptingStyleSheets?(this._styleSheet=new CSSStyleSheet,this._styleSheet.replaceSync(this.cssText)):this._styleSheet=null),this._styleSheet}}const textFromCSSResult=e=>{if(e instanceof CSSResult)return e.cssText;throw new Error(`Value passed to 'css' function must be a 'css' function result: ${e}.`)},css=(e,...t)=>{const n=t.reduce((t,n,r)=>t+textFromCSSResult(n)+e[r+1],e[0]);return new CSSResult(n)};/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */class LitElement extends UpdatingElement{/**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */static get styles(){return[]}static get _uniqueStyles(){if(this._styles===void 0){const e=this.styles,t=e.reduceRight((e,t)=>(e.add(t),e),new Set);// As a performance optimization to avoid duplicated styling that can
// occur especially when composing via subclassing, de-duplicate styles
// preserving the last item in the list. The last item is kept to
// try to preserve cascade order with the assumption that it's most
// important that last added styles override previous styles.
// Array.form does not work on Set in IE
this._styles=[],t.forEach(e=>this._styles.unshift(e))}return this._styles}/**
     * Performs element initialization. By default this calls `createRenderRoot`
     * to create the element `renderRoot` node and captures any pre-set values for
     * registered properties.
     */initialize(){super.initialize(),this.renderRoot=this.createRenderRoot(),window.ShadowRoot&&this.renderRoot instanceof window.ShadowRoot&&this.adoptStyles()}/**
     * Returns the node into which the element should render and by default
     * creates and returns an open shadowRoot. Implement to customize where the
     * element's DOM is rendered. For example, to render into the element's
     * childNodes, return `this`.
     * @returns {Element|DocumentFragment} Returns a node into which to render.
     */createRenderRoot(){return this.attachShadow({mode:"open"})}/**
     * Applies styling to the element shadowRoot using the `static get styles`
     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
     * available and will fallback otherwise. When Shadow DOM is polyfilled,
     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
     * is available but `adoptedStyleSheets` is not, styles are appended to the
     * end of the `shadowRoot` to [mimic spec
     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
     */adoptStyles(){const e=this.constructor._uniqueStyles;0===e.length||(window.ShadyCSS===void 0||window.ShadyCSS.nativeShadow?supportsAdoptingStyleSheets?this.renderRoot.adoptedStyleSheets=e.map(e=>e.styleSheet):this._needsShimAdoptedStyleSheets=!0:window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e=>e.cssText),this.localName));// There are three separate cases here based on Shadow DOM support.
// (1) shadowRoot polyfilled: use ShadyCSS
// (2) shadowRoot.adoptedStyleSheets available: use it.
// (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
// rendering
}connectedCallback(){super.connectedCallback(),this.hasUpdated&&window.ShadyCSS!==void 0&&window.ShadyCSS.styleElement(this)}/**
     * Updates the element. This method reflects property values to attributes
     * and calls `render` to render DOM via lit-html. Setting properties inside
     * this method will *not* trigger another update.
     * * @param _changedProperties Map of changed properties with old values
     */update(e){super.update(e);const t=this.render();t instanceof TemplateResult&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this}),this._needsShimAdoptedStyleSheets&&(this._needsShimAdoptedStyleSheets=!1,this.constructor._uniqueStyles.forEach(e=>{const t=document.createElement("style");t.textContent=e.cssText,this.renderRoot.appendChild(t)}))}/**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */render(){}}/**
 * Ensure this class is marked as `finalized` as an optimization ensuring
 * it will not needlessly try to `finalize`.
 */LitElement.finalized=!0,LitElement.render=render$1;var faTimes={prefix:"fas",iconName:"times",icon:[352,512,[],"f00d","M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]},faEnvelope={prefix:"fas",iconName:"envelope",icon:[512,512,[],"f0e0","M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"]},faPhone={prefix:"fas",iconName:"phone",icon:[512,512,[],"f095","M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"]},faHome={prefix:"fas",iconName:"home",icon:[576,512,[],"f015","M488 312.7V456c0 13.3-10.7 24-24 24H348c-6.6 0-12-5.4-12-12V356c0-6.6-5.4-12-12-12h-72c-6.6 0-12 5.4-12 12v112c0 6.6-5.4 12-12 12H112c-13.3 0-24-10.7-24-24V312.7c0-3.6 1.6-7 4.4-9.3l188-154.8c4.4-3.6 10.8-3.6 15.3 0l188 154.8c2.7 2.3 4.3 5.7 4.3 9.3zm83.6-60.9L488 182.9V44.4c0-6.6-5.4-12-12-12h-56c-6.6 0-12 5.4-12 12V117l-89.5-73.7c-17.7-14.6-43.3-14.6-61 0L4.4 251.8c-5.1 4.2-5.8 11.8-1.6 16.9l25.5 31c4.2 5.1 11.8 5.8 16.9 1.6l235.2-193.7c4.4-3.6 10.8-3.6 15.3 0l235.2 193.7c5.1 4.2 12.7 3.5 16.9-1.6l25.5-31c4.2-5.2 3.4-12.7-1.7-16.9z"]};/*
 * Copyright 2018 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */const{IntersectionObserver,CustomEvent}=window;class ByuPersonLookupResults extends LitElement{static get properties(){return{results:{type:Array},context:{type:String},searchPending:{type:Boolean}}}static get styles(){return[css`
      :host {
        padding: 1rem;
      }
      * {
        font-family: 'HCo Ringside Narrow SSm', Arial Narrow, Arial, sans-serif;
      }
      .modal {
        z-index: 98;
        background-color: rgba(0, 0, 0, 0.6);
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      }
      .results {
        z-index: 99;
        position: absolute;
        left: 0;
        right: 0;
        top: 20vh;
        bottom: 0;
        padding: 0.5rem;
        background-color: white;
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto;
        grid-gap: 0.5rem;
        overflow: auto;
      }
      .close-modal {
        z-index: 100;
        position: absolute;
        right: 0;
        top: calc(20vh - 2rem);
        border-radius: 50%;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        padding: 0.3rem;
        border: 1px solid #5199E1;
        cursor: pointer;
        box-shadow: 0rem 0rem 1rem #5199E1;
      }
      h2 {
        margin: 0;
      }
      table {
        border-collapse: collapse;
      }
      th, td {
        padding: 0.5rem;
        border-bottom: 1px solid #666666;
      }
      th {
        text-align: left;
        background-color: #0057B8;
        color: white;
        padding: 1rem;
      }
      tbody tr { cursor: pointer; }
      tbody tr:nth-child(odd) {
        background-color: #E6E6E6;
      }
      tbody tr.placeholder { cursor: default; }
      ol, ul {
        margin: 0;
        padding: 0;
        display: inline-flex;
        flex-direction: column;
      }
      li {
        list-style-type: none;
        margin: 0;
      }
      .nav-btn {
        padding: 0.3rem 1rem;
        border: thin solid #666666;
        border-radius: 0.05rem;
        color: white;
        cursor: pointer;
        justify-self: start;
        align-self: center;
      }
      button {
        font-size: 1.1rem;
        background-color: #0057B8;
      }
      button:hover, button:active {
        box-shadow: inset 0 0 0.2rem rgba(255, 255, 255, 0.5);
        background-color: #5199E1;
      }
      .deck {
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
        grid-gap: 1rem;
      }
      .card {
        border: thin solid #666666;
        border-left: 0.5rem solid #002E5D;
        padding: 0.5rem;
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
        grid-gap: 0.5rem;
        cursor: pointer;
      }
      .card h3 {
        margin: 0;
      }
      .contact {
        display: flex;
        flex-direction: column;
      }
      .contact div {
        display: inline-grid;
        grid-template-columns: auto 1fr;
        grid-gap: 0.25rem;
      }
      .contact div svg {
        margin-top: calc(1rem - 14px);
      }
      .card.placeholder { cursor: default; }
      svg.placeholder { filter: blur(1px); width: 18rem; height: 6rem; }
      svg.placeholder line {
        animation: pulse 1000ms ease-in-out infinite alternate;
      }
      @keyframes pulse {
        from { stroke: #999999; }
        70% { stroke: #999999; }
        to { stroke: #B3B5B7; }
      }
      @media only screen and (min-width: 650px) {
        .deck {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(28rem, 1fr));
          grid-auto-rows: auto;
          grid-gap: 1rem;
        }
        .card {
          border: thin solid #666666;
          border-left: 0.5rem solid #002E5D;
          padding: 0.5rem;
          display: grid;
          grid-template-columns: 1fr 1fr;
          grid-template-rows: auto auto;
          grid-gap: 0.5rem;
          cursor: pointer;
        }
        .card h3 {
          margin: 0;
          grid-column: 1/-1;
        }
      }
      @media only screen and (min-width: 900px) {
        .results {
          left: 10vw;
          right: 10vw;
          top: 10vh;
          max-height: 85vh;
        }
        .close-modal {
          right: calc(10vw - 2rem);
          top: calc(10vh - 2rem);
        }
      }
    `]}constructor(){super(),this.results=null,this.context="directory",this.searchPending=!1,this.isObserving=!1}updated(e){if(e.forEach((e,t)=>{console.log(`lookup-results::property changed!
        ${t}: '${e}' => '${this[t]}'`)}),this.results&&0<this.results.length&&!this.isObserving){console.log("lookup-results::set up intersection observer");const e=this.shadowRoot.getElementById("top"),t=this.shadowRoot.getElementById("bottom");if(!IntersectionObserver||!e||!t)return;const n=new IntersectionObserver(n=>{n.forEach(n=>{n.isIntersecting&&(n.target===t?this.next():n.target===e&&this.prev())})},{});// observer.observe(top)
console.log("lookup-results::observing!",t),n.observe(t),this.isObserving=!0}}firstUpdated(){}render(){// console.log(`byu-person-lookup-results::_render::searchPending=${searchPending}`)
const e=()=>[1,2,3,4,5,6].map(()=>html`
      <tr class="placeholder"><td colspan="5">
        <svg class="placeholder" viewBox="0 0 100 3" preserveAspectRatio="none">
          ${svg`<line x1="5" x2="95" y1="1.5" y2="1.5" stroke="#666666" />`}
        </svg>
      </td></tr>
    `),t=()=>[1,2,3,4,5,6].map(()=>html`
      <div class="card placeholder">
        <svg class="placeholder" viewBox="0 0 50 40" preserveAspectRatio="none">
          <rect x="1" y="1" width="40" height="15" fill="#999999"></rect>
          <rect x="1" y="25" width="45" height="5" fill="#999999"></rect>
          <rect x="1" y="33" width="30" height="5" fill="#999999"></rect>
        </svg>
        <svg class="placeholder" viewBox="0 0 50 40" preserveAspectRatio="none">
          <rect x="1" y="17" width="45" height="5" fill="#999999"></rect>
          <rect x="1" y="25" width="30" height="5" fill="#999999"></rect>
          <rect x="1" y="33" width="35" height="5" fill="#999999"></rect>
        </svg>
      </div>
    `),n=e=>html`
      <ul>
        ${e.map(e=>html`<li>${e}</li>`)}
      </ul>
    `,s=e=>html`
      <tr @click=${()=>this.select(e)}>
        <td>${e.name}</td>
        <td>${e.byuId}</td>
        <td>${e.netId}</td>
        <td>${e.employeeType}</td>
        <td>${e.studentStatus}</td>
      </tr>
    `,a=e=>/ACT|LEV/.test(e.employeeType)||""===e.employeeType&&e.jobTitle&&e.department?html`
          <div>
            <div>${e.jobTitle}</div>
            <div>${e.department}</div>
            <div>${e.addresses?e.addresses.work?n(e.addresses.work):"":""}</div>
          </div>
        `:html`<div></div>`,[,,,,d]=faEnvelope.icon,[,,,,i]=faPhone.icon,[,,,,o]=faHome.icon,[,,,,l]=faTimes.icon,p=svg`
    <path d=${l} fill="white" transform="translate(90)"/>
    `,u=e=>html`
      <svg width="14" height="14" viewBox="0 0 512 512">
        ${svg`<path d=${e} fill="#666666"/>`}
      </svg>
    `,c=e=>html`
      <div class="card" @click=${()=>this.select(e)}>
        <h3>${e.name}</h3>
        ${a(e)}
        <div class="contact">
          <div>${u(d)}${e.email}</div>
          <div>${u(i)}${e.phone}</div>
          <div>${u(o)}${e.addresses?e.addresses.mailing?n(e.addresses.mailing):"":""}</div>
        </div>
      </div>
    `;return this.results&&this.results.map&&!(1>this.results.length)?html`
      <div class="modal">
        <div class="results">
          <h2 id="top">Lookup Results</h2>
          ${this.context&&"admin"===this.context?(t=>html`
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>BYU ID</th>
            <th>Net ID</th>
            <th>EMP Type</th>
            <th>STD Status</th>
          </tr>
        </thead>
        <tbody>
          ${t.map(e=>s(e))}
          ${this.searchPending?e():""}
        </tbody>
      </table>
    `)(this.results):(e=>html`
      <div class="deck">
        ${e.map(e=>c(e))}
        ${this.searchPending?t():""}
      </div>
    `)(this.results)}
          <div class="spacer"></div>
          ${IntersectionObserver?html`<button id="bottom" class="nav-btn" @click=${this.close}>Close</button>`:html`<div>
             <button class="nav-btn" @click=${this.prev}>Prev</button>
             <button class="nav-btn" @click=${this.next}>Next</button>
           </div>`}
        </div>
        <button class="close-modal" @click=${()=>this.close()}>
          <svg alt="Search" width="24" height="24" viewBox="0 0 512 512">
            ${p}
          </svg>
        </button>
      </div>
    `:html``}dispatch(e,t){const n=t?{detail:t,bubbles:!0,composed:!0}:{bubbles:!0,composed:!0},r=new CustomEvent(e,n);this.dispatchEvent(r)}select(e){const{personId:t,byuId:n,netId:r,name:s}=e;this.dispatch("byu-lookup-results-select",{personId:t,byuId:n,netId:r,name:s}),this.close()}close(){this.dispatch("byu-lookup-results-close"),this.isObserving=!1}next(){this.searchPending||this.dispatch("byu-lookup-next-page")}prev(){this.searchPending||this.dispatch("byu-lookup-prev-page")}}/*
console.log('registering person lookup results')
window.customElements.define('byu-person-lookup-results', ByuPersonLookupResults)
*/export default ByuPersonLookupResults;
