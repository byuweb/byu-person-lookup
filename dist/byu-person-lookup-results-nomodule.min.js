var byu_person_lookup_results=function(){'use strict';/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * The default TemplateFactory which caches Templates keyed on
     * result.type and result.strings.
     */function e(e){let t=w.get(e.type);void 0===t&&(t={stringsArray:new WeakMap,keyString:new Map},w.set(e.type,t));let n=t.stringsArray.get(e.strings);if(void 0!==n)return n;// If the TemplateStringsArray is new, generate a key from the strings
// This key is shared between all templates with identical content
const r=e.strings.join(p);// Check if we already have a Template for this key
return n=t.keyString.get(r),void 0===n&&(n=new g(e,e.getTemplateElement()),t.keyString.set(r,n)),t.stringsArray.set(e.strings,n),n}/**
     * Removes the list of nodes from a Template safely. In addition to removing
     * nodes from the Template, the Template part indices are updated to match
     * the mutated Template DOM.
     *
     * As the template is walked the removal state is tracked and
     * part indices are adjusted as needed.
     *
     * div
     *   div#1 (remove) <-- start removing (removing node is div#1)
     *     div
     *       div#2 (remove)  <-- continue removing (removing node is still div#1)
     *         div
     * div <-- stop removing since previous sibling is the removing node (div#1,
     * removed 4 nodes)
     */function t(e,t){const{element:{content:r},parts:n}=e,a=document.createTreeWalker(r,H,null,!1);let s=U(n),d=n[s],i=-1,o=0;const l=[];for(let r=null;a.nextNode();){i++;const e=a.currentNode;// End removal if stepped past the removing node
for(e.previousSibling===r&&(r=null),t.has(e)&&(l.push(e),null===r&&(r=e)),null!==r&&o++;d!==void 0&&d.index===i;)// If part is in a removed node deactivate it by setting index to -1 or
// adjust the index as needed.
// go to the next active part.
d.index=null===r?d.index-o:-1,s=U(n,s),d=n[s]}l.forEach(e=>e.parentNode.removeChild(e))}/**
     * Inserts the given node into the Template, optionally before the given
     * refNode. In addition to inserting the node into the Template, the Template
     * part indices are updated to match the mutated Template DOM.
     */function n(e,t,n=null){const{element:{content:a},parts:r}=e;// If there's no refNode, then put node at end of template.
// No part indices need to be shifted in this case.
if(null===n||void 0===n)return void a.appendChild(t);const s=document.createTreeWalker(a,H,null,!1);let d=U(r),i=0,o=-1;for(;s.nextNode();){o++;const e=s.currentNode;for(e===n&&(i=M(t),n.parentNode.insertBefore(t,n));-1!==d&&r[d].index===o;){// If we've inserted the node, simply adjust all subsequent parts
if(0<i){for(;-1!==d;)r[d].index+=i,d=U(r,d);return}d=U(r,d)}}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ // Get a key to lookup in `templateCaches`.
const r=new WeakMap,a=e=>"function"==typeof e&&r.has(e),s=window.customElements!==void 0&&window.customElements.polyfillWrapFlushCallback!==void 0,d=(e,t,n=null,r=null)=>{for(let a=t;a!==n;){const t=a.nextSibling;e.insertBefore(a,r),a=t}},i=(e,t,n=null)=>{for(let r=t;r!==n;){const t=r.nextSibling;e.removeChild(r),r=t}},o={},l={},p=`{{lit-${(Math.random()+"").slice(2)}}}`,u=`<!--${p}-->`,c=new RegExp(`${p}|${u}`),m="$lit$";/**
     * An updateable Template that tracks the location of dynamic parts.
     */class g{constructor(e,t){this.parts=[],this.element=t;let n=-1,r=0;const a=[],s=t=>{const d=t.content,i=document.createTreeWalker(d,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
for(// Keeps track of the last index associated with a part. We try to delete
// unnecessary nodes, but we never want to associate two different parts
// to the same index. They must have a constant node between.
let d=0;i.nextNode();){n++;const t=i.currentNode;if(1===t.nodeType/* Node.ELEMENT_NODE */){if(t.hasAttributes()){const a=t.attributes;// Per
// https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,
// attributes are not guaranteed to be returned in document order.
// In particular, Edge/IE can return them out of order, so we cannot
// assume a correspondance between part index and attribute index.
let s=0;for(let e=0;e<a.length;e++)0<=a[e].value.indexOf(p)&&s++;for(;0<s--;){// Get the template literal section leading up to the first
// expression in this attribute
const a=e.strings[r],s=_.exec(a)[2],d=s.toLowerCase()+m,i=t.getAttribute(d),o=i.split(c);// Find the attribute name
this.parts.push({type:"attribute",index:n,name:s,strings:o}),t.removeAttribute(d),r+=o.length-1}}"TEMPLATE"===t.tagName&&s(t)}else if(3===t.nodeType/* Node.TEXT_NODE */){const e=t.data;if(0<=e.indexOf(p)){const s=t.parentNode,d=e.split(c),o=d.length-1;// Generate a new text node for each literal section
// These nodes are also used as the markers for node parts
for(let e=0;e<o;e++)s.insertBefore(""===d[e]?f():document.createTextNode(d[e]),t),this.parts.push({type:"node",index:++n});// If there's no text, we must insert a comment to mark our place.
// Else, we can trust it will stick around after cloning.
// We have a part for each match found
""===d[o]?(s.insertBefore(f(),t),a.push(t)):t.data=d[o],r+=o}}else if(8===t.nodeType/* Node.COMMENT_NODE */)if(t.data===p){const e=t.parentNode;// Add a new marker node to be the startNode of the Part if any of
// the following are true:
//  * We don't have a previousSibling
//  * The previousSibling is already the start of a previous part
(null===t.previousSibling||n===d)&&(n++,e.insertBefore(f(),t)),d=n,this.parts.push({type:"node",index:n}),null===t.nextSibling?t.data="":(a.push(t),n--),r++}else for(let e=-1;-1!==(e=t.data.indexOf(p,e+1));)// Comment node has a binding marker inside, make an inactive part
// The binding won't work, but subsequent bindings will
// TODO (justinfagnani): consider whether it's even worth it to
// make bindings in comments work
this.parts.push({type:"node",index:-1})}};s(t);// Remove text binding nodes after the walk to not disturb the TreeWalker
for(const r of a)r.parentNode.removeChild(r)}}const h=e=>-1!==e.index,f=()=>document.createComment(""),_=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;// Allows `document.createComment('')` to be renamed for a
// small manual size-savings.
/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * An instance of a `Template` that can be attached to the DOM and updated
     * with new values.
     */class y{constructor(e,t,n){this._parts=[],this.template=e,this.processor=t,this.options=n}update(e){let t=0;for(const n of this._parts)void 0!==n&&n.setValue(e[t]),t++;for(const t of this._parts)void 0!==t&&t.commit()}_clone(){// When using the Custom Elements polyfill, clone the node, rather than
// importing it, to keep the fragment in the template's document. This
// leaves the fragment inert so custom elements won't upgrade and
// potentially modify their contents by creating a polyfilled ShadowRoot
// while we traverse the tree.
const e=s?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),t=this.template.parts;let n=0,r=0;const a=e=>{// Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
// null
const s=document.createTreeWalker(e,133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,null,!1);// Loop through all the nodes and parts of a template
for(let d=s.nextNode();n<t.length&&null!==d;){const e=t[n];// Consecutive Parts may have the same node index, in the case of
// multiple bound attributes on an element. So each iteration we either
// increment the nodeIndex, if we aren't on a node with a part, or the
// partIndex if we are. By not incrementing the nodeIndex when we find a
// part, we allow for the next part to be associated with the current
// node if neccessasry.
if(!h(e))this._parts.push(void 0),n++;else if(r===e.index){if("node"===e.type){const e=this.processor.handleTextExpression(this.options);e.insertAfterNode(d.previousSibling),this._parts.push(e)}else this._parts.push(...this.processor.handleAttributeExpressions(d,e.name,e.strings,this.options));n++}else r++,"TEMPLATE"===d.nodeName&&a(d.content),d=s.nextNode()}};return a(e),s&&(document.adoptNode(e),customElements.upgrade(e)),e}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * The return type of `html`, which holds a Template and the values from
     * interpolated expressions.
     */class S{constructor(e,t,n,r){this.strings=e,this.values=t,this.type=n,this.processor=r}/**
         * Returns a string of HTML used to create a `<template>` element.
         */getHTML(){const e=this.strings.length-1;let t="";for(let n=0;n<e;n++){const e=this.strings[n],r=_.exec(e);// This exec() call does two things:
// 1) Appends a suffix to the bound attribute name to opt out of special
// attribute value parsing that IE11 and Edge do, like for style and
// many SVG attributes. The Template class also appends the same suffix
// when looking up attributes to create Parts.
// 2) Adds an unquoted-attribute-safe marker for the first expression in
// an attribute. Subsequent attribute expressions will use node markers,
// and this is safe since attributes with multiple expressions are
// guaranteed to be quoted.
t+=r?e.substr(0,r.index)+r[1]+r[2]+m+r[3]+p:e+u}return t+this.strings[e]}getTemplateElement(){const e=document.createElement("template");return e.innerHTML=this.getHTML(),e}}/**
     * A TemplateResult for SVG fragments.
     *
     * This class wraps HTMl in an `<svg>` tag in order to parse its contents in the
     * SVG namespace, then modifies the template to remove the `<svg>` tag so that
     * clones only container the original fragment.
     */class v extends S{getHTML(){return`<svg>${super.getHTML()}</svg>`}getTemplateElement(){const e=super.getTemplateElement(),t=e.content,n=t.firstChild;return t.removeChild(n),d(t,n.firstChild),e}}/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */const b=e=>null===e||"object"!=typeof e&&"function"!=typeof e;/**
     * Sets attribute values for AttributeParts, so that the value is only set once
     * even if there are multiple parts for an attribute.
     */class x{constructor(e,t,n){this.dirty=!0,this.element=e,this.name=t,this.strings=n,this.parts=[];for(let r=0;r<n.length-1;r++)this.parts[r]=this._createPart()}/**
         * Creates a single part. Override this to create a differnt type of part.
         */_createPart(){return new P(this)}_getValue(){const e=this.strings,t=e.length-1;let n="";for(let r=0;r<t;r++){n+=e[r];const t=this.parts[r];if(void 0!==t){const e=t.value;if(null!=e&&(Array.isArray(e)||// tslint:disable-next-line:no-any
"string"!=typeof e&&e[Symbol.iterator]))for(const r of e)n+="string"==typeof r?r:r+"";else n+="string"==typeof e?e:e+""}}return n+=e[t],n}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class P{constructor(e){this.value=void 0,this.committer=e}setValue(e){e===o||b(e)&&e===this.value||(this.value=e,!a(e)&&(this.committer.dirty=!0))}commit(){for(;a(this.value);){const e=this.value;this.value=o,e(this)}this.value===o||this.committer.commit()}}class N{constructor(e){this.value=void 0,this._pendingValue=void 0,this.options=e}/**
         * Inserts this part into a container.
         *
         * This part must be empty, as its contents are not automatically moved.
         */appendInto(e){this.startNode=e.appendChild(f()),this.endNode=e.appendChild(f())}/**
         * Inserts this part between `ref` and `ref`'s next sibling. Both `ref` and
         * its next sibling must be static, unchanging nodes such as those that appear
         * in a literal section of a template.
         *
         * This part must be empty, as its contents are not automatically moved.
         */insertAfterNode(e){this.startNode=e,this.endNode=e.nextSibling}/**
         * Appends this part into a parent part.
         *
         * This part must be empty, as its contents are not automatically moved.
         */appendIntoPart(e){e._insert(this.startNode=f()),e._insert(this.endNode=f())}/**
         * Appends this part after `ref`
         *
         * This part must be empty, as its contents are not automatically moved.
         */insertAfterPart(e){e._insert(this.startNode=f()),this.endNode=e.endNode,e.endNode=this.startNode}setValue(e){this._pendingValue=e}commit(){for(;a(this._pendingValue);){const e=this._pendingValue;this._pendingValue=o,e(this)}const e=this._pendingValue;e===o||(b(e)?e!==this.value&&this._commitText(e):e instanceof S?this._commitTemplateResult(e):e instanceof Node?this._commitNode(e):Array.isArray(e)||// tslint:disable-next-line:no-any
e[Symbol.iterator]?this._commitIterable(e):e===l?(this.value=l,this.clear()):this._commitText(e))}_insert(e){this.endNode.parentNode.insertBefore(e,this.endNode)}_commitNode(e){this.value===e||(this.clear(),this._insert(e),this.value=e)}_commitText(e){const t=this.startNode.nextSibling;e=null==e?"":e,t===this.endNode.previousSibling&&3===t.nodeType/* Node.TEXT_NODE */?t.data=e:this._commitNode(document.createTextNode("string"==typeof e?e:e+"")),this.value=e}_commitTemplateResult(e){const t=this.options.templateFactory(e);if(this.value instanceof y&&this.value.template===t)this.value.update(e.values);else{// Make sure we propagate the template processor from the TemplateResult
// so that we use its syntax extension, etc. The template factory comes
// from the render function options so that it can control template
// caching and preprocessing.
const n=new y(t,e.processor,this.options),r=n._clone();n.update(e.values),this._commitNode(r),this.value=n}}_commitIterable(e){Array.isArray(this.value)||(this.value=[],this.clear());// Lets us keep track of how many items we stamped so we can clear leftover
// items from a previous render
const t=this.value;let n,r=0;for(const a of e)// Try to reuse an existing part
n=t[r],void 0===n&&(n=new N(this.options),t.push(n),0==r?n.appendIntoPart(this):n.insertAfterPart(t[r-1])),n.setValue(a),n.commit(),r++;r<t.length&&(t.length=r,this.clear(n&&n.endNode))}clear(e=this.startNode){i(this.startNode.parentNode,e.nextSibling,this.endNode)}}/**
     * Implements a boolean attribute, roughly as defined in the HTML
     * specification.
     *
     * If the value is truthy, then the attribute is present with a value of
     * ''. If the value is falsey, the attribute is removed.
     */class C{constructor(e,t,n){if(this.value=void 0,this._pendingValue=void 0,2!==n.length||""!==n[0]||""!==n[1])throw new Error("Boolean attributes can only contain a single expression");this.element=e,this.name=t,this.strings=n}setValue(e){this._pendingValue=e}commit(){for(;a(this._pendingValue);){const e=this._pendingValue;this._pendingValue=o,e(this)}if(this._pendingValue!==o){const e=!!this._pendingValue;this.value!==e&&(e?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=e,this._pendingValue=o}}}/**
     * Sets attribute values for PropertyParts, so that the value is only set once
     * even if there are multiple parts for a property.
     *
     * If an expression controls the whole property value, then the value is simply
     * assigned to the property under control. If there are string literals or
     * multiple expressions, then the strings are expressions are interpolated into
     * a string first.
     */class T extends x{constructor(e,t,n){super(e,t,n),this.single=2===n.length&&""===n[0]&&""===n[1]}_createPart(){return new A(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class A extends P{}// Detect event listener options support. If the `capture` property is read
// from the options object, then options are supported. If not, then the thrid
// argument to add/removeEventListener is interpreted as the boolean capture
// value so we should only pass the `capture` property.
let V=!1;try{const e={get capture(){return V=!0,!1}};// tslint:disable-next-line:no-any
// tslint:disable-next-line:no-any
window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}catch(e){}class E{constructor(e,t,n){this.value=void 0,this._pendingValue=void 0,this.element=e,this.eventName=t,this.eventContext=n,this._boundHandleEvent=t=>this.handleEvent(t)}setValue(e){this._pendingValue=e}commit(){for(;a(this._pendingValue);){const e=this._pendingValue;this._pendingValue=o,e(this)}if(this._pendingValue===o)return;const e=this._pendingValue,t=this.value,n=null==e||null!=t&&(e.capture!==t.capture||e.once!==t.once||e.passive!==t.passive);n&&this.element.removeEventListener(this.eventName,this._boundHandleEvent,this._options),null!=e&&(null==t||n)&&(this._options=I(e),this.element.addEventListener(this.eventName,this._boundHandleEvent,this._options)),this.value=e,this._pendingValue=o}handleEvent(e){"function"==typeof this.value?this.value.call(this.eventContext||this.element,e):this.value.handleEvent(e)}}// We copy options because of the inconsistent behavior of browsers when reading
// the third argument of add/removeEventListener. IE11 doesn't support options
// at all. Chrome 41 only reads `capture` if the argument is an object.
const I=e=>e&&(V?{capture:e.capture,passive:e.passive,once:e.once}:e.capture);/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
     * Creates Parts when a template is instantiated.
     */const k=new class{/**
         * Create parts for an attribute-position binding, given the event, attribute
         * name, and string literals.
         *
         * @param element The element containing the binding
         * @param name  The attribute name
         * @param strings The string literals. There are always at least two strings,
         *   event for fully-controlled bindings with a single expression.
         */handleAttributeExpressions(e,t,n,r){const a=t[0];if("."===a){const r=new T(e,t.slice(1),n);return r.parts}if("@"===a)return[new E(e,t.slice(1),r.eventContext)];if("?"===a)return[new C(e,t.slice(1),n)];const s=new x(e,t,n);return s.parts}/**
         * Create parts for a text-position binding.
         * @param templateFactory
         */handleTextExpression(e){return new N(e)}},w=new Map,R=new WeakMap,O=(t,n,r)=>{let a=R.get(n);a===void 0&&(i(n,n.firstChild),R.set(n,a=new N(Object.assign({templateFactory:e},r))),a.appendInto(n)),a.setValue(t),a.commit()};(window.litHtmlVersions||(window.litHtmlVersions=[])).push("1.0.0");/**
     * Interprets a template literal as an HTML template that can efficiently
     * render to and update a container.
     */const L=(e,...t)=>new S(e,t,"html",k),z=(e,...t)=>new v(e,t,"svg",k),H=133/* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */,M=e=>{let t=11===e.nodeType/* Node.DOCUMENT_FRAGMENT_NODE */?0:1;for(const n=document.createTreeWalker(e,H,null,!1);n.nextNode();)t++;return t},U=(e,t=-1)=>{for(let n=t+1;n<e.length;n++){const t=e[n];if(h(t))return n}return-1},q=(e,t)=>`${e}--${t}`;/**
     * Interprets a template literal as an SVG template that can efficiently
     * render to and update a container.
     */let B=!0;"undefined"==typeof window.ShadyCSS?B=!1:"undefined"==typeof window.ShadyCSS.prepareTemplateDom&&(console.warn("Incompatible ShadyCSS version detected.Please update to at least @webcomponents/webcomponentsjs@2.0.2 and@webcomponents/shadycss@1.3.1."),B=!1);/**
     * Template factory which scopes template DOM using ShadyCSS.
     * @param scopeName {string}
     */const F=e=>t=>{const n=q(t.type,e);let r=w.get(n);void 0===r&&(r={stringsArray:new WeakMap,keyString:new Map},w.set(n,r));let a=r.stringsArray.get(t.strings);if(void 0!==a)return a;const s=t.strings.join(p);if(a=r.keyString.get(s),void 0===a){const n=t.getTemplateElement();B&&window.ShadyCSS.prepareTemplateDom(n,e),a=new g(t,n),r.keyString.set(s,a)}return r.stringsArray.set(t.strings,a),a},W=["html","svg"],D=e=>{W.forEach(n=>{const r=w.get(q(n,e));r!==void 0&&r.keyString.forEach(e=>{const{element:{content:n}}=e,r=new Set;// IE 11 doesn't support the iterable param Set constructor
Array.from(n.querySelectorAll("style")).forEach(e=>{r.add(e)}),t(e,r)})})},j=new Set,$=(e,r,a)=>{j.add(a);// Move styles out of rendered DOM and store.
const s=e.querySelectorAll("style");// If there are no styles, skip unnecessary work
if(0===s.length)return void window.ShadyCSS.prepareTemplateStyles(r.element,a);const d=document.createElement("style");// Collect styles into a single style. This helps us make sure ShadyCSS
// manipulations will not prevent us from being able to fix up template
// part indices.
// NOTE: collecting styles is inefficient for browsers but ShadyCSS
// currently does this anyway. When it does not, this should be changed.
for(let t=0;t<s.length;t++){const e=s[t];e.parentNode.removeChild(e),d.textContent+=e.textContent}// Remove styles from nested templates in this scope.
if(D(a),n(r,d,r.element.content.firstChild),window.ShadyCSS.prepareTemplateStyles(r.element,a),window.ShadyCSS.nativeShadow){// When in native Shadow DOM, re-add styling to rendered content using
// the style ShadyCSS produced.
const t=r.element.content.querySelector("style");e.insertBefore(t.cloneNode(!0),e.firstChild)}else{r.element.content.insertBefore(d,r.element.content.firstChild);const e=new Set;e.add(d),t(r,e)}},Q=(e,t,n)=>{const r=n.scopeName,a=R.has(t),s=t instanceof ShadowRoot&&B&&e instanceof S,d=s&&!j.has(r),o=d?document.createDocumentFragment():t;// When performing first scope render,
// (1) We've rendered into a fragment so that there's a chance to
// `prepareTemplateStyles` before sub-elements hit the DOM
// (which might cause them to render based on a common pattern of
// rendering in a custom element's `connectedCallback`);
// (2) Scope the template with ShadyCSS one time only for this scope.
// (3) Render the fragment into the container and make sure the
// container knows its `part` is the one we just rendered. This ensures
// DOM will be re-used on subsequent renders.
if(O(e,o,Object.assign({templateFactory:F(r)},n)),d){const e=R.get(o);R.delete(o),e.value instanceof y&&$(o,e.value.template,r),i(t,t.firstChild),t.appendChild(o),R.set(t,e)}// After elements have hit the DOM, update styling if this is the
// initial render to this container.
// This is needed whenever dynamic changes are made so it would be
// safest to do every render; however, this would regress performance
// so we leave it up to the user to call `ShadyCSSS.styleElement`
// for dynamic changes.
!a&&s&&window.ShadyCSS.styleElement(t.host)},J=e=>e,X=(e,t)=>{if(e in t)for(;t!==Object.prototype;){if(t.hasOwnProperty(e))return Object.getOwnPropertyDescriptor(t,e);t=Object.getPrototypeOf(t)}},Y={toAttribute(e,t){return t===Boolean?e?"":null:t===Object||t===Array?null==e?e:JSON.stringify(e):e},fromAttribute(e,t){return t===Boolean?null!==e:t===Number?null===e?null:+e:t===Object||t===Array?JSON.parse(e):e}},Z=(e,t)=>t!==e&&(t===t||e===e),G={attribute:!0,type:String,converter:Y,reflect:!1,hasChanged:Z},K=Promise.resolve(!0),ee=1,te=4,ne=8,re=16,ae=32;/**
     * Base element class which manages element properties and attributes. When
     * properties change, the `update` method is asynchronously called. This method
     * should be supplied by subclassers to render updates as desired.
     */class se extends HTMLElement{constructor(){/**
             * Map with keys for any properties that have changed since the last
             * update cycle with previous values.
             */ /**
             * Map with keys of properties that should be reflected when updated.
             */super(),this._updateState=0,this._instanceProperties=void 0,this._updatePromise=K,this._hasConnectedResolver=void 0,this._changedProperties=new Map,this._reflectingProperties=void 0,this.initialize()}/**
         * Returns a list of attributes corresponding to the registered properties.
         * @nocollapse
         */static get observedAttributes(){this._finalize();const e=[];for(const[t,n]of this._classProperties){const r=this._attributeNameForProperty(t,n);r!==void 0&&(this._attributeToPropertyMap.set(r,t),e.push(r))}return e}/**
         * Ensures the private `_classProperties` property metadata is created.
         * In addition to `_finalize` this is also called in `createProperty` to
         * ensure the `@property` decorator can add property metadata.
         */ /** @nocollapse */static _ensureClassProperties(){// ensure private storage for property declarations.
if(!this.hasOwnProperty(J("_classProperties",this))){this._classProperties=new Map;// NOTE: Workaround IE11 not supporting Map constructor argument.
const e=Object.getPrototypeOf(this)._classProperties;e!==void 0&&e.forEach((e,t)=>this._classProperties.set(t,e))}}/**
         * Creates a property accessor on the element prototype if one does not exist.
         * The property setter calls the property's `hasChanged` property option
         * or uses a strict identity check to determine whether or not to request
         * an update.
         * @nocollapse
         */static createProperty(e,t=G){if(this._ensureClassProperties(),this._classProperties.set(e,t),!t.noAccessor){const t=X(e,this.prototype);let n;// If there is a super accessor, capture it and "super" to it
if(void 0!==t&&t.set&&t.get){const{set:r,get:a}=t;n={get(){return a.call(this)},set(t){const n=this[e];r.call(this,t),this.requestUpdate(e,n)},configurable:!0,enumerable:!0}}else{const t="symbol"==typeof e?Symbol():`__${e}`;n={get(){return this[t]},set(n){const r=this[e];this[t]=n,this.requestUpdate(e,r)},configurable:!0,enumerable:!0}}Object.defineProperty(this.prototype,e,n)}}/**
         * Creates property accessors for registered properties and ensures
         * any superclasses are also finalized.
         * @nocollapse
         */static _finalize(){if(!(this.hasOwnProperty(J("finalized",this))&&this.finalized)){// finalize any superclasses
const e=Object.getPrototypeOf(this);// make any properties
// Note, only process "own" properties since this element will inherit
// any properties defined on the superClass, and finalization ensures
// the entire prototype chain is finalized.
if("function"==typeof e._finalize&&e._finalize(),this.finalized=!0,this._ensureClassProperties(),this._attributeToPropertyMap=new Map,this.hasOwnProperty(J("properties",this))){const e=this.properties,t=[...Object.getOwnPropertyNames(e),...("function"==typeof Object.getOwnPropertySymbols?Object.getOwnPropertySymbols(e):[])];// support symbols in properties (IE11 does not support this)
for(const n of t)// note, use of `any` is due to TypeSript lack of support for symbol in
// index types
this.createProperty(n,e[n])}}}/**
         * Returns the property name for the given attribute `name`.
         * @nocollapse
         */static _attributeNameForProperty(e,t){const n=t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}/**
         * Returns true if a property should request an update.
         * Called when a property value is set and uses the `hasChanged`
         * option for the property if present or a strict identity check.
         * @nocollapse
         */static _valueHasChanged(e,t,n=Z){return n(e,t)}/**
         * Returns the property value for the given attribute value.
         * Called via the `attributeChangedCallback` and uses the property's
         * `converter` or `converter.fromAttribute` property option.
         * @nocollapse
         */static _propertyValueFromAttribute(e,t){const n=t.type,r=t.converter||Y,a="function"==typeof r?r:r.fromAttribute;return a?a(e,n):e}/**
         * Returns the attribute value for the given property value. If this
         * returns undefined, the property will *not* be reflected to an attribute.
         * If this returns null, the attribute will be removed, otherwise the
         * attribute will be set to the value.
         * This uses the property's `reflect` and `type.toAttribute` property options.
         * @nocollapse
         */static _propertyValueToAttribute(e,t){if(void 0===t.reflect)return;const n=t.type,r=t.converter,a=r&&r.toAttribute||Y.toAttribute;return a(e,n)}/**
         * Performs element initialization. By default captures any pre-set values for
         * registered properties.
         */initialize(){this._saveInstanceProperties()}/**
         * Fixes any properties set on the instance before upgrade time.
         * Otherwise these would shadow the accessor and break these properties.
         * The properties are stored in a Map which is played back after the
         * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
         * (<=41), properties created for native platform properties like (`id` or
         * `name`) may not have default values set in the element constructor. On
         * these browsers native properties appear on instances and therefore their
         * default value will overwrite any element default (e.g. if the element sets
         * this.id = 'id' in the constructor, the 'id' will become '' since this is
         * the native platform default).
         */_saveInstanceProperties(){for(const[e]of this.constructor._classProperties)if(this.hasOwnProperty(e)){const t=this[e];delete this[e],this._instanceProperties||(this._instanceProperties=new Map),this._instanceProperties.set(e,t)}}/**
         * Applies previously saved instance properties.
         */_applyInstanceProperties(){for(const[e,t]of this._instanceProperties)this[e]=t;this._instanceProperties=void 0}connectedCallback(){this._updateState|=ae,this._hasConnectedResolver?(this._hasConnectedResolver(),this._hasConnectedResolver=void 0):this.requestUpdate()}/**
         * Allows for `super.disconnectedCallback()` in extensions while
         * reserving the possibility of making non-breaking feature additions
         * when disconnecting at some point in the future.
         */disconnectedCallback(){}/**
         * Synchronizes property values when attributes change.
         */attributeChangedCallback(e,t,n){t!==n&&this._attributeToProperty(e,n)}_propertyToAttribute(e,t,n=G){const r=this.constructor,a=r._attributeNameForProperty(e,n);if(a!==void 0){const e=r._propertyValueToAttribute(t,n);// an undefined value does not change the attribute.
if(e===void 0)return;// Track if the property is being reflected to avoid
// setting the property again via `attributeChangedCallback`. Note:
// 1. this takes advantage of the fact that the callback is synchronous.
// 2. will behave incorrectly if multiple attributes are in the reaction
// stack at time of calling. However, since we process attributes
// in `update` this should not be possible (or an extreme corner case
// that we'd like to discover).
// mark state reflecting
// mark state not reflecting
this._updateState|=ne,null==e?this.removeAttribute(a):this.setAttribute(a,e),this._updateState&=~ne}}_attributeToProperty(e,t){// Use tracking info to avoid deserializing attribute value if it was
// just set from a property setter.
if(this._updateState&ne)return;const n=this.constructor,r=n._attributeToPropertyMap.get(e);if(r!==void 0){const e=n._classProperties.get(r)||G;// mark state reflecting
// mark state not reflecting
this._updateState|=re,this[r]=n._propertyValueFromAttribute(t,e),this._updateState&=~re}}/**
         * Requests an update which is processed asynchronously. This should
         * be called when an element should update based on some state not triggered
         * by setting a property. In this case, pass no arguments. It should also be
         * called when manually implementing a property setter. In this case, pass the
         * property `name` and `oldValue` to ensure that any configured property
         * options are honored. Returns the `updateComplete` Promise which is resolved
         * when the update completes.
         *
         * @param name {PropertyKey} (optional) name of requesting property
         * @param oldValue {any} (optional) old value of requesting property
         * @returns {Promise} A Promise that is resolved when the update completes.
         */requestUpdate(e,t){let n=!0;// if we have a property key, perform property update steps.
if(void 0!==e&&!this._changedProperties.has(e)){const r=this.constructor,a=r._classProperties.get(e)||G;r._valueHasChanged(this[e],t,a.hasChanged)?(this._changedProperties.set(e,t),!0===a.reflect&&!(this._updateState&re)&&(void 0===this._reflectingProperties&&(this._reflectingProperties=new Map),this._reflectingProperties.set(e,a))):n=!1}return!this._hasRequestedUpdate&&n&&this._enqueueUpdate(),this.updateComplete}/**
         * Sets up the element to asynchronously update.
         */async _enqueueUpdate(){this._updateState|=te;let e;const t=this._updatePromise;this._updatePromise=new Promise(t=>e=t),await t,this._hasConnected||(await new Promise(e=>this._hasConnectedResolver=e));// Allow `performUpdate` to be asynchronous to enable scheduling of updates.
const n=this.performUpdate();// Note, this is to avoid delaying an additional microtask unless we need
// to.
null!=n&&"function"==typeof n.then&&(await n),e(!this._hasRequestedUpdate)}get _hasConnected(){return this._updateState&ae}get _hasRequestedUpdate(){return this._updateState&te}get hasUpdated(){return this._updateState&ee}/**
         * Performs an element update.
         *
         * You can override this method to change the timing of updates. For instance,
         * to schedule updates to occur just before the next frame:
         *
         * ```
         * protected async performUpdate(): Promise<unknown> {
         *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
         *   super.performUpdate();
         * }
         * ```
         */performUpdate(){if(this._instanceProperties&&this._applyInstanceProperties(),this.shouldUpdate(this._changedProperties)){const e=this._changedProperties;this.update(e),this._markUpdated(),this._updateState&ee||(this._updateState|=ee,this.firstUpdated(e)),this.updated(e)}else this._markUpdated()}_markUpdated(){this._changedProperties=new Map,this._updateState&=~te}/**
         * Returns a Promise that resolves when the element has completed updating.
         * The Promise value is a boolean that is `true` if the element completed the
         * update without triggering another update. The Promise result is `false` if
         * a property was set inside `updated()`. This getter can be implemented to
         * await additional state. For example, it is sometimes useful to await a
         * rendered element before fulfilling this Promise. To do this, first await
         * `super.updateComplete` then any subsequent state.
         *
         * @returns {Promise} The Promise returns a boolean that indicates if the
         * update resolved without triggering another update.
         */get updateComplete(){return this._updatePromise}/**
         * Controls whether or not `update` should be called when the element requests
         * an update. By default, this method always returns `true`, but this can be
         * customized to control when to update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */shouldUpdate(e){return!0}/**
         * Updates the element. This method reflects property values to attributes.
         * It can be overridden to render and keep updated element DOM.
         * Setting properties inside this method will *not* trigger
         * another update.
         *
         * * @param _changedProperties Map of changed properties with old values
         */update(e){if(this._reflectingProperties!==void 0&&0<this._reflectingProperties.size){for(const[e,t]of this._reflectingProperties)this._propertyToAttribute(e,this[e],t);this._reflectingProperties=void 0}}/**
         * Invoked whenever the element is updated. Implement to perform
         * post-updating tasks via DOM APIs, for example, focusing an element.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */updated(e){}/**
         * Invoked when the element is first updated. Implement to perform one time
         * work on the element after update.
         *
         * Setting properties inside this method will trigger the element to update
         * again after this update cycle completes.
         *
         * * @param _changedProperties Map of changed properties with old values
         */firstUpdated(e){}}/**
     * Marks class as having finished creating properties.
     */se.finalized=!0;/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */ /**
    @license
    Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at
    http://polymer.github.io/LICENSE.txt The complete set of authors may be found at
    http://polymer.github.io/AUTHORS.txt The complete set of contributors may be
    found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as
    part of the polymer project is also subject to an additional IP rights grant
    found at http://polymer.github.io/PATENTS.txt
    */const de="adoptedStyleSheets"in Document.prototype;class ie{constructor(e){this.cssText=e}// Note, this is a getter so that it's lazy. In practice, this means
// stylesheets are not created until the first element instance is made.
get styleSheet(){return void 0===this._styleSheet&&(de?(this._styleSheet=new CSSStyleSheet,this._styleSheet.replaceSync(this.cssText)):this._styleSheet=null),this._styleSheet}}const oe=e=>{if(e instanceof ie)return e.cssText;throw new Error(`Value passed to 'css' function must be a 'css' function result: ${e}.`)},le=(e,...t)=>{const n=t.reduce((t,n,r)=>t+oe(n)+e[r+1],e[0]);return new ie(n)};/**
     * @license
     * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
     * This code may only be used under the BSD style license found at
     * http://polymer.github.io/LICENSE.txt
     * The complete set of authors may be found at
     * http://polymer.github.io/AUTHORS.txt
     * The complete set of contributors may be found at
     * http://polymer.github.io/CONTRIBUTORS.txt
     * Code distributed by Google as part of the polymer project is also
     * subject to an additional IP rights grant found at
     * http://polymer.github.io/PATENTS.txt
     */class pe extends se{/**
         * Array of styles to apply to the element. The styles should be defined
         * using the `css` tag function.
         */static get styles(){return[]}static get _uniqueStyles(){if(this._styles===void 0){const e=this.styles,t=e.reduceRight((e,t)=>(e.add(t),e),new Set);// As a performance optimization to avoid duplicated styling that can
// occur especially when composing via subclassing, de-duplicate styles
// preserving the last item in the list. The last item is kept to
// try to preserve cascade order with the assumption that it's most
// important that last added styles override previous styles.
// Array.form does not work on Set in IE
this._styles=[],t.forEach(e=>this._styles.unshift(e))}return this._styles}/**
         * Performs element initialization. By default this calls `createRenderRoot`
         * to create the element `renderRoot` node and captures any pre-set values for
         * registered properties.
         */initialize(){super.initialize(),this.renderRoot=this.createRenderRoot(),window.ShadowRoot&&this.renderRoot instanceof window.ShadowRoot&&this.adoptStyles()}/**
         * Returns the node into which the element should render and by default
         * creates and returns an open shadowRoot. Implement to customize where the
         * element's DOM is rendered. For example, to render into the element's
         * childNodes, return `this`.
         * @returns {Element|DocumentFragment} Returns a node into which to render.
         */createRenderRoot(){return this.attachShadow({mode:"open"})}/**
         * Applies styling to the element shadowRoot using the `static get styles`
         * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where
         * available and will fallback otherwise. When Shadow DOM is polyfilled,
         * ShadyCSS scopes styles and adds them to the document. When Shadow DOM
         * is available but `adoptedStyleSheets` is not, styles are appended to the
         * end of the `shadowRoot` to [mimic spec
         * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
         */adoptStyles(){const e=this.constructor._uniqueStyles;0===e.length||(window.ShadyCSS===void 0||window.ShadyCSS.nativeShadow?de?this.renderRoot.adoptedStyleSheets=e.map(e=>e.styleSheet):this._needsShimAdoptedStyleSheets=!0:window.ShadyCSS.ScopingShim.prepareAdoptedCssText(e.map(e=>e.cssText),this.localName));// There are three separate cases here based on Shadow DOM support.
// (1) shadowRoot polyfilled: use ShadyCSS
// (2) shadowRoot.adoptedStyleSheets available: use it.
// (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after
// rendering
}connectedCallback(){super.connectedCallback(),this.hasUpdated&&window.ShadyCSS!==void 0&&window.ShadyCSS.styleElement(this)}/**
         * Updates the element. This method reflects property values to attributes
         * and calls `render` to render DOM via lit-html. Setting properties inside
         * this method will *not* trigger another update.
         * * @param _changedProperties Map of changed properties with old values
         */update(e){super.update(e);const t=this.render();t instanceof S&&this.constructor.render(t,this.renderRoot,{scopeName:this.localName,eventContext:this}),this._needsShimAdoptedStyleSheets&&(this._needsShimAdoptedStyleSheets=!1,this.constructor._uniqueStyles.forEach(e=>{const t=document.createElement("style");t.textContent=e.cssText,this.renderRoot.appendChild(t)}))}/**
         * Invoked on each update to perform rendering tasks. This method must return
         * a lit-html TemplateResult. Setting properties inside this method will *not*
         * trigger the element to update.
         */render(){}}/**
     * Ensure this class is marked as `finalized` as an optimization ensuring
     * it will not needlessly try to `finalize`.
     */pe.finalized=!0,pe.render=Q;var ue={prefix:"fas",iconName:"times",icon:[352,512,[],"f00d","M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"]},ce={prefix:"fas",iconName:"envelope",icon:[512,512,[],"f0e0","M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V400c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5 0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"]},me={prefix:"fas",iconName:"phone",icon:[512,512,[],"f095","M493.4 24.6l-104-24c-11.3-2.6-22.9 3.3-27.5 13.9l-48 112c-4.2 9.8-1.4 21.3 6.9 28l60.6 49.6c-36 76.7-98.9 140.5-177.2 177.2l-49.6-60.6c-6.8-8.3-18.2-11.1-28-6.9l-112 48C3.9 366.5-2 378.1.6 389.4l24 104C27.1 504.2 36.7 512 48 512c256.1 0 464-207.5 464-464 0-11.2-7.7-20.9-18.6-23.4z"]},ge={prefix:"fas",iconName:"home",icon:[576,512,[],"f015","M488 312.7V456c0 13.3-10.7 24-24 24H348c-6.6 0-12-5.4-12-12V356c0-6.6-5.4-12-12-12h-72c-6.6 0-12 5.4-12 12v112c0 6.6-5.4 12-12 12H112c-13.3 0-24-10.7-24-24V312.7c0-3.6 1.6-7 4.4-9.3l188-154.8c4.4-3.6 10.8-3.6 15.3 0l188 154.8c2.7 2.3 4.3 5.7 4.3 9.3zm83.6-60.9L488 182.9V44.4c0-6.6-5.4-12-12-12h-56c-6.6 0-12 5.4-12 12V117l-89.5-73.7c-17.7-14.6-43.3-14.6-61 0L4.4 251.8c-5.1 4.2-5.8 11.8-1.6 16.9l25.5 31c4.2 5.1 11.8 5.8 16.9 1.6l235.2-193.7c4.4-3.6 10.8-3.6 15.3 0l235.2 193.7c5.1 4.2 12.7 3.5 16.9-1.6l25.5-31c4.2-5.2 3.4-12.7-1.7-16.9z"]};/*
     * Copyright 2018 Brigham Young University
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *    http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */const{IntersectionObserver:he,CustomEvent:fe}=window;class _e extends pe{static get properties(){return{results:{type:Array},context:{type:String},noAutoselect:{type:Boolean},searchPending:{type:Boolean}}}static get styles(){return[le`
      :host {
        display: block;
      }
      :host[hidden] {
        display: none;
      }
      .modal {
        z-index: 98;
        background-color: rgba(0, 0, 0, 0.6);
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      }
      .results {
        z-index: 99;
        position: fixed;
        left: 0;
        right: 0;
        top: 20vh;
        bottom: 0;
        padding: 0.5rem;
        background-color: white;
        color: #141414;
        display: grid;
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr auto;
        grid-gap: 0.5rem;
        overflow: auto;
      }
      .close-modal {
        z-index: 100;
        position: fixed;
        right: 0;
        top: calc(20vh - 2rem);
        border-radius: 50%;
        display: inline-flex;
        justify-content: center;
        align-items: center;
        padding: 0.3rem;
        border: 1px solid #5199E1;
        cursor: pointer;
        box-shadow: 0rem 0rem 1rem #5199E1;
      }
      h2 {
        margin: 0;
      }
      table {
        border-collapse: collapse;
      }
      th, td {
        padding: 0.5rem;
        border-bottom: 1px solid #666666;
      }
      th {
        text-align: left;
        background-color: #0057B8;
        color: white;
        padding: 1rem;
      }
      tbody tr { cursor: pointer; }
      tbody tr:nth-child(odd) {
        background-color: #E6E6E6;
      }
      tbody tr.placeholder { cursor: default; }
      ol, ul {
        margin: 0;
        padding: 0;
        display: inline-flex;
        flex-direction: column;
      }
      li {
        list-style-type: none;
        margin: 0;
      }
      .nav-btn {
        padding: 0.3rem 1rem;
        border: thin solid #666666;
        border-radius: 0.05rem;
        color: white;
        cursor: pointer;
        justify-self: start;
        align-self: center;
      }
      button {
        font-size: 1.1rem;
        background-color: #0057B8;
      }
      button:hover, button:active {
        box-shadow: inset 0 0 0.2rem rgba(255, 255, 255, 0.5);
        background-color: #5199E1;
      }
      .deck {
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
        grid-gap: 1rem;
      }
      .card {
        border: thin solid #666666;
        border-left: 0.5rem solid #002E5D;
        padding: 0.5rem;
        display: grid;
        grid-template-columns: 1fr;
        grid-auto-rows: auto;
        grid-gap: 0.5rem;
        cursor: pointer;
      }
      .card h3 {
        margin: 0;
      }
      .contact {
        display: flex;
        flex-direction: column;
      }
      .contact div {
        display: inline-grid;
        grid-template-columns: auto 1fr;
        grid-gap: 0.25rem;
      }
      .contact div svg {
        margin-top: calc(1rem - 14px);
      }
      .card.placeholder { cursor: default; }
      svg.placeholder { filter: blur(1px); width: 100%; height: 6rem; }
      tr.placeholder svg.placeholder { width: 100%; max-height: 1rem; }
      svg.placeholder rect {
        animation: pulse 1000ms ease-in-out infinite alternate;
      }
      @keyframes pulse {
        from { fill: #999999; }
        70% { fill: #999999; }
        to { fill: #B3B5B7; }
      }
      @media only screen and (min-width: 650px) {
        .deck {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(28rem, 1fr));
          grid-auto-rows: auto;
          grid-gap: 1rem;
        }
        .card {
          border: thin solid #666666;
          border-left: 0.5rem solid #002E5D;
          padding: 0.5rem;
          display: grid;
          grid-template-columns: 1fr 1fr;
          grid-template-rows: auto auto;
          grid-gap: 0.5rem;
          cursor: pointer;
        }
        .card h3 {
          margin: 0;
          grid-column: 1/-1;
        }
      }
      @media only screen and (min-width: 900px) {
        .results {
          left: 10vw;
          right: 10vw;
          top: 10vh;
          max-height: 85vh;
        }
        .close-modal {
          right: calc(10vw - 2rem);
          top: calc(10vh - 2rem);
        }
      }
    `]}constructor(){super(),this.results=null,this.context="directory",this.noAutoselect=!1,this.searchPending=!1,this.isObserving=!1}updated(e){/*
         * changedProperties.forEach((oldValue, propName) => {
         *   console.log(`lookup-results::property changed!
         *     ${propName}: '${oldValue}' => '${this[propName]}'`)
         * })
         */if(this.results&&1===this.results.length&&!this.noAutoselect)// Do Autoselect
return this.select(this.results[0]);if(this.results&&0<this.results.length&&!this.isObserving){// console.log('lookup-results::set up intersection observer')
const e=this.shadowRoot.getElementById("top"),t=this.shadowRoot.getElementById("bottom");if(!he||!e||!t)return;const n=new he(n=>{n.forEach(n=>{n.isIntersecting&&(n.target===t?this.next():n.target===e&&this.prev())})},{});// observer.observe(top)
// console.log('lookup-results::observing!', bottom)
n.observe(t),this.isObserving=!0}}render(){// console.log(`byu-person-lookup-results::_render::searchPending=${searchPending}`)
const e=()=>[1,2,3,4,5,6].map(()=>L`
      <tr class="placeholder"><td colspan="5">
        <svg class="placeholder" viewBox="0 0 100 5" preserveAspectRatio="none">
          ${z`<rect x="1" y="1" width="98" height="3" fill="#999999"></rect>`}
        </svg>
      </td></tr>
    `),t=()=>[1,2,3,4,5,6].map(()=>L`
      <div class="card placeholder">
        <svg class="placeholder" viewBox="0 0 50 40" preserveAspectRatio="none">
          <rect x="1" y="1" width="40" height="15" fill="#999999"></rect>
          <rect x="1" y="25" width="45" height="5" fill="#999999"></rect>
          <rect x="1" y="33" width="30" height="5" fill="#999999"></rect>
        </svg>
        <svg class="placeholder" viewBox="0 0 50 40" preserveAspectRatio="none">
          <rect x="1" y="17" width="45" height="5" fill="#999999"></rect>
          <rect x="1" y="25" width="30" height="5" fill="#999999"></rect>
          <rect x="1" y="33" width="35" height="5" fill="#999999"></rect>
        </svg>
      </div>
    `),n=e=>L`
      <ul>
        ${e.map(e=>L`<li>${e}</li>`)}
      </ul>
    `,a=e=>L`
      <tr @click=${()=>this.select(e)}>
        <td>${e.name}</td>
        <td>${e.byuId}</td>
        <td>${e.netId}</td>
        <td>${e.employeeStatus}</td>
        <td>${e.studentStatus}</td>
      </tr>
    `,s=e=>e.showAdditionalInfo&&e.additionalInfo?L`
          <ul>
            ${e.additionalInfo.map(e=>L`<li>${e}</li>`)}
          </ul>
        `:L`<div></div>`,[,,,,d]=ce.icon,[,,,,i]=me.icon,[,,,,o]=ge.icon,[,,,,l]=ue.icon,p=z`
    <path d=${l} fill="white" transform="translate(90)"/>
    `,u=e=>L`
      <svg width="14" height="14" viewBox="0 0 512 512">
        ${z`<path d=${e} fill="#666666"/>`}
      </svg>
    `,c=e=>L`
      <div class="card" @click=${()=>this.select(e)}>
        <h3>${e.name}</h3>
        ${s(e)}
        <div class="contact">
          <div>${u(d)}${e.email}</div>
          <div>${u(i)}${e.phone}</div>
          <div>${u(o)}${e.address?n(e.address):""}</div>
        </div>
      </div>
    `;return this.results&&this.results.map&&!(1>this.results.length)?L`
      <div class="modal">
        <div class="results">
          <h2 id="top">Lookup Results</h2>
          ${this.context&&"admin"===this.context?(t=>L`
      <table>
        <thead>
          <tr>
            <th>Name</th>
            <th>BYU ID</th>
            <th>Net ID</th>
            <th>EMP Status</th>
            <th>STD Status</th>
          </tr>
        </thead>
        <tbody>
          ${t.map(e=>a(e))}
          ${this.searchPending?e():""}
        </tbody>
      </table>
    `)(this.results):(e=>L`
      <div class="deck">
        ${e.map(e=>c(e))}
        ${this.searchPending?t():""}
      </div>
    `)(this.results)}
          <div class="spacer"></div>
          ${he?L`<button id="bottom" class="nav-btn" @click=${this.close}>Close</button>`:L`<div>
             <button class="nav-btn" @click=${this.prev}>Prev</button>
             <button class="nav-btn" @click=${this.next}>Next</button>
           </div>`}
        </div>
        <button class="close-modal" @click=${()=>this.close()}>
          <svg alt="Search" width="24" height="24" viewBox="0 0 512 512">
            ${p}
          </svg>
        </button>
      </div>
    `:L``}dispatch(e,t){const n=t?{detail:t,bubbles:!0,composed:!0}:{bubbles:!0,composed:!0},r=new fe(e,n);this.dispatchEvent(r)}select(e){const{personId:t,byuId:n,netId:r,name:a}=e;this.dispatch("byu-lookup-results-select",{personId:t,byuId:n,netId:r,name:a}),this.close()}close(){this.dispatch("byu-lookup-results-close"),this.isObserving=!1}next(){this.searchPending||this.dispatch("byu-lookup-next-page")}prev(){this.searchPending||this.dispatch("byu-lookup-prev-page")}}return _e}();
